{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/raccoon/source/css/article.scss","path":"css/article.scss","modified":1,"renderable":1},{"_id":"themes/raccoon/source/css/style.scss","path":"css/style.scss","modified":1,"renderable":1},{"_id":"themes/raccoon/source/css/variables.scss","path":"css/variables.scss","modified":0,"renderable":1},{"_id":"themes/raccoon/source/css/buttons.scss","path":"css/buttons.scss","modified":1,"renderable":1},{"_id":"themes/raccoon/source/css/mixins.scss","path":"css/mixins.scss","modified":0,"renderable":1},{"_id":"themes/raccoon/source/css/sidebar.scss","path":"css/sidebar.scss","modified":1,"renderable":1},{"_id":"themes/raccoon/source/css/mixins/blocks.scss","path":"css/mixins/blocks.scss","modified":1,"renderable":1},{"_id":"themes/raccoon/source/images/new-raccoon-logo.svg","path":"images/new-raccoon-logo.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/_data/authors.json","hash":"5c38011c294361b1ec78ef962d9aa0e2dee05fd4","modified":1463848869425},{"_id":"source/_posts/es6-arrow-functions.md","hash":"180c2be2905162c79cc2498c8eb2bd7d55ae813f","modified":1463925011211},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1463582993066},{"_id":"themes/raccoon/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1463575505752},{"_id":"themes/raccoon/source/css/_highlight.scss","hash":"04b9b8a3a11eff2637b99435bf8d5a5aef0d1b59","modified":1463652391096},{"_id":"themes/raccoon/source/css/article.scss","hash":"1566a9a855e94999cbcec3966657a98e7097696d","modified":1464164777667},{"_id":"themes/raccoon/source/css/style.scss","hash":"6401f328c6925c0449c6b6ef7bf73b25987278b6","modified":1464164917666},{"_id":"themes/raccoon/source/css/variables.scss","hash":"389bf70a8444037217884f013e55a85903237e6a","modified":1463831362047},{"_id":"themes/raccoon/source/css/modules/_breakpoint/_breakpoint.scss","hash":"111e3d27596320f01d6bb588a046ed6a5a84461c","modified":1463636099150},{"_id":"themes/raccoon/source/css/modules/guttenberg/_gutenberg-config.scss","hash":"04c32b86b283221be9c8df094163db654330a393","modified":1463635918275},{"_id":"themes/raccoon/source/css/modules/guttenberg/_gutenberg-mixins.scss","hash":"825701cdc03e77b6c4f30b76f8ce23bbf7eae1c7","modified":1463635918272},{"_id":"themes/raccoon/source/css/modules/guttenberg/_gutenberg-responsive.scss","hash":"dca00403e2d1322c16f64d96afdbceccf8a85cdc","modified":1463637591300},{"_id":"themes/raccoon/source/css/modules/guttenberg/_gutenberg-reset.scss","hash":"d68dfca9f65161417d83800c154501c1de3813fe","modified":1463637575795},{"_id":"themes/raccoon/source/css/modules/guttenberg/_gutenberg-style.scss","hash":"45b4b694f7af918d6171edca9ca2a86a3cafff13","modified":1463637350559},{"_id":"themes/raccoon/source/css/modules/guttenberg/_gutenberg-typography.scss","hash":"c73be77e17dc79534c8a567b2702956c1ec5e304","modified":1463637602961},{"_id":"themes/raccoon/source/css/modules/guttenberg/_gutenberg.scss","hash":"95ea1f5f3dd1f527f3aae46971e73c6a3cda2887","modified":1463635918279},{"_id":"themes/raccoon/source/css/modules/_breakpoint/breakpoint/_context.scss","hash":"bcd0da3f48eef0372ecd9fcb59dda7ec810c8da0","modified":1463636099151},{"_id":"themes/raccoon/source/css/modules/_breakpoint/breakpoint/_legacy-settings.scss","hash":"6fdf1193db85b6362d7a636f768bebbf2dd782a7","modified":1463636099153},{"_id":"themes/raccoon/source/css/modules/_breakpoint/breakpoint/_helpers.scss","hash":"6cc193806af918dcea3d85655ba1c1d1cda1e568","modified":1463636099153},{"_id":"themes/raccoon/source/css/modules/_breakpoint/breakpoint/_no-query.scss","hash":"49e883eac2487a03d9951922111cb2a51b73b27e","modified":1463636099154},{"_id":"themes/raccoon/source/css/modules/_breakpoint/breakpoint/_parsers.scss","hash":"49d01b36dee60979faab409206a9ac3329525180","modified":1463636099155},{"_id":"themes/raccoon/source/css/modules/_breakpoint/breakpoint/_respond-to.scss","hash":"517640571f532dffbfcd3734051b108f7cd1d882","modified":1463636099155},{"_id":"themes/raccoon/source/css/modules/_breakpoint/breakpoint/_settings.scss","hash":"4d4b9bf7cb0e71568b543c6758db4b6094d18518","modified":1463636099157},{"_id":"themes/raccoon/source/css/modules/_breakpoint/breakpoint/parsers/_double.scss","hash":"ce6e641bf257f85bfedf1507a5f61f82e134ff03","modified":1463636099158},{"_id":"themes/raccoon/source/css/modules/_breakpoint/breakpoint/parsers/_query.scss","hash":"2224a5bd7d2670076f209b1c49d0dbd28a6e00df","modified":1463636099159},{"_id":"themes/raccoon/source/css/modules/_breakpoint/breakpoint/parsers/_single.scss","hash":"d0b223f7c720cb4166ab7ae2ac3d6e241006e57e","modified":1463636099161},{"_id":"themes/raccoon/source/css/modules/_breakpoint/breakpoint/parsers/_resolution.scss","hash":"825a2c87b34c2a06995f030738cebdbf692f7ff1","modified":1463636099160},{"_id":"themes/raccoon/source/css/modules/_breakpoint/breakpoint/parsers/_triple.scss","hash":"c2bf2576bddf0b6035aa1f570f366152fe7be153","modified":1463636099161},{"_id":"themes/raccoon/source/css/modules/_breakpoint/breakpoint/parsers/double/_default-pair.scss","hash":"9394f2d95c6c1c498a612a412a1ead429e78535d","modified":1463636099162},{"_id":"themes/raccoon/source/css/modules/_breakpoint/breakpoint/parsers/double/_default.scss","hash":"1f5f025c7b52e554ab07ae4f89a2aa181628f6b4","modified":1463636099163},{"_id":"themes/raccoon/source/css/modules/_breakpoint/breakpoint/parsers/double/_double-string.scss","hash":"ad5d4ccfa901854cfafda3154040eb8bc7ecac4c","modified":1463636099164},{"_id":"themes/raccoon/source/css/modules/_breakpoint/breakpoint/parsers/single/_default.scss","hash":"520d895aa78dd0dff17821c23cd091b7782ddeb3","modified":1463636099165},{"_id":"themes/raccoon/source/css/modules/_breakpoint/breakpoint/parsers/resolution/_resolution.scss","hash":"d3ad320b42d17092654ce65bcb8deb30bdb89c10","modified":1463636099165},{"_id":"themes/raccoon/source/css/modules/_breakpoint/breakpoint/parsers/triple/_default.scss","hash":"ae69eb8fdea6e5461bf5905365c6d1252af69757","modified":1463636099166},{"_id":"themes/raccoon/source/_data/authors.json","hash":"5c38011c294361b1ec78ef962d9aa0e2dee05fd4","modified":1463848869425},{"_id":"themes/raccoon/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1463575505778},{"_id":"themes/raccoon/layout/_partial/after-footer.ejs","hash":"82a30f81c0e8ba4a8af17acd6cc99e93834e4d5e","modified":1463575505778},{"_id":"themes/raccoon/layout/_partial/post/category.ejs","hash":"876f51ec29607379b6fae71a1b85c5134f0bc24f","modified":1463916765611},{"_id":"themes/raccoon/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1463575505804},{"_id":"themes/raccoon/layout/_partial/post/date.ejs","hash":"a956b3936c0f888e25ad5f77f7457964278b5949","modified":1463934179538},{"_id":"themes/raccoon/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1463575505778},{"_id":"themes/raccoon/layout/_widget/recent_posts.ejs","hash":"dcdd88bd79c40d5d2ada558ddc375beb2910f2a1","modified":1464441847561},{"_id":"themes/raccoon/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1463575505781},{"_id":"themes/raccoon/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1463575505781},{"_id":"themes/raccoon/_config.yml","hash":"fb8c98a0f6ff9f962637f329c22699721854cd73","modified":1463575505739},{"_id":"themes/raccoon/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1463575505752},{"_id":"themes/raccoon/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1463575505752},{"_id":"themes/raccoon/layout/layout.ejs","hash":"a139493f78484dadb2ad4a1e1ece06bf505fcebe","modified":1464169853087},{"_id":"themes/raccoon/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1463575505752},{"_id":"themes/raccoon/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1463575505753},{"_id":"themes/raccoon/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1463575505758},{"_id":"themes/raccoon/source/css/buttons.scss","hash":"ccaf4197a6d086756c0e2a43aa590e66e6e4e806","modified":1464013417751},{"_id":"themes/raccoon/source/css/main.css","hash":"f4c815878cb86f767f23099e654f8f8d29ed5ee0","modified":1463938555712},{"_id":"themes/raccoon/source/_data/categories.json","hash":"bdf7d6fbcbb54bafb5bd130a77625ebfaa63fc13","modified":1463915027366},{"_id":"themes/raccoon/source/css/main.css.map","hash":"ce385a255f058dea2cc92b03e37c9475c8afa603","modified":1463938555933},{"_id":"themes/raccoon/source/css/mixins.scss","hash":"66bd3ce0a5d4192ed7a63c597215266462a0861b","modified":1463941694371},{"_id":"themes/raccoon/layout/_partial/article.ejs","hash":"55712a5a3ad8f6070fe9143c7a4a83874f071b17","modified":1463936214530},{"_id":"themes/raccoon/layout/_partial/archive.ejs","hash":"931aaaffa0910a48199388ede576184ff15793ee","modified":1463575505778},{"_id":"themes/raccoon/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1463575505778},{"_id":"themes/raccoon/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1463575505778},{"_id":"themes/raccoon/layout/_partial/head.ejs","hash":"4ddc777969858ff6516a42ee4bb86ae610fc2bb8","modified":1463915911744},{"_id":"themes/raccoon/layout/_partial/header.ejs","hash":"c21ca56f419d01a9f49c27b6be9f4a98402b2aa3","modified":1463575505779},{"_id":"themes/raccoon/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1463575505781},{"_id":"themes/raccoon/layout/_pold/index.ejs","hash":"429bbf7965cad9300821eb9d705bfe7b3890e231","modified":1463850531841},{"_id":"themes/raccoon/layout/_partial/sidebar.ejs","hash":"a5603f46c39da59f2bd9ca3bd147d2a1659985e2","modified":1464165249234},{"_id":"themes/raccoon/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1463575505785},{"_id":"themes/raccoon/source/css/modules/_gridlex.scss","hash":"1a29fdf6b8a0e342513c99b46425688f0ed57683","modified":1464165351429},{"_id":"themes/raccoon/source/css/modules/_normalize.scss","hash":"8ba9aca6723d38559c0e093bce46811dff9c5982","modified":1463908545043},{"_id":"themes/raccoon/layout/_partial/post/author.ejs","hash":"ad4f3c939310eed8b213fd8262405b6d72605331","modified":1463934214047},{"_id":"themes/raccoon/layout/_partial/helpers/icon.ejs","hash":"7190586830852823db8129e2863085658324ef22","modified":1463921753342},{"_id":"themes/raccoon/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1463575505804},{"_id":"themes/raccoon/layout/_partial/post/tag.ejs","hash":"760cec0db71ca80f644b248ebce973f7c1516dde","modified":1463924608448},{"_id":"themes/raccoon/layout/_partial/post/title.ejs","hash":"7a7f2c106dc191746ad069785e71748474cfebbe","modified":1463915608611},{"_id":"themes/raccoon/source/css/.sass-cache/0895f2350e024f7dcf51176252f556aa4470286b/_highlight.scssc","hash":"aaa9d55cf485febbf92d3055a06f10f0db0c4175","modified":1463938478113},{"_id":"themes/raccoon/source/css/.sass-cache/0895f2350e024f7dcf51176252f556aa4470286b/article.scssc","hash":"3236fa0fde256c397c02941efb429c97f7173307","modified":1463938555460},{"_id":"themes/raccoon/source/css/.sass-cache/0895f2350e024f7dcf51176252f556aa4470286b/buttons.scssc","hash":"86d59f37b4fd050d5be9795f183db0f4cb3c4a98","modified":1463938555465},{"_id":"themes/raccoon/source/css/.sass-cache/0895f2350e024f7dcf51176252f556aa4470286b/mixins.scssc","hash":"733452315c768eff7a4b2051ec3cd6176b0ec1aa","modified":1463938478027},{"_id":"themes/raccoon/source/css/.sass-cache/0895f2350e024f7dcf51176252f556aa4470286b/variables.scssc","hash":"7d3e6316d15a1455cb5ce75b2da5a7e59e58f1be","modified":1463938478022},{"_id":"themes/raccoon/source/css/.sass-cache/0895f2350e024f7dcf51176252f556aa4470286b/style.scssc","hash":"d4a1ecb927d930c33c306318b06dd7ddc8a6e5b9","modified":1463938478018},{"_id":"themes/raccoon/source/css/.sass-cache/28944330a0348fe5435be23aa66a3e250781d167/_default.scssc","hash":"914ce4c33325f047dfa867e005134ad3911ef048","modified":1463938478204},{"_id":"themes/raccoon/source/css/.sass-cache/3c1718288a63d6091205f90c971ab8bdbe4ad9ea/_default.scssc","hash":"aa4e3c5b955edd71c40513fdad87f21ecfc50a18","modified":1463938478226},{"_id":"themes/raccoon/source/css/.sass-cache/3c1718288a63d6091205f90c971ab8bdbe4ad9ea/_default-pair.scssc","hash":"1da8d575e1f170049ec59201c9b3549517335cb1","modified":1463938478217},{"_id":"themes/raccoon/source/css/.sass-cache/3c1718288a63d6091205f90c971ab8bdbe4ad9ea/_double-string.scssc","hash":"6a97220d8d46715bafc809a043929e0ea7504787","modified":1463938478222},{"_id":"themes/raccoon/source/css/.sass-cache/3f7dd7a236456275b685e5cd1c1ad2019b51b21d/_double.scssc","hash":"a9e4145b89a6b73752609372fba9cdef37715768","modified":1463938478211},{"_id":"themes/raccoon/source/css/.sass-cache/3c7cb2e39dd8d651a3d957a2b4028b1bdd21d46f/_normalize.scssc","hash":"a94f8311c1b031606e5165eb2377a18104f9b1cf","modified":1463938478048},{"_id":"themes/raccoon/source/css/.sass-cache/3f7dd7a236456275b685e5cd1c1ad2019b51b21d/_query.scssc","hash":"802a0a8f2af4c3bb4da5a5bb95da2b5c46f7fb06","modified":1463938478195},{"_id":"themes/raccoon/source/css/.sass-cache/3f7dd7a236456275b685e5cd1c1ad2019b51b21d/_resolution.scssc","hash":"522b9ab43678c160ba60c98dc3de3596fc42a0f4","modified":1463938478245},{"_id":"themes/raccoon/source/css/.sass-cache/3f7dd7a236456275b685e5cd1c1ad2019b51b21d/_single.scssc","hash":"83065a10f2f14c509ebcc6ea798bdc93a8464a32","modified":1463938478199},{"_id":"themes/raccoon/source/css/.sass-cache/3f7dd7a236456275b685e5cd1c1ad2019b51b21d/_triple.scssc","hash":"9b29fca4445728ec85897d8cb391a90053b3b210","modified":1463938478232},{"_id":"themes/raccoon/source/css/.sass-cache/513f07a67d7fdf58ccfd9ce7668038ad3904f56d/_breakpoint.scssc","hash":"9900a453d8d2176826506a0e46c93e6bb8cf2f61","modified":1463938478125},{"_id":"themes/raccoon/source/css/.sass-cache/71074cb3a9124b9a856293bb0815d0e67060f811/_context.scssc","hash":"b1bbffe7004fd1ea1d8a30252845c55fb070c02c","modified":1463938478144},{"_id":"themes/raccoon/source/css/.sass-cache/71074cb3a9124b9a856293bb0815d0e67060f811/_legacy-settings.scssc","hash":"21d4f80f116b0cf2f3f3529aaf79d9ce78e97b85","modified":1463938478283},{"_id":"themes/raccoon/source/css/.sass-cache/71074cb3a9124b9a856293bb0815d0e67060f811/_helpers.scssc","hash":"4bc9e983e3c389aff90aca4111317a6bef9694f7","modified":1463938478157},{"_id":"themes/raccoon/source/css/.sass-cache/71074cb3a9124b9a856293bb0815d0e67060f811/_no-query.scssc","hash":"3119a891478e09dba35ac321223a1c09bb27b587","modified":1463938478262},{"_id":"themes/raccoon/source/css/.sass-cache/71074cb3a9124b9a856293bb0815d0e67060f811/_parsers.scssc","hash":"08ebc0b72213f981d813198af7d4df35dfe4dc62","modified":1463938478179},{"_id":"themes/raccoon/source/css/.sass-cache/71074cb3a9124b9a856293bb0815d0e67060f811/_respond-to.scssc","hash":"627244f536ca7dd2f206081465c96e4de77fce35","modified":1463938478275},{"_id":"themes/raccoon/source/css/.sass-cache/71074cb3a9124b9a856293bb0815d0e67060f811/_settings.scssc","hash":"32635e95a994506047e5d8fb19a1538466c649e0","modified":1463938478134},{"_id":"themes/raccoon/source/css/.sass-cache/8df8631988cdf60009ca3ed7d9df887e66b48efe/_default.scssc","hash":"b6fc783bbc253f673941929dcab9d027d46ff8db","modified":1463938478238},{"_id":"themes/raccoon/source/css/.sass-cache/c9ea7099c499ff473c0a03c8261742bc222c8bbe/_resolution.scssc","hash":"468bb61fd453bb0a0ce3c39f3ba765e705d52033","modified":1463938478257},{"_id":"themes/raccoon/source/css/.sass-cache/3c7cb2e39dd8d651a3d957a2b4028b1bdd21d46f/_gridlex.scssc","hash":"e602434b29d0615180996982b28c2f6c051e4c18","modified":1463938478079},{"_id":"themes/raccoon/source/css/sidebar.scss","hash":"b8bac66b69c02174ab9524ceccc6ad916fe8ff53","modified":1464442010757},{"_id":"source/_posts/oop-example-validation.md","hash":"d552496f6abddbd7a731118320767dfb7aab2167","modified":1464010845797},{"_id":"source/_posts/fn-array-methods.md","hash":"0b1b1590b396d9ef98b74420e091e14afa7bf553","modified":1464012851767},{"_id":"source/_posts/oop-objects-vs-primitives.md","hash":"736dfe6fad453f51ef397b227de824771ac0c6d3","modified":1464011584533},{"_id":"themes/raccoon/source/images/new-raccoon-logo.svg","hash":"213fce72cf9e8ce3f0af7205f77fa7285f1a3c3e","modified":1464107894421},{"_id":"themes/raccoon/source/css/mixins/blocks.scss","hash":"69ecb38a0afa7fa45e3d38e883c5e3b4ad47508a","modified":1463981597400},{"_id":"public/archives/index.html","hash":"d59ad1e68fb2ef321184ffd9b566708d859adb9a","modified":1464443270390},{"_id":"public/archives/2016/index.html","hash":"e48fe8cbfc70315e36229d512839eb609124d095","modified":1464443270458},{"_id":"public/index.html","hash":"d9f80a0d61a43d15e58412519f32605b0c903473","modified":1464443270458},{"_id":"public/categories/Статья/index.html","hash":"66059e966246abec751ea9365017e2f91d45382c","modified":1464443270463},{"_id":"public/archives/2016/03/index.html","hash":"1faf1ba21ed57cbf43ab0404709aa108f2de1793","modified":1464443270463},{"_id":"public/archives/2016/04/index.html","hash":"d83950415ee77dd98f415fa3eb8426cbfb3ef623","modified":1464443270463},{"_id":"public/tags/ES6/index.html","hash":"65f2ba6ff0d7e6e309ac98702c9e2080b975abd8","modified":1464443270463},{"_id":"public/tags/JavaScript/index.html","hash":"445dc4f73e4befb1aa085895dd6fa9b752c3abe3","modified":1464443270463},{"_id":"public/tags/OOP/index.html","hash":"2abc13067bba4e03d65838f94919b2fc3f8e95f0","modified":1464443270463},{"_id":"public/tags/FN/index.html","hash":"3de71641300970b6fcff068018b74472c94f9d7d","modified":1464443270463},{"_id":"public/fn-array-methods/index.html","hash":"1909e413993877b849fd5fe5f691ad7babe07f22","modified":1464443270463},{"_id":"public/oop-objects-vs-primitives/index.html","hash":"3315eb351602bd71f8539f6372f5d4ac48d07e91","modified":1464443270463},{"_id":"public/es6-arrow-functions/index.html","hash":"76abb5af70b979f502fc782ae155de52f9a0d97f","modified":1464443270464},{"_id":"public/oop-example-validation/index.html","hash":"ace29559e014647126b9daf20d78155643b2e3c5","modified":1464443270464},{"_id":"public/images/new-raccoon-logo.svg","hash":"213fce72cf9e8ce3f0af7205f77fa7285f1a3c3e","modified":1464443270467},{"_id":"public/css/article.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1464443270492},{"_id":"public/css/buttons.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1464443270493},{"_id":"public/css/sidebar.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1464443270493},{"_id":"public/css/mixins/blocks.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1464443270493},{"_id":"public/css/mixins.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1464443270493},{"_id":"public/css/variables.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1464443270493},{"_id":"public/css/style.css","hash":"27e6a96c4ab1cb0ca0ea7b597ea1dd41a7ce20ed","modified":1464443270520}],"Category":[{"name":"article","_id":"cioih58fo00006kpn09qhltze"},{"name":"Статья","_id":"cioii992q00026kpnkdrladun"}],"Data":[{"_id":"authors","data":{"rtivital":{"name":"Виталий Ртищев"},"missingdays":{"name":"Евгений Бовыкин"}}}],"Page":[],"Post":[{"title":"ES6: стрелочные функции","author":"rtivital","date":"2016-03-14T00:00:00.000Z","_content":"\nНа первый взгляд может показаться, что стрелочные функции являются исключительно \"синтаксическим сахаром\" и [не несут в себе никакой](/) новой функциональности. Действительно, их использование выглядит очень удобным и значительно соркащает объемы необходимого кода, особенно если вы сторонник функционального JavaScript:\n<!-- more -->\n```javascript\n// раньше\nvar sum = function() {\n  return [].reduce.call(arguments, function(m, n) {\n    return m + n;\n  }, 0);\n}\n\n// сейчас\nvar sum = (...args) => args.reduce((m, n) => m + n, 0);\n```\n\nЧтобы разобраться с новой синтаксической конструкцией, рассмотрим простую функцию `add`, которая возвращает сумму двух переданных ей аргументов:\n\n```javascript\n// раньше\nvar add = function(a, b) {\n  return a + b;\n};\n\n// сейчас\nvar add = (a, b) => a + b;\n```\n\nСоздание стрелочной функции состоит из имени `add`, передаваемых ей параметров `(a, b)` и тела функции `a + b`.\n\n## Объявление\nВсе стрелочные функции создаются с помощью *function expression*, то есть они всегда будут эквиваленты следующему ES5 коду:\n```javascript\n// function expression: два способа в ES6\nvar f = function() { return 42; }\nvar f = () => 42;\n\n// function declaration: один способ в ES6\nfunction f() {\n  return 42;\n}\n```\n\nПоэтому следует помнить, что перед использованием стрелочной функции её всегда необходимо создать заранее.\n\n## Параметры\nОбычно параметры помещаются в круглые скобки `(a, b)`. Если необходимо передать функции всего один параметр, то круглые скобки можно не использовать `var f = x => x * 2`, но лучше подобную возможность не использовать и всегда окружать параметр скобками `var f = (x) => x * 2`, чтобы избежать недопонимания. В случае, если в параметрах нет необходимости, объявление функции будет выглядеть следующим образом:\n```javascript\nvar f = () => 42;\n\nf(); // 42\n```\n\n## Тело функции\nВ случае, когда необходимо выполнить всего одну инструкцию (как во всех примерах, рассмотренных выше) достаточно просто указать эту инструкцию, как тело функции:\n```javascript\nvar add = (a, b) => a + b; // возвращает a + b\n```\n\nВ ситуациях, когда одной инструкции оказывается недостаточно, тело функции необходимо заключить в фигурные скобки `{ ... }` и пользовать ключевым словом `return`:\n```javascript\nvar g = (a, b) => {\n  let m = Math.pow(2, parseInt(a));\n  return b + m;\n}\n```\n\nВсе возможности обычных функций могут быть использованы и со стрелочными, включая [параметры по умолчанию](http://jsraccoon.ru/es6-defaults/), [остаточные параметры](http://jsraccoon.ru/es6-spread-rest/), [реструктурирующее присваивание](http://jsraccoon.ru/es6-destructuring/) и так далее.\n\n## Анонимные функции\nЧаще всего анонимные стрелочные функции используются при итерациях по элементам массивов с методами `map`, `forEach`, `reduce`, `filter` и другими:\n```javascript\nconst double = (arr) => arr.map( item => item * 2 );\ndouble([1,2,3,4]); // [2, 4, 6, 8]\n\nconst filter = (arr) => arr.filter( item => !!item );\nfilter([false, undefined, 0, 1, 'str']); // [1, \"str\"]\n\nconst sum = (...args) => args.reduce((m, n) => m + n, 0);\nsum(10, 15, 20); // 45\n```\n\n## this больше не проблема\nГлавная причина появления стрелочных функций в ES6 — недопонимание, которое возникает у большинства разработчиков при работе с ключевым словом `this`. Чтобы понять, что же такого чудесного принесли с собой стрелочные функции рассмотрим простой пример:\n```javascript\n// ES5\nvar obj = {\n  btn: document.links[0],\n  log: function (message) {\n    console.log(message);\n    return this;\n  },\n  init: function() {\n    var self = this;\n    self.btn.addEventListener('click', function() {\n      self.log('Button Clicked!');\n    }, false);\n  }\n};\n```\n\nЧтобы выполнить какой-либо метод из объекта до появления стрелочных функций необходимо было воспользоваться одним из методов замены ключевого слова `this`: как в этом примере записать его в переменную `self`, или воспользоваться методом функций `bind`. Данные способы, несмоненно, работали, но выглядели достаточно скверно и могли смутить других разработчиков, которые попытались бы разобраться в коде. Стрелочные функции полностью решают данную проблему. Теперб код, приведённый выше, будет выглядеть следующим образом:\n```javascript\n// ES6\nvar obj = {\n  btn: document.links[0],\n  log: function(message) {\n    console.log(message);\n    return this;\n  },\n  init: function() {\n    this.btn.addEventListener('click', () => this.log('Button Clicked!'), false);\n  }\n};\n```\n\nНаиболее подробное описание принципов работы стрелочных функций с ключевым словом `this` можно найти в [этой статье](http://blog.getify.com/arrow-this/).\n","source":"_posts/es6-arrow-functions.md","raw":"---\ntitle: \"ES6: стрелочные функции\"\nauthor: rtivital\ndate: \"2016-03-14\"\ncategories: Статья\ntags: [ES6, JavaScript]\n---\n\nНа первый взгляд может показаться, что стрелочные функции являются исключительно \"синтаксическим сахаром\" и [не несут в себе никакой](/) новой функциональности. Действительно, их использование выглядит очень удобным и значительно соркащает объемы необходимого кода, особенно если вы сторонник функционального JavaScript:\n<!-- more -->\n```javascript\n// раньше\nvar sum = function() {\n  return [].reduce.call(arguments, function(m, n) {\n    return m + n;\n  }, 0);\n}\n\n// сейчас\nvar sum = (...args) => args.reduce((m, n) => m + n, 0);\n```\n\nЧтобы разобраться с новой синтаксической конструкцией, рассмотрим простую функцию `add`, которая возвращает сумму двух переданных ей аргументов:\n\n```javascript\n// раньше\nvar add = function(a, b) {\n  return a + b;\n};\n\n// сейчас\nvar add = (a, b) => a + b;\n```\n\nСоздание стрелочной функции состоит из имени `add`, передаваемых ей параметров `(a, b)` и тела функции `a + b`.\n\n## Объявление\nВсе стрелочные функции создаются с помощью *function expression*, то есть они всегда будут эквиваленты следующему ES5 коду:\n```javascript\n// function expression: два способа в ES6\nvar f = function() { return 42; }\nvar f = () => 42;\n\n// function declaration: один способ в ES6\nfunction f() {\n  return 42;\n}\n```\n\nПоэтому следует помнить, что перед использованием стрелочной функции её всегда необходимо создать заранее.\n\n## Параметры\nОбычно параметры помещаются в круглые скобки `(a, b)`. Если необходимо передать функции всего один параметр, то круглые скобки можно не использовать `var f = x => x * 2`, но лучше подобную возможность не использовать и всегда окружать параметр скобками `var f = (x) => x * 2`, чтобы избежать недопонимания. В случае, если в параметрах нет необходимости, объявление функции будет выглядеть следующим образом:\n```javascript\nvar f = () => 42;\n\nf(); // 42\n```\n\n## Тело функции\nВ случае, когда необходимо выполнить всего одну инструкцию (как во всех примерах, рассмотренных выше) достаточно просто указать эту инструкцию, как тело функции:\n```javascript\nvar add = (a, b) => a + b; // возвращает a + b\n```\n\nВ ситуациях, когда одной инструкции оказывается недостаточно, тело функции необходимо заключить в фигурные скобки `{ ... }` и пользовать ключевым словом `return`:\n```javascript\nvar g = (a, b) => {\n  let m = Math.pow(2, parseInt(a));\n  return b + m;\n}\n```\n\nВсе возможности обычных функций могут быть использованы и со стрелочными, включая [параметры по умолчанию](http://jsraccoon.ru/es6-defaults/), [остаточные параметры](http://jsraccoon.ru/es6-spread-rest/), [реструктурирующее присваивание](http://jsraccoon.ru/es6-destructuring/) и так далее.\n\n## Анонимные функции\nЧаще всего анонимные стрелочные функции используются при итерациях по элементам массивов с методами `map`, `forEach`, `reduce`, `filter` и другими:\n```javascript\nconst double = (arr) => arr.map( item => item * 2 );\ndouble([1,2,3,4]); // [2, 4, 6, 8]\n\nconst filter = (arr) => arr.filter( item => !!item );\nfilter([false, undefined, 0, 1, 'str']); // [1, \"str\"]\n\nconst sum = (...args) => args.reduce((m, n) => m + n, 0);\nsum(10, 15, 20); // 45\n```\n\n## this больше не проблема\nГлавная причина появления стрелочных функций в ES6 — недопонимание, которое возникает у большинства разработчиков при работе с ключевым словом `this`. Чтобы понять, что же такого чудесного принесли с собой стрелочные функции рассмотрим простой пример:\n```javascript\n// ES5\nvar obj = {\n  btn: document.links[0],\n  log: function (message) {\n    console.log(message);\n    return this;\n  },\n  init: function() {\n    var self = this;\n    self.btn.addEventListener('click', function() {\n      self.log('Button Clicked!');\n    }, false);\n  }\n};\n```\n\nЧтобы выполнить какой-либо метод из объекта до появления стрелочных функций необходимо было воспользоваться одним из методов замены ключевого слова `this`: как в этом примере записать его в переменную `self`, или воспользоваться методом функций `bind`. Данные способы, несмоненно, работали, но выглядели достаточно скверно и могли смутить других разработчиков, которые попытались бы разобраться в коде. Стрелочные функции полностью решают данную проблему. Теперб код, приведённый выше, будет выглядеть следующим образом:\n```javascript\n// ES6\nvar obj = {\n  btn: document.links[0],\n  log: function(message) {\n    console.log(message);\n    return this;\n  },\n  init: function() {\n    this.btn.addEventListener('click', () => this.log('Button Clicked!'), false);\n  }\n};\n```\n\nНаиболее подробное описание принципов работы стрелочных функций с ключевым словом `this` можно найти в [этой статье](http://blog.getify.com/arrow-this/).\n","slug":"es6-arrow-functions","published":1,"updated":"2016-05-22T13:50:11.211Z","_id":"ciohe4moc0000sspn0pjc7rwg","comments":1,"layout":"post","photos":[],"link":"","content":"<p>На первый взгляд может показаться, что стрелочные функции являются исключительно “синтаксическим сахаром” и <a href=\"/\">не несут в себе никакой</a> новой функциональности. Действительно, их использование выглядит очень удобным и значительно соркащает объемы необходимого кода, особенно если вы сторонник функционального JavaScript:<br><a id=\"more\"></a><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// раньше</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [].reduce.call(<span class=\"built_in\">arguments</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m, n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m + n;</span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// сейчас</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = (...args) =&gt; args.reduce((m, n) =&gt; m + n, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure></p>\n<p>Чтобы разобраться с новой синтаксической конструкцией, рассмотрим простую функцию <code>add</code>, которая возвращает сумму двух переданных ей аргументов:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// раньше</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// сейчас</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> add = (a, b) =&gt; a + b;</span><br></pre></td></tr></table></figure>\n<p>Создание стрелочной функции состоит из имени <code>add</code>, передаваемых ей параметров <code>(a, b)</code> и тела функции <code>a + b</code>.</p>\n<h2 id=\"Объявление\"><a href=\"#Объявление\" class=\"headerlink\" title=\"Объявление\"></a>Объявление</h2><p>Все стрелочные функции создаются с помощью <em>function expression</em>, то есть они всегда будут эквиваленты следующему ES5 коду:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// function expression: два способа в ES6</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">42</span>; &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = () =&gt; <span class=\"number\">42</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// function declaration: один способ в ES6</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">42</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Поэтому следует помнить, что перед использованием стрелочной функции её всегда необходимо создать заранее.</p>\n<h2 id=\"Параметры\"><a href=\"#Параметры\" class=\"headerlink\" title=\"Параметры\"></a>Параметры</h2><p>Обычно параметры помещаются в круглые скобки <code>(a, b)</code>. Если необходимо передать функции всего один параметр, то круглые скобки можно не использовать <code>var f = x =&gt; x * 2</code>, но лучше подобную возможность не использовать и всегда окружать параметр скобками <code>var f = (x) =&gt; x * 2</code>, чтобы избежать недопонимания. В случае, если в параметрах нет необходимости, объявление функции будет выглядеть следующим образом:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = () =&gt; <span class=\"number\">42</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">f(); <span class=\"comment\">// 42</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Тело-функции\"><a href=\"#Тело-функции\" class=\"headerlink\" title=\"Тело функции\"></a>Тело функции</h2><p>В случае, когда необходимо выполнить всего одну инструкцию (как во всех примерах, рассмотренных выше) достаточно просто указать эту инструкцию, как тело функции:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add = (a, b) =&gt; a + b; <span class=\"comment\">// возвращает a + b</span></span><br></pre></td></tr></table></figure></p>\n<p>В ситуациях, когда одной инструкции оказывается недостаточно, тело функции необходимо заключить в фигурные скобки <code>{ ... }</code> и пользовать ключевым словом <code>return</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> g = (a, b) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> m = <span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"built_in\">parseInt</span>(a));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> b + m;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Все возможности обычных функций могут быть использованы и со стрелочными, включая <a href=\"http://jsraccoon.ru/es6-defaults/\" target=\"_blank\" rel=\"external\">параметры по умолчанию</a>, <a href=\"http://jsraccoon.ru/es6-spread-rest/\" target=\"_blank\" rel=\"external\">остаточные параметры</a>, <a href=\"http://jsraccoon.ru/es6-destructuring/\" target=\"_blank\" rel=\"external\">реструктурирующее присваивание</a> и так далее.</p>\n<h2 id=\"Анонимные-функции\"><a href=\"#Анонимные-функции\" class=\"headerlink\" title=\"Анонимные функции\"></a>Анонимные функции</h2><p>Чаще всего анонимные стрелочные функции используются при итерациях по элементам массивов с методами <code>map</code>, <code>forEach</code>, <code>reduce</code>, <code>filter</code> и другими:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> double = (arr) =&gt; arr.map( item =&gt; item * <span class=\"number\">2</span> );</span><br><span class=\"line\">double([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]); <span class=\"comment\">// [2, 4, 6, 8]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> filter = (arr) =&gt; arr.filter( item =&gt; !!item );</span><br><span class=\"line\">filter([<span class=\"literal\">false</span>, <span class=\"literal\">undefined</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"string\">'str'</span>]); <span class=\"comment\">// [1, \"str\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sum = (...args) =&gt; args.reduce((m, n) =&gt; m + n, <span class=\"number\">0</span>);</span><br><span class=\"line\">sum(<span class=\"number\">10</span>, <span class=\"number\">15</span>, <span class=\"number\">20</span>); <span class=\"comment\">// 45</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"this-больше-не-проблема\"><a href=\"#this-больше-не-проблема\" class=\"headerlink\" title=\"this больше не проблема\"></a>this больше не проблема</h2><p>Главная причина появления стрелочных функций в ES6 — недопонимание, которое возникает у большинства разработчиков при работе с ключевым словом <code>this</code>. Чтобы понять, что же такого чудесного принесли с собой стрелочные функции рассмотрим простой пример:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  btn: <span class=\"built_in\">document</span>.links[<span class=\"number\">0</span>],</span><br><span class=\"line\">  log: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(message);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    self.btn.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      self.log(<span class=\"string\">'Button Clicked!'</span>);</span><br><span class=\"line\">    &#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Чтобы выполнить какой-либо метод из объекта до появления стрелочных функций необходимо было воспользоваться одним из методов замены ключевого слова <code>this</code>: как в этом примере записать его в переменную <code>self</code>, или воспользоваться методом функций <code>bind</code>. Данные способы, несмоненно, работали, но выглядели достаточно скверно и могли смутить других разработчиков, которые попытались бы разобраться в коде. Стрелочные функции полностью решают данную проблему. Теперб код, приведённый выше, будет выглядеть следующим образом:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  btn: <span class=\"built_in\">document</span>.links[<span class=\"number\">0</span>],</span><br><span class=\"line\">  log: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(message);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.btn.addEventListener(<span class=\"string\">'click'</span>, () =&gt; <span class=\"keyword\">this</span>.log(<span class=\"string\">'Button Clicked!'</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Наиболее подробное описание принципов работы стрелочных функций с ключевым словом <code>this</code> можно найти в <a href=\"http://blog.getify.com/arrow-this/\" target=\"_blank\" rel=\"external\">этой статье</a>.</p>\n","excerpt":"<p>На первый взгляд может показаться, что стрелочные функции являются исключительно “синтаксическим сахаром” и <a href=\"/\">не несут в себе никакой</a> новой функциональности. Действительно, их использование выглядит очень удобным и значительно соркащает объемы необходимого кода, особенно если вы сторонник функционального JavaScript:<br>","more":"<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// раньше</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [].reduce.call(<span class=\"built_in\">arguments</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m, n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m + n;</span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// сейчас</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = (...args) =&gt; args.reduce((m, n) =&gt; m + n, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure></p>\n<p>Чтобы разобраться с новой синтаксической конструкцией, рассмотрим простую функцию <code>add</code>, которая возвращает сумму двух переданных ей аргументов:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// раньше</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// сейчас</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> add = (a, b) =&gt; a + b;</span><br></pre></td></tr></table></figure>\n<p>Создание стрелочной функции состоит из имени <code>add</code>, передаваемых ей параметров <code>(a, b)</code> и тела функции <code>a + b</code>.</p>\n<h2 id=\"Объявление\"><a href=\"#Объявление\" class=\"headerlink\" title=\"Объявление\"></a>Объявление</h2><p>Все стрелочные функции создаются с помощью <em>function expression</em>, то есть они всегда будут эквиваленты следующему ES5 коду:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// function expression: два способа в ES6</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">42</span>; &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = () =&gt; <span class=\"number\">42</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// function declaration: один способ в ES6</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">42</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Поэтому следует помнить, что перед использованием стрелочной функции её всегда необходимо создать заранее.</p>\n<h2 id=\"Параметры\"><a href=\"#Параметры\" class=\"headerlink\" title=\"Параметры\"></a>Параметры</h2><p>Обычно параметры помещаются в круглые скобки <code>(a, b)</code>. Если необходимо передать функции всего один параметр, то круглые скобки можно не использовать <code>var f = x =&gt; x * 2</code>, но лучше подобную возможность не использовать и всегда окружать параметр скобками <code>var f = (x) =&gt; x * 2</code>, чтобы избежать недопонимания. В случае, если в параметрах нет необходимости, объявление функции будет выглядеть следующим образом:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = () =&gt; <span class=\"number\">42</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">f(); <span class=\"comment\">// 42</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Тело-функции\"><a href=\"#Тело-функции\" class=\"headerlink\" title=\"Тело функции\"></a>Тело функции</h2><p>В случае, когда необходимо выполнить всего одну инструкцию (как во всех примерах, рассмотренных выше) достаточно просто указать эту инструкцию, как тело функции:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add = (a, b) =&gt; a + b; <span class=\"comment\">// возвращает a + b</span></span><br></pre></td></tr></table></figure></p>\n<p>В ситуациях, когда одной инструкции оказывается недостаточно, тело функции необходимо заключить в фигурные скобки <code>{ ... }</code> и пользовать ключевым словом <code>return</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> g = (a, b) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> m = <span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"built_in\">parseInt</span>(a));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> b + m;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Все возможности обычных функций могут быть использованы и со стрелочными, включая <a href=\"http://jsraccoon.ru/es6-defaults/\">параметры по умолчанию</a>, <a href=\"http://jsraccoon.ru/es6-spread-rest/\">остаточные параметры</a>, <a href=\"http://jsraccoon.ru/es6-destructuring/\">реструктурирующее присваивание</a> и так далее.</p>\n<h2 id=\"Анонимные-функции\"><a href=\"#Анонимные-функции\" class=\"headerlink\" title=\"Анонимные функции\"></a>Анонимные функции</h2><p>Чаще всего анонимные стрелочные функции используются при итерациях по элементам массивов с методами <code>map</code>, <code>forEach</code>, <code>reduce</code>, <code>filter</code> и другими:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> double = (arr) =&gt; arr.map( item =&gt; item * <span class=\"number\">2</span> );</span><br><span class=\"line\">double([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]); <span class=\"comment\">// [2, 4, 6, 8]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> filter = (arr) =&gt; arr.filter( item =&gt; !!item );</span><br><span class=\"line\">filter([<span class=\"literal\">false</span>, <span class=\"literal\">undefined</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"string\">'str'</span>]); <span class=\"comment\">// [1, \"str\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sum = (...args) =&gt; args.reduce((m, n) =&gt; m + n, <span class=\"number\">0</span>);</span><br><span class=\"line\">sum(<span class=\"number\">10</span>, <span class=\"number\">15</span>, <span class=\"number\">20</span>); <span class=\"comment\">// 45</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"this-больше-не-проблема\"><a href=\"#this-больше-не-проблема\" class=\"headerlink\" title=\"this больше не проблема\"></a>this больше не проблема</h2><p>Главная причина появления стрелочных функций в ES6 — недопонимание, которое возникает у большинства разработчиков при работе с ключевым словом <code>this</code>. Чтобы понять, что же такого чудесного принесли с собой стрелочные функции рассмотрим простой пример:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  btn: <span class=\"built_in\">document</span>.links[<span class=\"number\">0</span>],</span><br><span class=\"line\">  log: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(message);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    self.btn.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      self.log(<span class=\"string\">'Button Clicked!'</span>);</span><br><span class=\"line\">    &#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Чтобы выполнить какой-либо метод из объекта до появления стрелочных функций необходимо было воспользоваться одним из методов замены ключевого слова <code>this</code>: как в этом примере записать его в переменную <code>self</code>, или воспользоваться методом функций <code>bind</code>. Данные способы, несмоненно, работали, но выглядели достаточно скверно и могли смутить других разработчиков, которые попытались бы разобраться в коде. Стрелочные функции полностью решают данную проблему. Теперб код, приведённый выше, будет выглядеть следующим образом:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  btn: <span class=\"built_in\">document</span>.links[<span class=\"number\">0</span>],</span><br><span class=\"line\">  log: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(message);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.btn.addEventListener(<span class=\"string\">'click'</span>, () =&gt; <span class=\"keyword\">this</span>.log(<span class=\"string\">'Button Clicked!'</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Наиболее подробное описание принципов работы стрелочных функций с ключевым словом <code>this</code> можно найти в <a href=\"http://blog.getify.com/arrow-this/\">этой статье</a>.</p>"},{"title":"Объектно-ориентированный JavaScript: немного практики","author":"rtivital","date":"2016-04-23T00:00:00.000Z","_content":"В прошлых статьях мы рассмотрели [основы работы с объектами](http://jsraccoon.ru/oop-object-base), [функции конструкторы](http://jsraccoon.ru/oop-constructors) и [прототипы](http://jsraccoon.ru/oop-prototypes). А, значит, настало время окончательно во всём разобраться и написать боевой пример — небольшую библиотеку для валидации данных. Полный код библиотеки, которую будем создавать в этой статье, можно найти в [этом репозитории](https://github.com/rtivital/validate). Если же вы хотите в ходе чтения статьи следовать всем инструкциям, то вы можете скачать [стартовый шаблон](https://gist.github.com/rtivital/229191009ff742df62bd).\n<!--MORE-->\n##### Идея\nБиблиотека предназначена для валидации данных из одного поля ввода (тега `<input>` или `<textarea>`) и предоставляет несколько простых методов проверки данных. Например, можно проверить правильность введённого email адреса или указать максимальное и минимальное количество символов. Сама по себе, библиотека не даёт огромного функционала, но очень проста в расширении, предлагая пользователю самому дописать необходимые ему методы для валидации данных. В комплекте с библиотекой идёт простой строковый шаблонизатор, который поможет выводить понятные сообщения об ошибках.\n\n##### Параметры\nНеобходимо всегда точно осознавать, что будет делать созданная вами функция-конструктор перед тем, как вы начнёте писать код. Поэтому, для начала, попробуем описать, что будет делать валидатор данных. Мы уже знаем, что нам обязательно нужно передавать DOM элемент (`<input>` или `<textarea>`), но помимо этого нам также необходимо узнать правила валидации, шаблоны сообщений об ошибках и `callback` функции, которые будут срабатывать при успешном или, наоборот, неуспешном завершении валидации. Очевидно, что параметров достаточно много и передавать их в функцию по одному будет крайне неудобно. Как раз для таких целей и существуют объекты. Используя объект, мы можем удобно сгруппировать все передаваемые в функцию данные. Таким образом, все параметры, которые нужно предоставить функции-конструктору: DOM элемент и объект настроек.\n```javascript\nvar email = document.getElementbyId('email');\nvar emailValidation = new Validator(email, { /* объект настроек */ });\n```\n\n##### Объект настроек\nИтак, у нас уже есть поле ввода, данные из которого будут проверяться, но этого же недостаточно. По крайней мере, нужно указать правила, в соответствие с которыми будет проводиться валидация. Для этого создадим свойство `rules` в объекте настроек, которое будет содержать все правила:\n```javascript\nvar settings = {\n  rules: {\n    min: 8,\n    max: 50,\n    match: 'email'\n  }\n};\n```\n\nДанная конфигурация скажет функции-конструктору, что поле ввода должно содержать валидный адрес электронной почты, длина которого не меньше 8 и не больше 50 символов.\n\nК каждому правилу должно прилагаться сообщение об ошибке, которое будет использовано, когда валидация данных будет провалена. Поэтому создадим ещё одно свойство объекта `settings`, которое будет содержать все сообщения об ошибках.\n```javascript\nvar settings = {\n  rules: { /* ... */ },\n  messages: {\n    min: 'Поле должно содержать больше 8 символов',\n    max: 'Поле не должно содержать больше 50 символов',\n    match: 'Поле должно содержать валидный адрес электронной почты'\n  }\n};\n```\n\nТеперь остался последний, но самый важный шаг для завершения конфигурации — `callback` функции. Для наглядности назовём их `onError` и `onSuccess`. Данные функции, передаваемые с объектом настроек, будут срабатывать при завершении валидации в зависимости от её результата. Они могут содержать всё что угодно, но пока для простоты будем просто выводить в консоль сообщения.\n```javascript\nvar settings = {\n  rules: { /* ... */ },\n  messages: { /* ... */ },\n  onError: function() { console.log('Валидация провалена'); },\n  onSuccess: function() { console.log('Валидация прошла успешно'); }\n};\n```\n\nИтак, основа нашего объекта настроек готова, и мы уже определились со всеми параметрами, передаваемыми в функцию, а, значит, половина работы мы уже сделали.\n```javascript\nvar settings = {\n  rules: {\n    min: 8,\n    max: 50,\n    match: 'email'\n  },\n  messages: {\n    min: 'Поле должно содержать больше 8 символов',\n    max: 'Поле не должно содержать больше 50 символов',\n    match: 'Поле должно содержать валидный адрес электронной почты'\n  },\n  onError: function() { console.log('Валидация провалена'); },\n  onSuccess: function() { console.log('Валидация прошла успешно'); }\n};\n\nvar email = document.getElementbyId('email');\nvar emailValidation = new Validator(email, settings);\n```\n\n##### Паттерн \"Модуль\"\nПри создании библиотеки мы не хотим, чтобы все наши \"внутренние\" переменные попали в чужие руки (кто знает, что задумали другие разработчики-злодеи). Может возникнуть конфликт имён и любую переменную из нашей библиотеки сможет перезаписать сторонний код. Чтобы этого не произошло, необходимо ограничить доступ. Удобнее всего это сделать с помощью [паттерна \"Модуль\"](http://forwebdev.ru/javascript/module-pattern/). Всё, что для этого нужно, — обвернуть весь наш код в немедленно вызываемую анонимную функцию и записать результат её выполнения в переменную, которая и будет использоваться другими разработчиками.\n```javascript\nvar Validator = (function() {})();\n```\n\nТаким образом, мы создали новую область видимости. Всё, что находится внутри неё, не будет доступно для записи и чтения, если мы сами не запишем данные, как свойство объекта `window`, или не вернём значение — в этом случае то, что возвращает функция будет записано в переменную `Validator`. Создадим функцию-конструктор и экспортируем её из модуля:\n```javascript\nvar Validator = (function() {\n  'use strict';\n\n  var Validate = function(element, options) {\n    this.element = element;\n    this.options = options;\n  };\n\n  return Validate;\n})();\n```\n\nТеперь у нас есть возможность использовать функцию `Validate` вне модуля, так как она была записана в переменную `Validator`.\n```javascript\nvar emailValidation = new Validator('element', 'options');\nconsole.log(emailValidation); // { element: \"element\", options: \"options\" }\n```\n\nКак я уже писал выше, мы также можем записать любые данные, как свойство объекта `window`. При подобной подходе у нас уже не возникает необходимости возвращать что-либо из модуля. Поэтому и результат выполнения записывать в переменную нет необходимости.\n```javascript\n(function() {\n  'use strict';\n\n  var Validate = function(element, options) {\n    this.element = element;\n    this.options = options;\n  };\n\n  window.Validator = Validate;\n})();\n```\n\n##### Запись свойств\nМы уже приступили к созданию функции-конструктора `Validate` и записали два свойства: `element` и `options`. Этого вполне достаточно, но было бы удобно обращаться к некоторым свойствам напрямую, например, писать каждый раз не `this.options.rules`, а просто `this.rules`. Поэтому создадим ещё несколько свойств для удобства:\n\n* `value` для обращения к введенным в поле ввода данным\n* `length` — количество символов в полученном `value`\n* `rules` — объект, содержащий все правила\n* и `messages` — объект со всеми сообщениями\n\n```javascript\nvar Validate = function(element, options) {\n  this.element = element;\n  this.options = options;\n\n  this.value = this.element.value.trim();\n  this.length = this.value.length;\n  this.rules = this.options.rules;\n  this.mesages = this.options.messages;\n};\n```\n\n##### Методы\nВ начале статьи я писал, что библиотека достаточно минималистична и не располагает огромным количеством методов. Поэтому ограничимся самым минимальным набором:\n\n* `required` — проверка наличия хотя бы одного непробельного символа\n* `min` — минимальное количество символов\n* `max` — максимальное количество символов\n* `match` — проверка соответствия какому-либо паттерну\n\n##### required\nВсё, что необходимо сделать в методе — сравнить длину значения `this.length` с нулём. Таким, образом мы убедимся, что был введён хотя бы один непробельный символ:\n```javascript\nValidate.prototype.required = function() {\n  return this.length > 0;\n};\n```\n\n##### min и max\nМетоды `min` и `max` практически повторяют метод `required`, но также принимают параметр, с которым будут сравнивать длину полученного значения `this.length`:\n```javascript\nValidate.prototype.min = function(param) {\n  return this.length >= param;\n};\n\nValidate.prototype.max = function(param) {\n  return this.length <= param;\n};\n```\n\n##### match\nМетод `match` работает с регулярными выражениями. Для простоты создадим объект, который будет содержать все наши регулярные выражения. Положим его в переменную `regExps` и объявим её вне метода.\n```javascript\nvar regExps = {\n  email: /^([\\w-]+(?:\\.[\\w-]+)*)@((?:[\\w-]+\\.)*\\w[\\w-]{0,66})\\.([a-z]{2,6}(?:\\.[a-z]{2})?)$/i,\n  url: /^((https?):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)|)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&%@!\\-\\/]))?$/,\n  numbers: /^\\d+(\\.\\d{1,2})?$/,\n  digits: /[0-9]*$/,\n  letters: /[a-z][A-Z]*$/\n};\n\nValidate.prototype.match = function(param) {};\n```\n\nТеперь мы сможем получить к ним доступ внутри метода `match`. В будущем нам ещё понадобится этот объект, так что поместить его вне метода `match` — хорошая идея.\nЧтобы проверить соответствие значения `this.value` регулярному выражению нужно воспользоваться методом `test`:\n```javascript\nValidate.prototype.match = function(param) {\n  // выбираем регулярное выражение\n  var re = regExps[param];\n  // Тестируем\n  return re.test(this.value);\n};\n\n// Кратко\nValidate.prototype.match = function(param) {\n  return regExps[param].test(this.value);\n};\n```\n\n##### Всё вместе\nИтак, мы написали 4 метода для валидации данных:\n```javascript\nValidate.prototype.required = function() {\n  return this.length > 0;\n};\n\nValidate.prototype.min = function(param) {\n  return this.length >= param;\n};\n\nValidate.prototype.max = function(param) {\n  return this.length <= param;\n};\n\nValidate.prototype.match = function(param) {\n  return regExps[param].test(this.value);\n};\n```\n\nДля их создания нам каждый раз приходилось обращаться к прототипу функции-конструктора `Validate`. Запись `Validate.prototype` достаточно громоздкая. Чтобы каждый раз не использовать её можно создать переменную, которая будет ссылаться на прототип. Так как любой прототип является не более чем простым объектом, мы можем смело задавать подобные переменные:\n```javascript\nvar fn = Validate.prototype;\nfn.required = function() { return this.length > 0; };\nfn.min = function(param) { return this.length >= param; };\nfn.max = function(param) { return this.length <= param; };\nfn.match = function(param) { return regExps[param].test(this.value); };\n```\n\n##### Валидация\nСами по себе написанные нами ранее методы бесполезны. Они ничего не умеют, кроме проверки данных. То есть для создания сообщений, группировки этих методов и вызова `callback` функций они не подходят. Поэтому создадим ещё один метод `validate`, который будет отвечать за обработку всего выше перечисленного.\n```javascript\nfn.validate = function() {};\n```\n\nПервое, что нужно сделать — перезаписать значение для `this.value` и `this.length`. При каждом запуске метода `validate` мы хотим получать новые данные из поля ввода и только потом проверять их.\n```javascript\nfn.validate = function() {\n  this.value = this.element.value.trim();\n  this.length = this.value.length;\n};\n```\n\nТеперь у нас есть самые \"свежие\" данные и мы можем их использовать для проверки соответствия правилам, которые записаны в объекте `this.rules`. Свойства объекта `this.rules` соответствуют написанным нами ранее методам. Удобнее всего правила перебрать с помощью цикла `for .. in`:\n```javascript\n// Пример объекта правил\n// {\n//   min: 8,\n//   max: 50,\n//   match: 'email'\n// }\n\nfn.validate = function() {\n  this.value = this.element.value.trim();\n  this.length = this.value.length;\n\n  for (var rule in this.rules) {\n    var param = this.rules[rule];\n  }\n};\n```\n\nИтак, мы написали цикл, с помощью которого мы переберём все передаваемые в функцию правила. При каждой итерации внутри цикла у нас будет доступ к имени текущего правила, например, `min`, а также к параметру правила, например `8` для правила `min`. Всё, что нам остаётся сделать, — последовательно применить созданные нам ранее методы.\n```javascript\nfn.validate = function() {\n  // ...\n  for (var rule in this.rules) {\n    var param = this.rules[rule];\n    var result = this[rule](param);\n  }\n};\n```\n\nПеременная `result` всегда содержит значение типа `boolean`, с помощью которого мы можем сказать соответствует ли наше `this.value` требованиям, описанным в правилах. Если мы узнали, что значение не соответствует какому-либо правилу, то мы сразу же прерываем выполнение цикла и вызываем `callback` функцию `onError`. Если же значение прошло проверки на все заданные правила, то нужно вызвать функцию `onSuccess`. Перед циклом объявим переменную `isValid`, которая будет сигнализировать о состоянии валидации.\n```javascript\nfn.validate = function() {\n  // ...\n  // Изначально считаем, что все правила пройдены\n  var isValid = true;\n  for (var rule in this.rules) {\n    var param = this.rules[rule];\n    var result = this[rule](param);\n    if (!result) {\n      // Если вылидация провалилась, то выставляем значение false\n      isValid = false;\n      // Вызываем функцию onError\n      this.options.onError.call(this);\n      // И прерываем выполнение цикла\n      break;\n    }\n  }\n\n  // После завершения цикла проверяем isValid\n  if (isValid) {\n    // Если всё хорошо, то вызываем функцию onSuccess\n    this.options.onSuccess.call(this);\n  }\n};\n```\n\n##### Пишем сообщения\nНаписанный нами метод `validate` уже сейчас достаточно хорошо. Он умеет проверять соответствие данных всем переданным правилам и вызывать функции в зависимости от результата проверки. Но мы также хотим передавать содержательные сообщения о полученных ошибках. В этом нам поможет простая функция для строковой шаблонизации. Допустим, что на выходе мы хотим получить сообщение, которое будет содержать введённые пользователем данные, а также параметр из наших правил. Чтобы получить подобную конструкцию мы можем составить строку:\n```javascript\nvar rules = {\n  min: 8\n};\nvar messages = {\n  min: 'Значение должно быть не менее %rule% символов. Значение \"%data%\" не подходит.'\n};\n```\n\nВ полученной строке необходимо заменить `%rule%` на параметр (в данном случае 8), а `%data%` на значение, полученное от пользователя. Таким образом, со всеми заменами строка будет выглядеть следующим образом: `'Значение должно быть не менее 8 символов. Значение \"банан\" не подходит.'`\n\nРеализовать подобную шаблонизацию достаточно просто с помощью метода строк `replace`. Чтобы не забивать наш метод `validate` большим количеством кода, создадим для этого отдельную функцию `createMessage`:\n```javascript\nvar createMessage = function(str, rule, data) {\n  return str.replace('%rule%', rule).replace('%data%', data);\n};\n\n// Сразу же опробуем функцию\ncreateMessage('Данные: %data%, Правило: %rule%','желтый', 'банан');\n// Данные: банан, Правило: желтый\n```\n\nФункция работает. Но работает только для наших конкретных переменных. Если в будущем мы захотим передавать и другие значения, то у нас ничего не получится. Чтобы это исправить будем передавать в функцию не отдельные параметры, а объект, содержащий все значения, которые нужно заменить.\n```javascript\nvar createMessage = function(str, settings) {\n  for (var key in settings) {\n    console.log(key, settings[key])\n    str = str.replace('%' + key + '%', settings[key]);\n  }\n  return str;\n};\n\n// Сразу же опробуем функцию\ncreateMessage('Данные: %data%, Правило: %rule%', {\n  data: 'Банан',\n  rule: 'Жёлтый'\n});\n// Данные: банан, Правило: желтый\n```\n\nТеперь функция принимает неограниченное число значений для замены и не зависит от порядка следования этих значений в объекте. Добавим эту функцию в наш модуль и будем использовать в методе `validate`.\n```javascript\nfn.validate = function() {\n  // ...\n  // Изначально считаем, что все правила пройдены\n  var isValid = true;\n  for (var rule in this.rules) {\n    var param = this.rules[rule];\n    var result = this[rule](param);\n    if (!result) {\n      isValid = false;\n      // Получаем шаблон сообщения из переданного пользователем объекта messages\n      var messageTemplate = this.messages[rule];\n      // Создаем сообщение с параметрами data и rule\n      this.message = createMessage(message, {\n        data: this.value,\n        rule: param\n      })\n      this.options.onError.call(this);\n      break;\n    }\n  }\n  if (isValid) {\n    this.options.onSuccess.call(this);\n  }\n};\n```\n\nТеперь у нас есть сообщение. Но как его можно будет использовать? Как вы, наверное, уже заметили, мы вызываем функции `onError` и `onSuccess` с помощью метода `call`, с помощью которого можно задавать значение `this` для функций. Другими словами, первый аргумент, передаваемый в метод `call` будет использован функцией, как `this`. Таким образом, мы получим возможность использовать все свойства и методы внутри функций.\n```javascript\nvar onError = function() {\n  console.log('Ошибка: ' + this.message);\n};\n```\n\n##### Обращение к прототипу\nЧтобы обеспечить удобство создания методов в нашей библиотеке, мы можем экспортировать из нашего модуля не только ссылку на функцию конструктор, но и на её прототип.\n```javascript\nvar Validator = (function(){\n\n  var Validate = function() {};\n  var fn = Validate.prototype;\n\n  return {\n    init: Validate,\n    fn: fn\n  }\n})();\n```\n\nТеперь для создания новой валидации нам придется использовать следующую конструкцию:\n```javascript\nvar emailValidation = new Validator.init(/* опции */);\n```\n\nСтало немного сложнее, но подобное решение позволяет создавать новые методы для конструктора `Validate`, обращаясь к его прототипу.\n```javascript\nVaidator.fn.password = function() {\n  return this.value === '1234qwerty';\n};\n\nvar passwordValidation = new Validator.init(document.getElementById('password'), {\n  rules: {\n    password: true\n  },\n  messages: {\n    password: 'Пароль %data% неверный'\n  }\n});\n```\n\n##### Код библиотеки целиком\nВы можете посмотреть результат применения библиотеки на [codepen](http://codepen.io/rtivital/pen/JGwaoV) или [скачать работающий пример](https://gist.github.com/rtivital/d5499b4b6c8377d79dd2/archive/4484ac046d7daba0adb1caa80632bc39f9305689.zip).\n\n```javascript\nvar Validator = (function() {\n  'use strict';\n\n  var _createMessage = function(message, settings) {\n    for (var key in settings) {\n      message = message.replace('%' + key + '%', settings[key]);\n    }\n    return message;\n  };\n\n  // http://youmightnotneedjquery.com/#deep_extend\n  var _extend = function(out) {\n    out = out || {};\n\n    for (var i = 1; i < arguments.length; i++) {\n      var obj = arguments[i];\n\n      if (!obj)\n        continue;\n\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          if (typeof obj[key] === 'object')\n            out[key] = _extend(out[key], obj[key]);\n          else\n            out[key] = obj[key];\n        }\n      }\n    }\n\n    return out;\n  };\n\n  var regExps = {\n    email: /^([\\w-]+(?:\\.[\\w-]+)*)@((?:[\\w-]+\\.)*\\w[\\w-]{0,66})\\.([a-z]{2,6}(?:\\.[a-z]{2})?)$/i,\n    url: /^((https?):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)|)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&%@!\\-\\/]))?$/,\n    numbers: /^\\d+(\\.\\d{1,2})?$/,\n    digits: /[0-9]*$/,\n    letters: /[a-z][A-Z]*$/\n  };\n\n  var messages = {\n    required: 'This field is required',\n    min: 'This field should contain at least %rule% characters',\n    max: 'This field should not contain more than %rule% characters',\n    match: 'This field shold countain a valid %rule%'\n  };\n\n  var Validate = function(element, options) {\n    var defaults = {\n      regExps: regExps,\n      messages: messages\n    };\n\n    this.options = _extend({}, defaults, options);\n    this.element = element;\n    this.regExps = regExps;\n  };\n\n  var fn = Validate.prototype;\n\n  fn.validate = function() {\n    var isValid = true;\n\n    this.value = this.element.value.trim();\n    this.length = this.value.length;\n\n    for (var rule in this.options.rules) {\n      var param = this.options.rules[rule];\n\n      if (!this[rule](param)) {\n        isValid = false;\n        this.message = _createMessage(this.options.messages[rule], {rule: param, data: this.value});\n        this.options.onError.call(this);\n        break;\n      }\n    }\n\n    if (isValid) {\n      this.options.onSuccess.call(this);\n    }\n  };\n\n  fn.required = function() { return this.length > 0;};\n  fn.min = function(param) { return this.length >= param; };\n  fn.max = function(param) { return this.length <= param; };\n  fn.match = function(param) { return this.regExps[param].test(this.value); };\n\n  return {\n    init: Validate,\n    fn: fn\n  };\n})();\n```\n\nЗаметили, каким хитрым образом мы установили объект настроек `this.options`? Функция `_extend` широко используется в подобных ситуациях и позволяет переназначить параметры, заданные по умолчанию с помощью объекта настроек.\n\n##### Что дальше?\nНаписанное нами решение небезопасно и недружелюбно к пользователю. Всё из-за того, что мы не включили ни одной обработки ошибок. Представьте, что будет, если пользователь попробует передать в функцию-конструктор `Validate` DOM элемент, у которого не будет свойства `value`. Или что случится, когда пользователь попробует воспользоваться несуществующим сообщением об ошибке или же регулярным выражением? Попробуйте сами предусмотреть подобные ситуации и улучшить библиотеку. Вы также можете посмотреть мои в [этом репозитории](https://github.com/rtivital/validate).\n\nЕсли вы хотите ещё попрактиковаться на данном примере, то попробуйте написать следующие методы:\n\nМетод `contain` проверяет нахождение всех переданных подстрок в проверяемых данных:\n```javascript\nvar emailValidator = new Validator.init(email, {\n  rules: {\n    contain: ['@', '.com', 'gmail']\n  }\n});\n```\n\nМетод `only` проверяет сотоит ли введённое пользователем значение только из указанных символов:\n```javascript\nvar phoneValidator = new Validator.init(phone, {\n  rules: {\n    only: [1, 2, 3, 4, 5, 6, 7, 8, 9, 0, '+', '-', '(', ')']\n  }\n});\n```\n","source":"_posts/oop-example-validation.md","raw":"---\ntitle: \"Объектно-ориентированный JavaScript: немного практики\"\nauthor: rtivital\ndate: \"2016-04-23\"\ncategories: Статья\ntags: [OOP, JavaScript]\n---\nВ прошлых статьях мы рассмотрели [основы работы с объектами](http://jsraccoon.ru/oop-object-base), [функции конструкторы](http://jsraccoon.ru/oop-constructors) и [прототипы](http://jsraccoon.ru/oop-prototypes). А, значит, настало время окончательно во всём разобраться и написать боевой пример — небольшую библиотеку для валидации данных. Полный код библиотеки, которую будем создавать в этой статье, можно найти в [этом репозитории](https://github.com/rtivital/validate). Если же вы хотите в ходе чтения статьи следовать всем инструкциям, то вы можете скачать [стартовый шаблон](https://gist.github.com/rtivital/229191009ff742df62bd).\n<!--MORE-->\n##### Идея\nБиблиотека предназначена для валидации данных из одного поля ввода (тега `<input>` или `<textarea>`) и предоставляет несколько простых методов проверки данных. Например, можно проверить правильность введённого email адреса или указать максимальное и минимальное количество символов. Сама по себе, библиотека не даёт огромного функционала, но очень проста в расширении, предлагая пользователю самому дописать необходимые ему методы для валидации данных. В комплекте с библиотекой идёт простой строковый шаблонизатор, который поможет выводить понятные сообщения об ошибках.\n\n##### Параметры\nНеобходимо всегда точно осознавать, что будет делать созданная вами функция-конструктор перед тем, как вы начнёте писать код. Поэтому, для начала, попробуем описать, что будет делать валидатор данных. Мы уже знаем, что нам обязательно нужно передавать DOM элемент (`<input>` или `<textarea>`), но помимо этого нам также необходимо узнать правила валидации, шаблоны сообщений об ошибках и `callback` функции, которые будут срабатывать при успешном или, наоборот, неуспешном завершении валидации. Очевидно, что параметров достаточно много и передавать их в функцию по одному будет крайне неудобно. Как раз для таких целей и существуют объекты. Используя объект, мы можем удобно сгруппировать все передаваемые в функцию данные. Таким образом, все параметры, которые нужно предоставить функции-конструктору: DOM элемент и объект настроек.\n```javascript\nvar email = document.getElementbyId('email');\nvar emailValidation = new Validator(email, { /* объект настроек */ });\n```\n\n##### Объект настроек\nИтак, у нас уже есть поле ввода, данные из которого будут проверяться, но этого же недостаточно. По крайней мере, нужно указать правила, в соответствие с которыми будет проводиться валидация. Для этого создадим свойство `rules` в объекте настроек, которое будет содержать все правила:\n```javascript\nvar settings = {\n  rules: {\n    min: 8,\n    max: 50,\n    match: 'email'\n  }\n};\n```\n\nДанная конфигурация скажет функции-конструктору, что поле ввода должно содержать валидный адрес электронной почты, длина которого не меньше 8 и не больше 50 символов.\n\nК каждому правилу должно прилагаться сообщение об ошибке, которое будет использовано, когда валидация данных будет провалена. Поэтому создадим ещё одно свойство объекта `settings`, которое будет содержать все сообщения об ошибках.\n```javascript\nvar settings = {\n  rules: { /* ... */ },\n  messages: {\n    min: 'Поле должно содержать больше 8 символов',\n    max: 'Поле не должно содержать больше 50 символов',\n    match: 'Поле должно содержать валидный адрес электронной почты'\n  }\n};\n```\n\nТеперь остался последний, но самый важный шаг для завершения конфигурации — `callback` функции. Для наглядности назовём их `onError` и `onSuccess`. Данные функции, передаваемые с объектом настроек, будут срабатывать при завершении валидации в зависимости от её результата. Они могут содержать всё что угодно, но пока для простоты будем просто выводить в консоль сообщения.\n```javascript\nvar settings = {\n  rules: { /* ... */ },\n  messages: { /* ... */ },\n  onError: function() { console.log('Валидация провалена'); },\n  onSuccess: function() { console.log('Валидация прошла успешно'); }\n};\n```\n\nИтак, основа нашего объекта настроек готова, и мы уже определились со всеми параметрами, передаваемыми в функцию, а, значит, половина работы мы уже сделали.\n```javascript\nvar settings = {\n  rules: {\n    min: 8,\n    max: 50,\n    match: 'email'\n  },\n  messages: {\n    min: 'Поле должно содержать больше 8 символов',\n    max: 'Поле не должно содержать больше 50 символов',\n    match: 'Поле должно содержать валидный адрес электронной почты'\n  },\n  onError: function() { console.log('Валидация провалена'); },\n  onSuccess: function() { console.log('Валидация прошла успешно'); }\n};\n\nvar email = document.getElementbyId('email');\nvar emailValidation = new Validator(email, settings);\n```\n\n##### Паттерн \"Модуль\"\nПри создании библиотеки мы не хотим, чтобы все наши \"внутренние\" переменные попали в чужие руки (кто знает, что задумали другие разработчики-злодеи). Может возникнуть конфликт имён и любую переменную из нашей библиотеки сможет перезаписать сторонний код. Чтобы этого не произошло, необходимо ограничить доступ. Удобнее всего это сделать с помощью [паттерна \"Модуль\"](http://forwebdev.ru/javascript/module-pattern/). Всё, что для этого нужно, — обвернуть весь наш код в немедленно вызываемую анонимную функцию и записать результат её выполнения в переменную, которая и будет использоваться другими разработчиками.\n```javascript\nvar Validator = (function() {})();\n```\n\nТаким образом, мы создали новую область видимости. Всё, что находится внутри неё, не будет доступно для записи и чтения, если мы сами не запишем данные, как свойство объекта `window`, или не вернём значение — в этом случае то, что возвращает функция будет записано в переменную `Validator`. Создадим функцию-конструктор и экспортируем её из модуля:\n```javascript\nvar Validator = (function() {\n  'use strict';\n\n  var Validate = function(element, options) {\n    this.element = element;\n    this.options = options;\n  };\n\n  return Validate;\n})();\n```\n\nТеперь у нас есть возможность использовать функцию `Validate` вне модуля, так как она была записана в переменную `Validator`.\n```javascript\nvar emailValidation = new Validator('element', 'options');\nconsole.log(emailValidation); // { element: \"element\", options: \"options\" }\n```\n\nКак я уже писал выше, мы также можем записать любые данные, как свойство объекта `window`. При подобной подходе у нас уже не возникает необходимости возвращать что-либо из модуля. Поэтому и результат выполнения записывать в переменную нет необходимости.\n```javascript\n(function() {\n  'use strict';\n\n  var Validate = function(element, options) {\n    this.element = element;\n    this.options = options;\n  };\n\n  window.Validator = Validate;\n})();\n```\n\n##### Запись свойств\nМы уже приступили к созданию функции-конструктора `Validate` и записали два свойства: `element` и `options`. Этого вполне достаточно, но было бы удобно обращаться к некоторым свойствам напрямую, например, писать каждый раз не `this.options.rules`, а просто `this.rules`. Поэтому создадим ещё несколько свойств для удобства:\n\n* `value` для обращения к введенным в поле ввода данным\n* `length` — количество символов в полученном `value`\n* `rules` — объект, содержащий все правила\n* и `messages` — объект со всеми сообщениями\n\n```javascript\nvar Validate = function(element, options) {\n  this.element = element;\n  this.options = options;\n\n  this.value = this.element.value.trim();\n  this.length = this.value.length;\n  this.rules = this.options.rules;\n  this.mesages = this.options.messages;\n};\n```\n\n##### Методы\nВ начале статьи я писал, что библиотека достаточно минималистична и не располагает огромным количеством методов. Поэтому ограничимся самым минимальным набором:\n\n* `required` — проверка наличия хотя бы одного непробельного символа\n* `min` — минимальное количество символов\n* `max` — максимальное количество символов\n* `match` — проверка соответствия какому-либо паттерну\n\n##### required\nВсё, что необходимо сделать в методе — сравнить длину значения `this.length` с нулём. Таким, образом мы убедимся, что был введён хотя бы один непробельный символ:\n```javascript\nValidate.prototype.required = function() {\n  return this.length > 0;\n};\n```\n\n##### min и max\nМетоды `min` и `max` практически повторяют метод `required`, но также принимают параметр, с которым будут сравнивать длину полученного значения `this.length`:\n```javascript\nValidate.prototype.min = function(param) {\n  return this.length >= param;\n};\n\nValidate.prototype.max = function(param) {\n  return this.length <= param;\n};\n```\n\n##### match\nМетод `match` работает с регулярными выражениями. Для простоты создадим объект, который будет содержать все наши регулярные выражения. Положим его в переменную `regExps` и объявим её вне метода.\n```javascript\nvar regExps = {\n  email: /^([\\w-]+(?:\\.[\\w-]+)*)@((?:[\\w-]+\\.)*\\w[\\w-]{0,66})\\.([a-z]{2,6}(?:\\.[a-z]{2})?)$/i,\n  url: /^((https?):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)|)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&%@!\\-\\/]))?$/,\n  numbers: /^\\d+(\\.\\d{1,2})?$/,\n  digits: /[0-9]*$/,\n  letters: /[a-z][A-Z]*$/\n};\n\nValidate.prototype.match = function(param) {};\n```\n\nТеперь мы сможем получить к ним доступ внутри метода `match`. В будущем нам ещё понадобится этот объект, так что поместить его вне метода `match` — хорошая идея.\nЧтобы проверить соответствие значения `this.value` регулярному выражению нужно воспользоваться методом `test`:\n```javascript\nValidate.prototype.match = function(param) {\n  // выбираем регулярное выражение\n  var re = regExps[param];\n  // Тестируем\n  return re.test(this.value);\n};\n\n// Кратко\nValidate.prototype.match = function(param) {\n  return regExps[param].test(this.value);\n};\n```\n\n##### Всё вместе\nИтак, мы написали 4 метода для валидации данных:\n```javascript\nValidate.prototype.required = function() {\n  return this.length > 0;\n};\n\nValidate.prototype.min = function(param) {\n  return this.length >= param;\n};\n\nValidate.prototype.max = function(param) {\n  return this.length <= param;\n};\n\nValidate.prototype.match = function(param) {\n  return regExps[param].test(this.value);\n};\n```\n\nДля их создания нам каждый раз приходилось обращаться к прототипу функции-конструктора `Validate`. Запись `Validate.prototype` достаточно громоздкая. Чтобы каждый раз не использовать её можно создать переменную, которая будет ссылаться на прототип. Так как любой прототип является не более чем простым объектом, мы можем смело задавать подобные переменные:\n```javascript\nvar fn = Validate.prototype;\nfn.required = function() { return this.length > 0; };\nfn.min = function(param) { return this.length >= param; };\nfn.max = function(param) { return this.length <= param; };\nfn.match = function(param) { return regExps[param].test(this.value); };\n```\n\n##### Валидация\nСами по себе написанные нами ранее методы бесполезны. Они ничего не умеют, кроме проверки данных. То есть для создания сообщений, группировки этих методов и вызова `callback` функций они не подходят. Поэтому создадим ещё один метод `validate`, который будет отвечать за обработку всего выше перечисленного.\n```javascript\nfn.validate = function() {};\n```\n\nПервое, что нужно сделать — перезаписать значение для `this.value` и `this.length`. При каждом запуске метода `validate` мы хотим получать новые данные из поля ввода и только потом проверять их.\n```javascript\nfn.validate = function() {\n  this.value = this.element.value.trim();\n  this.length = this.value.length;\n};\n```\n\nТеперь у нас есть самые \"свежие\" данные и мы можем их использовать для проверки соответствия правилам, которые записаны в объекте `this.rules`. Свойства объекта `this.rules` соответствуют написанным нами ранее методам. Удобнее всего правила перебрать с помощью цикла `for .. in`:\n```javascript\n// Пример объекта правил\n// {\n//   min: 8,\n//   max: 50,\n//   match: 'email'\n// }\n\nfn.validate = function() {\n  this.value = this.element.value.trim();\n  this.length = this.value.length;\n\n  for (var rule in this.rules) {\n    var param = this.rules[rule];\n  }\n};\n```\n\nИтак, мы написали цикл, с помощью которого мы переберём все передаваемые в функцию правила. При каждой итерации внутри цикла у нас будет доступ к имени текущего правила, например, `min`, а также к параметру правила, например `8` для правила `min`. Всё, что нам остаётся сделать, — последовательно применить созданные нам ранее методы.\n```javascript\nfn.validate = function() {\n  // ...\n  for (var rule in this.rules) {\n    var param = this.rules[rule];\n    var result = this[rule](param);\n  }\n};\n```\n\nПеременная `result` всегда содержит значение типа `boolean`, с помощью которого мы можем сказать соответствует ли наше `this.value` требованиям, описанным в правилах. Если мы узнали, что значение не соответствует какому-либо правилу, то мы сразу же прерываем выполнение цикла и вызываем `callback` функцию `onError`. Если же значение прошло проверки на все заданные правила, то нужно вызвать функцию `onSuccess`. Перед циклом объявим переменную `isValid`, которая будет сигнализировать о состоянии валидации.\n```javascript\nfn.validate = function() {\n  // ...\n  // Изначально считаем, что все правила пройдены\n  var isValid = true;\n  for (var rule in this.rules) {\n    var param = this.rules[rule];\n    var result = this[rule](param);\n    if (!result) {\n      // Если вылидация провалилась, то выставляем значение false\n      isValid = false;\n      // Вызываем функцию onError\n      this.options.onError.call(this);\n      // И прерываем выполнение цикла\n      break;\n    }\n  }\n\n  // После завершения цикла проверяем isValid\n  if (isValid) {\n    // Если всё хорошо, то вызываем функцию onSuccess\n    this.options.onSuccess.call(this);\n  }\n};\n```\n\n##### Пишем сообщения\nНаписанный нами метод `validate` уже сейчас достаточно хорошо. Он умеет проверять соответствие данных всем переданным правилам и вызывать функции в зависимости от результата проверки. Но мы также хотим передавать содержательные сообщения о полученных ошибках. В этом нам поможет простая функция для строковой шаблонизации. Допустим, что на выходе мы хотим получить сообщение, которое будет содержать введённые пользователем данные, а также параметр из наших правил. Чтобы получить подобную конструкцию мы можем составить строку:\n```javascript\nvar rules = {\n  min: 8\n};\nvar messages = {\n  min: 'Значение должно быть не менее %rule% символов. Значение \"%data%\" не подходит.'\n};\n```\n\nВ полученной строке необходимо заменить `%rule%` на параметр (в данном случае 8), а `%data%` на значение, полученное от пользователя. Таким образом, со всеми заменами строка будет выглядеть следующим образом: `'Значение должно быть не менее 8 символов. Значение \"банан\" не подходит.'`\n\nРеализовать подобную шаблонизацию достаточно просто с помощью метода строк `replace`. Чтобы не забивать наш метод `validate` большим количеством кода, создадим для этого отдельную функцию `createMessage`:\n```javascript\nvar createMessage = function(str, rule, data) {\n  return str.replace('%rule%', rule).replace('%data%', data);\n};\n\n// Сразу же опробуем функцию\ncreateMessage('Данные: %data%, Правило: %rule%','желтый', 'банан');\n// Данные: банан, Правило: желтый\n```\n\nФункция работает. Но работает только для наших конкретных переменных. Если в будущем мы захотим передавать и другие значения, то у нас ничего не получится. Чтобы это исправить будем передавать в функцию не отдельные параметры, а объект, содержащий все значения, которые нужно заменить.\n```javascript\nvar createMessage = function(str, settings) {\n  for (var key in settings) {\n    console.log(key, settings[key])\n    str = str.replace('%' + key + '%', settings[key]);\n  }\n  return str;\n};\n\n// Сразу же опробуем функцию\ncreateMessage('Данные: %data%, Правило: %rule%', {\n  data: 'Банан',\n  rule: 'Жёлтый'\n});\n// Данные: банан, Правило: желтый\n```\n\nТеперь функция принимает неограниченное число значений для замены и не зависит от порядка следования этих значений в объекте. Добавим эту функцию в наш модуль и будем использовать в методе `validate`.\n```javascript\nfn.validate = function() {\n  // ...\n  // Изначально считаем, что все правила пройдены\n  var isValid = true;\n  for (var rule in this.rules) {\n    var param = this.rules[rule];\n    var result = this[rule](param);\n    if (!result) {\n      isValid = false;\n      // Получаем шаблон сообщения из переданного пользователем объекта messages\n      var messageTemplate = this.messages[rule];\n      // Создаем сообщение с параметрами data и rule\n      this.message = createMessage(message, {\n        data: this.value,\n        rule: param\n      })\n      this.options.onError.call(this);\n      break;\n    }\n  }\n  if (isValid) {\n    this.options.onSuccess.call(this);\n  }\n};\n```\n\nТеперь у нас есть сообщение. Но как его можно будет использовать? Как вы, наверное, уже заметили, мы вызываем функции `onError` и `onSuccess` с помощью метода `call`, с помощью которого можно задавать значение `this` для функций. Другими словами, первый аргумент, передаваемый в метод `call` будет использован функцией, как `this`. Таким образом, мы получим возможность использовать все свойства и методы внутри функций.\n```javascript\nvar onError = function() {\n  console.log('Ошибка: ' + this.message);\n};\n```\n\n##### Обращение к прототипу\nЧтобы обеспечить удобство создания методов в нашей библиотеке, мы можем экспортировать из нашего модуля не только ссылку на функцию конструктор, но и на её прототип.\n```javascript\nvar Validator = (function(){\n\n  var Validate = function() {};\n  var fn = Validate.prototype;\n\n  return {\n    init: Validate,\n    fn: fn\n  }\n})();\n```\n\nТеперь для создания новой валидации нам придется использовать следующую конструкцию:\n```javascript\nvar emailValidation = new Validator.init(/* опции */);\n```\n\nСтало немного сложнее, но подобное решение позволяет создавать новые методы для конструктора `Validate`, обращаясь к его прототипу.\n```javascript\nVaidator.fn.password = function() {\n  return this.value === '1234qwerty';\n};\n\nvar passwordValidation = new Validator.init(document.getElementById('password'), {\n  rules: {\n    password: true\n  },\n  messages: {\n    password: 'Пароль %data% неверный'\n  }\n});\n```\n\n##### Код библиотеки целиком\nВы можете посмотреть результат применения библиотеки на [codepen](http://codepen.io/rtivital/pen/JGwaoV) или [скачать работающий пример](https://gist.github.com/rtivital/d5499b4b6c8377d79dd2/archive/4484ac046d7daba0adb1caa80632bc39f9305689.zip).\n\n```javascript\nvar Validator = (function() {\n  'use strict';\n\n  var _createMessage = function(message, settings) {\n    for (var key in settings) {\n      message = message.replace('%' + key + '%', settings[key]);\n    }\n    return message;\n  };\n\n  // http://youmightnotneedjquery.com/#deep_extend\n  var _extend = function(out) {\n    out = out || {};\n\n    for (var i = 1; i < arguments.length; i++) {\n      var obj = arguments[i];\n\n      if (!obj)\n        continue;\n\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          if (typeof obj[key] === 'object')\n            out[key] = _extend(out[key], obj[key]);\n          else\n            out[key] = obj[key];\n        }\n      }\n    }\n\n    return out;\n  };\n\n  var regExps = {\n    email: /^([\\w-]+(?:\\.[\\w-]+)*)@((?:[\\w-]+\\.)*\\w[\\w-]{0,66})\\.([a-z]{2,6}(?:\\.[a-z]{2})?)$/i,\n    url: /^((https?):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)|)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&%@!\\-\\/]))?$/,\n    numbers: /^\\d+(\\.\\d{1,2})?$/,\n    digits: /[0-9]*$/,\n    letters: /[a-z][A-Z]*$/\n  };\n\n  var messages = {\n    required: 'This field is required',\n    min: 'This field should contain at least %rule% characters',\n    max: 'This field should not contain more than %rule% characters',\n    match: 'This field shold countain a valid %rule%'\n  };\n\n  var Validate = function(element, options) {\n    var defaults = {\n      regExps: regExps,\n      messages: messages\n    };\n\n    this.options = _extend({}, defaults, options);\n    this.element = element;\n    this.regExps = regExps;\n  };\n\n  var fn = Validate.prototype;\n\n  fn.validate = function() {\n    var isValid = true;\n\n    this.value = this.element.value.trim();\n    this.length = this.value.length;\n\n    for (var rule in this.options.rules) {\n      var param = this.options.rules[rule];\n\n      if (!this[rule](param)) {\n        isValid = false;\n        this.message = _createMessage(this.options.messages[rule], {rule: param, data: this.value});\n        this.options.onError.call(this);\n        break;\n      }\n    }\n\n    if (isValid) {\n      this.options.onSuccess.call(this);\n    }\n  };\n\n  fn.required = function() { return this.length > 0;};\n  fn.min = function(param) { return this.length >= param; };\n  fn.max = function(param) { return this.length <= param; };\n  fn.match = function(param) { return this.regExps[param].test(this.value); };\n\n  return {\n    init: Validate,\n    fn: fn\n  };\n})();\n```\n\nЗаметили, каким хитрым образом мы установили объект настроек `this.options`? Функция `_extend` широко используется в подобных ситуациях и позволяет переназначить параметры, заданные по умолчанию с помощью объекта настроек.\n\n##### Что дальше?\nНаписанное нами решение небезопасно и недружелюбно к пользователю. Всё из-за того, что мы не включили ни одной обработки ошибок. Представьте, что будет, если пользователь попробует передать в функцию-конструктор `Validate` DOM элемент, у которого не будет свойства `value`. Или что случится, когда пользователь попробует воспользоваться несуществующим сообщением об ошибке или же регулярным выражением? Попробуйте сами предусмотреть подобные ситуации и улучшить библиотеку. Вы также можете посмотреть мои в [этом репозитории](https://github.com/rtivital/validate).\n\nЕсли вы хотите ещё попрактиковаться на данном примере, то попробуйте написать следующие методы:\n\nМетод `contain` проверяет нахождение всех переданных подстрок в проверяемых данных:\n```javascript\nvar emailValidator = new Validator.init(email, {\n  rules: {\n    contain: ['@', '.com', 'gmail']\n  }\n});\n```\n\nМетод `only` проверяет сотоит ли введённое пользователем значение только из указанных символов:\n```javascript\nvar phoneValidator = new Validator.init(phone, {\n  rules: {\n    only: [1, 2, 3, 4, 5, 6, 7, 8, 9, 0, '+', '-', '(', ')']\n  }\n});\n```\n","slug":"oop-example-validation","published":1,"updated":"2016-05-23T13:40:45.797Z","_id":"ciok26pl900006gpnpwu7la6x","comments":1,"layout":"post","photos":[],"link":"","content":"<p>В прошлых статьях мы рассмотрели <a href=\"http://jsraccoon.ru/oop-object-base\" target=\"_blank\" rel=\"external\">основы работы с объектами</a>, <a href=\"http://jsraccoon.ru/oop-constructors\" target=\"_blank\" rel=\"external\">функции конструкторы</a> и <a href=\"http://jsraccoon.ru/oop-prototypes\" target=\"_blank\" rel=\"external\">прототипы</a>. А, значит, настало время окончательно во всём разобраться и написать боевой пример — небольшую библиотеку для валидации данных. Полный код библиотеки, которую будем создавать в этой статье, можно найти в <a href=\"https://github.com/rtivital/validate\" target=\"_blank\" rel=\"external\">этом репозитории</a>. Если же вы хотите в ходе чтения статьи следовать всем инструкциям, то вы можете скачать <a href=\"https://gist.github.com/rtivital/229191009ff742df62bd\" target=\"_blank\" rel=\"external\">стартовый шаблон</a>.<br><a id=\"more\"></a></p>\n<h5 id=\"Идея\"><a href=\"#Идея\" class=\"headerlink\" title=\"Идея\"></a>Идея</h5><p>Библиотека предназначена для валидации данных из одного поля ввода (тега <code>&lt;input&gt;</code> или <code>&lt;textarea&gt;</code>) и предоставляет несколько простых методов проверки данных. Например, можно проверить правильность введённого email адреса или указать максимальное и минимальное количество символов. Сама по себе, библиотека не даёт огромного функционала, но очень проста в расширении, предлагая пользователю самому дописать необходимые ему методы для валидации данных. В комплекте с библиотекой идёт простой строковый шаблонизатор, который поможет выводить понятные сообщения об ошибках.</p>\n<h5 id=\"Параметры\"><a href=\"#Параметры\" class=\"headerlink\" title=\"Параметры\"></a>Параметры</h5><p>Необходимо всегда точно осознавать, что будет делать созданная вами функция-конструктор перед тем, как вы начнёте писать код. Поэтому, для начала, попробуем описать, что будет делать валидатор данных. Мы уже знаем, что нам обязательно нужно передавать DOM элемент (<code>&lt;input&gt;</code> или <code>&lt;textarea&gt;</code>), но помимо этого нам также необходимо узнать правила валидации, шаблоны сообщений об ошибках и <code>callback</code> функции, которые будут срабатывать при успешном или, наоборот, неуспешном завершении валидации. Очевидно, что параметров достаточно много и передавать их в функцию по одному будет крайне неудобно. Как раз для таких целей и существуют объекты. Используя объект, мы можем удобно сгруппировать все передаваемые в функцию данные. Таким образом, все параметры, которые нужно предоставить функции-конструктору: DOM элемент и объект настроек.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> email = <span class=\"built_in\">document</span>.getElementbyId(<span class=\"string\">'email'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> emailValidation = <span class=\"keyword\">new</span> Validator(email, &#123; <span class=\"comment\">/* объект настроек */</span> &#125;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Объект-настроек\"><a href=\"#Объект-настроек\" class=\"headerlink\" title=\"Объект настроек\"></a>Объект настроек</h5><p>Итак, у нас уже есть поле ввода, данные из которого будут проверяться, но этого же недостаточно. По крайней мере, нужно указать правила, в соответствие с которыми будет проводиться валидация. Для этого создадим свойство <code>rules</code> в объекте настроек, которое будет содержать все правила:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> settings = &#123;</span><br><span class=\"line\">  rules: &#123;</span><br><span class=\"line\">    min: <span class=\"number\">8</span>,</span><br><span class=\"line\">    max: <span class=\"number\">50</span>,</span><br><span class=\"line\">    match: <span class=\"string\">'email'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Данная конфигурация скажет функции-конструктору, что поле ввода должно содержать валидный адрес электронной почты, длина которого не меньше 8 и не больше 50 символов.</p>\n<p>К каждому правилу должно прилагаться сообщение об ошибке, которое будет использовано, когда валидация данных будет провалена. Поэтому создадим ещё одно свойство объекта <code>settings</code>, которое будет содержать все сообщения об ошибках.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> settings = &#123;</span><br><span class=\"line\">  rules: &#123; <span class=\"comment\">/* ... */</span> &#125;,</span><br><span class=\"line\">  messages: &#123;</span><br><span class=\"line\">    min: <span class=\"string\">'Поле должно содержать больше 8 символов'</span>,</span><br><span class=\"line\">    max: <span class=\"string\">'Поле не должно содержать больше 50 символов'</span>,</span><br><span class=\"line\">    match: <span class=\"string\">'Поле должно содержать валидный адрес электронной почты'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Теперь остался последний, но самый важный шаг для завершения конфигурации — <code>callback</code> функции. Для наглядности назовём их <code>onError</code> и <code>onSuccess</code>. Данные функции, передаваемые с объектом настроек, будут срабатывать при завершении валидации в зависимости от её результата. Они могут содержать всё что угодно, но пока для простоты будем просто выводить в консоль сообщения.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> settings = &#123;</span><br><span class=\"line\">  rules: &#123; <span class=\"comment\">/* ... */</span> &#125;,</span><br><span class=\"line\">  messages: &#123; <span class=\"comment\">/* ... */</span> &#125;,</span><br><span class=\"line\">  onError: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'Валидация провалена'</span>); &#125;,</span><br><span class=\"line\">  onSuccess: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'Валидация прошла успешно'</span>); &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Итак, основа нашего объекта настроек готова, и мы уже определились со всеми параметрами, передаваемыми в функцию, а, значит, половина работы мы уже сделали.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> settings = &#123;</span><br><span class=\"line\">  rules: &#123;</span><br><span class=\"line\">    min: <span class=\"number\">8</span>,</span><br><span class=\"line\">    max: <span class=\"number\">50</span>,</span><br><span class=\"line\">    match: <span class=\"string\">'email'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  messages: &#123;</span><br><span class=\"line\">    min: <span class=\"string\">'Поле должно содержать больше 8 символов'</span>,</span><br><span class=\"line\">    max: <span class=\"string\">'Поле не должно содержать больше 50 символов'</span>,</span><br><span class=\"line\">    match: <span class=\"string\">'Поле должно содержать валидный адрес электронной почты'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  onError: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'Валидация провалена'</span>); &#125;,</span><br><span class=\"line\">  onSuccess: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'Валидация прошла успешно'</span>); &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> email = <span class=\"built_in\">document</span>.getElementbyId(<span class=\"string\">'email'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> emailValidation = <span class=\"keyword\">new</span> Validator(email, settings);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Паттерн-“Модуль”\"><a href=\"#Паттерн-“Модуль”\" class=\"headerlink\" title=\"Паттерн “Модуль”\"></a>Паттерн “Модуль”</h5><p>При создании библиотеки мы не хотим, чтобы все наши “внутренние” переменные попали в чужие руки (кто знает, что задумали другие разработчики-злодеи). Может возникнуть конфликт имён и любую переменную из нашей библиотеки сможет перезаписать сторонний код. Чтобы этого не произошло, необходимо ограничить доступ. Удобнее всего это сделать с помощью <a href=\"http://forwebdev.ru/javascript/module-pattern/\" target=\"_blank\" rel=\"external\">паттерна “Модуль”</a>. Всё, что для этого нужно, — обвернуть весь наш код в немедленно вызываемую анонимную функцию и записать результат её выполнения в переменную, которая и будет использоваться другими разработчиками.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Validator = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;)();</span><br></pre></td></tr></table></figure></p>\n<p>Таким образом, мы создали новую область видимости. Всё, что находится внутри неё, не будет доступно для записи и чтения, если мы сами не запишем данные, как свойство объекта <code>window</code>, или не вернём значение — в этом случае то, что возвращает функция будет записано в переменную <code>Validator</code>. Создадим функцию-конструктор и экспортируем её из модуля:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Validator = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  'use strict'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> Validate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element, options</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.element = element;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.options = options;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> Validate;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></p>\n<p>Теперь у нас есть возможность использовать функцию <code>Validate</code> вне модуля, так как она была записана в переменную <code>Validator</code>.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> emailValidation = <span class=\"keyword\">new</span> Validator(<span class=\"string\">'element'</span>, <span class=\"string\">'options'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(emailValidation); <span class=\"comment\">// &#123; element: \"element\", options: \"options\" &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>Как я уже писал выше, мы также можем записать любые данные, как свойство объекта <code>window</code>. При подобной подходе у нас уже не возникает необходимости возвращать что-либо из модуля. Поэтому и результат выполнения записывать в переменную нет необходимости.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  'use strict'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> Validate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element, options</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.element = element;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.options = options;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">window</span>.Validator = Validate;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Запись-свойств\"><a href=\"#Запись-свойств\" class=\"headerlink\" title=\"Запись свойств\"></a>Запись свойств</h5><p>Мы уже приступили к созданию функции-конструктора <code>Validate</code> и записали два свойства: <code>element</code> и <code>options</code>. Этого вполне достаточно, но было бы удобно обращаться к некоторым свойствам напрямую, например, писать каждый раз не <code>this.options.rules</code>, а просто <code>this.rules</code>. Поэтому создадим ещё несколько свойств для удобства:</p>\n<ul>\n<li><code>value</code> для обращения к введенным в поле ввода данным</li>\n<li><code>length</code> — количество символов в полученном <code>value</code></li>\n<li><code>rules</code> — объект, содержащий все правила</li>\n<li>и <code>messages</code> — объект со всеми сообщениями</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Validate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.element = element;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.options = options;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.value = <span class=\"keyword\">this</span>.element.value.trim();</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.length = <span class=\"keyword\">this</span>.value.length;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.rules = <span class=\"keyword\">this</span>.options.rules;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.mesages = <span class=\"keyword\">this</span>.options.messages;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"Методы\"><a href=\"#Методы\" class=\"headerlink\" title=\"Методы\"></a>Методы</h5><p>В начале статьи я писал, что библиотека достаточно минималистична и не располагает огромным количеством методов. Поэтому ограничимся самым минимальным набором:</p>\n<ul>\n<li><code>required</code> — проверка наличия хотя бы одного непробельного символа</li>\n<li><code>min</code> — минимальное количество символов</li>\n<li><code>max</code> — максимальное количество символов</li>\n<li><code>match</code> — проверка соответствия какому-либо паттерну</li>\n</ul>\n<h5 id=\"required\"><a href=\"#required\" class=\"headerlink\" title=\"required\"></a>required</h5><p>Всё, что необходимо сделать в методе — сравнить длину значения <code>this.length</code> с нулём. Таким, образом мы убедимся, что был введён хотя бы один непробельный символ:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Validate.prototype.required = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"min-и-max\"><a href=\"#min-и-max\" class=\"headerlink\" title=\"min и max\"></a>min и max</h5><p>Методы <code>min</code> и <code>max</code> практически повторяют метод <code>required</code>, но также принимают параметр, с которым будут сравнивать длину полученного значения <code>this.length</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Validate.prototype.min = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length &gt;= param;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Validate.prototype.max = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length &lt;= param;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h5><p>Метод <code>match</code> работает с регулярными выражениями. Для простоты создадим объект, который будет содержать все наши регулярные выражения. Положим его в переменную <code>regExps</code> и объявим её вне метода.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> regExps = &#123;</span><br><span class=\"line\">  email: <span class=\"regexp\">/^([\\w-]+(?:\\.[\\w-]+)*)@((?:[\\w-]+\\.)*\\w[\\w-]&#123;0,66&#125;)\\.([a-z]&#123;2,6&#125;(?:\\.[a-z]&#123;2&#125;)?)$/i</span>,</span><br><span class=\"line\">  url: <span class=\"regexp\">/^((https?):\\/\\/(\\w+:&#123;0,1&#125;\\w*@)?(\\S+)|)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&amp;%@!\\-\\/]))?$/</span>,</span><br><span class=\"line\">  numbers: <span class=\"regexp\">/^\\d+(\\.\\d&#123;1,2&#125;)?$/</span>,</span><br><span class=\"line\">  digits: <span class=\"regexp\">/[0-9]*$/</span>,</span><br><span class=\"line\">  letters: <span class=\"regexp\">/[a-z][A-Z]*$/</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Validate.prototype.match = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Теперь мы сможем получить к ним доступ внутри метода <code>match</code>. В будущем нам ещё понадобится этот объект, так что поместить его вне метода <code>match</code> — хорошая идея.<br>Чтобы проверить соответствие значения <code>this.value</code> регулярному выражению нужно воспользоваться методом <code>test</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Validate.prototype.match = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// выбираем регулярное выражение</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> re = regExps[param];</span><br><span class=\"line\">  <span class=\"comment\">// Тестируем</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> re.test(<span class=\"keyword\">this</span>.value);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Кратко</span></span><br><span class=\"line\">Validate.prototype.match = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> regExps[param].test(<span class=\"keyword\">this</span>.value);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Всё-вместе\"><a href=\"#Всё-вместе\" class=\"headerlink\" title=\"Всё вместе\"></a>Всё вместе</h5><p>Итак, мы написали 4 метода для валидации данных:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Validate.prototype.required = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Validate.prototype.min = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length &gt;= param;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Validate.prototype.max = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length &lt;= param;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Validate.prototype.match = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> regExps[param].test(<span class=\"keyword\">this</span>.value);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Для их создания нам каждый раз приходилось обращаться к прототипу функции-конструктора <code>Validate</code>. Запись <code>Validate.prototype</code> достаточно громоздкая. Чтобы каждый раз не использовать её можно создать переменную, которая будет ссылаться на прототип. Так как любой прототип является не более чем простым объектом, мы можем смело задавать подобные переменные:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fn = Validate.prototype;</span><br><span class=\"line\">fn.required = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length &gt; <span class=\"number\">0</span>; &#125;;</span><br><span class=\"line\">fn.min = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length &gt;= param; &#125;;</span><br><span class=\"line\">fn.max = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length &lt;= param; &#125;;</span><br><span class=\"line\">fn.match = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123; <span class=\"keyword\">return</span> regExps[param].test(<span class=\"keyword\">this</span>.value); &#125;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Валидация\"><a href=\"#Валидация\" class=\"headerlink\" title=\"Валидация\"></a>Валидация</h5><p>Сами по себе написанные нами ранее методы бесполезны. Они ничего не умеют, кроме проверки данных. То есть для создания сообщений, группировки этих методов и вызова <code>callback</code> функций они не подходят. Поэтому создадим ещё один метод <code>validate</code>, который будет отвечать за обработку всего выше перечисленного.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn.validate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Первое, что нужно сделать — перезаписать значение для <code>this.value</code> и <code>this.length</code>. При каждом запуске метода <code>validate</code> мы хотим получать новые данные из поля ввода и только потом проверять их.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn.validate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.value = <span class=\"keyword\">this</span>.element.value.trim();</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.length = <span class=\"keyword\">this</span>.value.length;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Теперь у нас есть самые “свежие” данные и мы можем их использовать для проверки соответствия правилам, которые записаны в объекте <code>this.rules</code>. Свойства объекта <code>this.rules</code> соответствуют написанным нами ранее методам. Удобнее всего правила перебрать с помощью цикла <code>for .. in</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Пример объекта правил</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   min: 8,</span></span><br><span class=\"line\"><span class=\"comment\">//   max: 50,</span></span><br><span class=\"line\"><span class=\"comment\">//   match: 'email'</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">fn.validate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.value = <span class=\"keyword\">this</span>.element.value.trim();</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.length = <span class=\"keyword\">this</span>.value.length;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> rule <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.rules) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> param = <span class=\"keyword\">this</span>.rules[rule];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Итак, мы написали цикл, с помощью которого мы переберём все передаваемые в функцию правила. При каждой итерации внутри цикла у нас будет доступ к имени текущего правила, например, <code>min</code>, а также к параметру правила, например <code>8</code> для правила <code>min</code>. Всё, что нам остаётся сделать, — последовательно применить созданные нам ранее методы.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn.validate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> rule <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.rules) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> param = <span class=\"keyword\">this</span>.rules[rule];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"keyword\">this</span>[rule](param);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Переменная <code>result</code> всегда содержит значение типа <code>boolean</code>, с помощью которого мы можем сказать соответствует ли наше <code>this.value</code> требованиям, описанным в правилах. Если мы узнали, что значение не соответствует какому-либо правилу, то мы сразу же прерываем выполнение цикла и вызываем <code>callback</code> функцию <code>onError</code>. Если же значение прошло проверки на все заданные правила, то нужно вызвать функцию <code>onSuccess</code>. Перед циклом объявим переменную <code>isValid</code>, которая будет сигнализировать о состоянии валидации.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn.validate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// Изначально считаем, что все правила пройдены</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> isValid = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> rule <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.rules) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> param = <span class=\"keyword\">this</span>.rules[rule];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"keyword\">this</span>[rule](param);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Если вылидация провалилась, то выставляем значение false</span></span><br><span class=\"line\">      isValid = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"comment\">// Вызываем функцию onError</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.options.onError.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      <span class=\"comment\">// И прерываем выполнение цикла</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// После завершения цикла проверяем isValid</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isValid) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Если всё хорошо, то вызываем функцию onSuccess</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.options.onSuccess.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Пишем-сообщения\"><a href=\"#Пишем-сообщения\" class=\"headerlink\" title=\"Пишем сообщения\"></a>Пишем сообщения</h5><p>Написанный нами метод <code>validate</code> уже сейчас достаточно хорошо. Он умеет проверять соответствие данных всем переданным правилам и вызывать функции в зависимости от результата проверки. Но мы также хотим передавать содержательные сообщения о полученных ошибках. В этом нам поможет простая функция для строковой шаблонизации. Допустим, что на выходе мы хотим получить сообщение, которое будет содержать введённые пользователем данные, а также параметр из наших правил. Чтобы получить подобную конструкцию мы можем составить строку:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> rules = &#123;</span><br><span class=\"line\">  min: <span class=\"number\">8</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> messages = &#123;</span><br><span class=\"line\">  min: <span class=\"string\">'Значение должно быть не менее %rule% символов. Значение \"%data%\" не подходит.'</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>В полученной строке необходимо заменить <code>%rule%</code> на параметр (в данном случае 8), а <code>%data%</code> на значение, полученное от пользователя. Таким образом, со всеми заменами строка будет выглядеть следующим образом: <code>&#39;Значение должно быть не менее 8 символов. Значение &quot;банан&quot; не подходит.&#39;</code></p>\n<p>Реализовать подобную шаблонизацию достаточно просто с помощью метода строк <code>replace</code>. Чтобы не забивать наш метод <code>validate</code> большим количеством кода, создадим для этого отдельную функцию <code>createMessage</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> createMessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str, rule, data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str.replace(<span class=\"string\">'%rule%'</span>, rule).replace(<span class=\"string\">'%data%'</span>, data);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Сразу же опробуем функцию</span></span><br><span class=\"line\">createMessage(<span class=\"string\">'Данные: %data%, Правило: %rule%'</span>,<span class=\"string\">'желтый'</span>, <span class=\"string\">'банан'</span>);</span><br><span class=\"line\"><span class=\"comment\">// Данные: банан, Правило: желтый</span></span><br></pre></td></tr></table></figure></p>\n<p>Функция работает. Но работает только для наших конкретных переменных. Если в будущем мы захотим передавать и другие значения, то у нас ничего не получится. Чтобы это исправить будем передавать в функцию не отдельные параметры, а объект, содержащий все значения, которые нужно заменить.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> createMessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str, settings</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> settings) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(key, settings[key])</span><br><span class=\"line\">    str = str.replace(<span class=\"string\">'%'</span> + key + <span class=\"string\">'%'</span>, settings[key]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Сразу же опробуем функцию</span></span><br><span class=\"line\">createMessage(<span class=\"string\">'Данные: %data%, Правило: %rule%'</span>, &#123;</span><br><span class=\"line\">  data: <span class=\"string\">'Банан'</span>,</span><br><span class=\"line\">  rule: <span class=\"string\">'Жёлтый'</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// Данные: банан, Правило: желтый</span></span><br></pre></td></tr></table></figure></p>\n<p>Теперь функция принимает неограниченное число значений для замены и не зависит от порядка следования этих значений в объекте. Добавим эту функцию в наш модуль и будем использовать в методе <code>validate</code>.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn.validate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// Изначально считаем, что все правила пройдены</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> isValid = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> rule <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.rules) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> param = <span class=\"keyword\">this</span>.rules[rule];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"keyword\">this</span>[rule](param);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">      isValid = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"comment\">// Получаем шаблон сообщения из переданного пользователем объекта messages</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> messageTemplate = <span class=\"keyword\">this</span>.messages[rule];</span><br><span class=\"line\">      <span class=\"comment\">// Создаем сообщение с параметрами data и rule</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.message = createMessage(message, &#123;</span><br><span class=\"line\">        data: <span class=\"keyword\">this</span>.value,</span><br><span class=\"line\">        rule: param</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.options.onError.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isValid) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.options.onSuccess.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Теперь у нас есть сообщение. Но как его можно будет использовать? Как вы, наверное, уже заметили, мы вызываем функции <code>onError</code> и <code>onSuccess</code> с помощью метода <code>call</code>, с помощью которого можно задавать значение <code>this</code> для функций. Другими словами, первый аргумент, передаваемый в метод <code>call</code> будет использован функцией, как <code>this</code>. Таким образом, мы получим возможность использовать все свойства и методы внутри функций.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> onError = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Ошибка: '</span> + <span class=\"keyword\">this</span>.message);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Обращение-к-прототипу\"><a href=\"#Обращение-к-прототипу\" class=\"headerlink\" title=\"Обращение к прототипу\"></a>Обращение к прототипу</h5><p>Чтобы обеспечить удобство создания методов в нашей библиотеке, мы можем экспортировать из нашего модуля не только ссылку на функцию конструктор, но и на её прототип.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Validator = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> Validate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> fn = Validate.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    init: Validate,</span><br><span class=\"line\">    fn: fn</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></p>\n<p>Теперь для создания новой валидации нам придется использовать следующую конструкцию:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> emailValidation = <span class=\"keyword\">new</span> Validator.init(<span class=\"comment\">/* опции */</span>);</span><br></pre></td></tr></table></figure></p>\n<p>Стало немного сложнее, но подобное решение позволяет создавать новые методы для конструктора <code>Validate</code>, обращаясь к его прототипу.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vaidator.fn.password = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.value === <span class=\"string\">'1234qwerty'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> passwordValidation = <span class=\"keyword\">new</span> Validator.init(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'password'</span>), &#123;</span><br><span class=\"line\">  rules: &#123;</span><br><span class=\"line\">    password: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  messages: &#123;</span><br><span class=\"line\">    password: <span class=\"string\">'Пароль %data% неверный'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Код-библиотеки-целиком\"><a href=\"#Код-библиотеки-целиком\" class=\"headerlink\" title=\"Код библиотеки целиком\"></a>Код библиотеки целиком</h5><p>Вы можете посмотреть результат применения библиотеки на <a href=\"http://codepen.io/rtivital/pen/JGwaoV\" target=\"_blank\" rel=\"external\">codepen</a> или <a href=\"https://gist.github.com/rtivital/d5499b4b6c8377d79dd2/archive/4484ac046d7daba0adb1caa80632bc39f9305689.zip\" target=\"_blank\" rel=\"external\">скачать работающий пример</a>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Validator = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  'use strict'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> _createMessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">message, settings</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> settings) &#123;</span><br><span class=\"line\">      message = message.replace(<span class=\"string\">'%'</span> + key + <span class=\"string\">'%'</span>, settings[key]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// http://youmightnotneedjquery.com/#deep_extend</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> _extend = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">out</span>) </span>&#123;</span><br><span class=\"line\">    out = out || &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">arguments</span>.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> obj = <span class=\"built_in\">arguments</span>[i];</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!obj)</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> obj[key] === <span class=\"string\">'object'</span>)</span><br><span class=\"line\">            out[key] = _extend(out[key], obj[key]);</span><br><span class=\"line\">          <span class=\"keyword\">else</span></span><br><span class=\"line\">            out[key] = obj[key];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> out;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> regExps = &#123;</span><br><span class=\"line\">    email: <span class=\"regexp\">/^([\\w-]+(?:\\.[\\w-]+)*)@((?:[\\w-]+\\.)*\\w[\\w-]&#123;0,66&#125;)\\.([a-z]&#123;2,6&#125;(?:\\.[a-z]&#123;2&#125;)?)$/i</span>,</span><br><span class=\"line\">    url: <span class=\"regexp\">/^((https?):\\/\\/(\\w+:&#123;0,1&#125;\\w*@)?(\\S+)|)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&amp;%@!\\-\\/]))?$/</span>,</span><br><span class=\"line\">    numbers: <span class=\"regexp\">/^\\d+(\\.\\d&#123;1,2&#125;)?$/</span>,</span><br><span class=\"line\">    digits: <span class=\"regexp\">/[0-9]*$/</span>,</span><br><span class=\"line\">    letters: <span class=\"regexp\">/[a-z][A-Z]*$/</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> messages = &#123;</span><br><span class=\"line\">    required: <span class=\"string\">'This field is required'</span>,</span><br><span class=\"line\">    min: <span class=\"string\">'This field should contain at least %rule% characters'</span>,</span><br><span class=\"line\">    max: <span class=\"string\">'This field should not contain more than %rule% characters'</span>,</span><br><span class=\"line\">    match: <span class=\"string\">'This field shold countain a valid %rule%'</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> Validate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element, options</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> defaults = &#123;</span><br><span class=\"line\">      regExps: regExps,</span><br><span class=\"line\">      messages: messages</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.options = _extend(&#123;&#125;, defaults, options);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.element = element;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.regExps = regExps;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fn = Validate.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">  fn.validate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> isValid = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = <span class=\"keyword\">this</span>.element.value.trim();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.length = <span class=\"keyword\">this</span>.value.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> rule <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.options.rules) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> param = <span class=\"keyword\">this</span>.options.rules[rule];</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>[rule](param)) &#123;</span><br><span class=\"line\">        isValid = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.message = _createMessage(<span class=\"keyword\">this</span>.options.messages[rule], &#123;rule: param, data: <span class=\"keyword\">this</span>.value&#125;);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.options.onError.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isValid) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.options.onSuccess.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  fn.required = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length &gt; <span class=\"number\">0</span>;&#125;;</span><br><span class=\"line\">  fn.min = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length &gt;= param; &#125;;</span><br><span class=\"line\">  fn.max = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length &lt;= param; &#125;;</span><br><span class=\"line\">  fn.match = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.regExps[param].test(<span class=\"keyword\">this</span>.value); &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    init: Validate,</span><br><span class=\"line\">    fn: fn</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>Заметили, каким хитрым образом мы установили объект настроек <code>this.options</code>? Функция <code>_extend</code> широко используется в подобных ситуациях и позволяет переназначить параметры, заданные по умолчанию с помощью объекта настроек.</p>\n<h5 id=\"Что-дальше\"><a href=\"#Что-дальше\" class=\"headerlink\" title=\"Что дальше?\"></a>Что дальше?</h5><p>Написанное нами решение небезопасно и недружелюбно к пользователю. Всё из-за того, что мы не включили ни одной обработки ошибок. Представьте, что будет, если пользователь попробует передать в функцию-конструктор <code>Validate</code> DOM элемент, у которого не будет свойства <code>value</code>. Или что случится, когда пользователь попробует воспользоваться несуществующим сообщением об ошибке или же регулярным выражением? Попробуйте сами предусмотреть подобные ситуации и улучшить библиотеку. Вы также можете посмотреть мои в <a href=\"https://github.com/rtivital/validate\" target=\"_blank\" rel=\"external\">этом репозитории</a>.</p>\n<p>Если вы хотите ещё попрактиковаться на данном примере, то попробуйте написать следующие методы:</p>\n<p>Метод <code>contain</code> проверяет нахождение всех переданных подстрок в проверяемых данных:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> emailValidator = <span class=\"keyword\">new</span> Validator.init(email, &#123;</span><br><span class=\"line\">  rules: &#123;</span><br><span class=\"line\">    contain: [<span class=\"string\">'@'</span>, <span class=\"string\">'.com'</span>, <span class=\"string\">'gmail'</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>Метод <code>only</code> проверяет сотоит ли введённое пользователем значение только из указанных символов:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> phoneValidator = <span class=\"keyword\">new</span> Validator.init(phone, &#123;</span><br><span class=\"line\">  rules: &#123;</span><br><span class=\"line\">    only: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">0</span>, <span class=\"string\">'+'</span>, <span class=\"string\">'-'</span>, <span class=\"string\">'('</span>, <span class=\"string\">')'</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n","excerpt":"<p>В прошлых статьях мы рассмотрели <a href=\"http://jsraccoon.ru/oop-object-base\">основы работы с объектами</a>, <a href=\"http://jsraccoon.ru/oop-constructors\">функции конструкторы</a> и <a href=\"http://jsraccoon.ru/oop-prototypes\">прототипы</a>. А, значит, настало время окончательно во всём разобраться и написать боевой пример — небольшую библиотеку для валидации данных. Полный код библиотеки, которую будем создавать в этой статье, можно найти в <a href=\"https://github.com/rtivital/validate\">этом репозитории</a>. Если же вы хотите в ходе чтения статьи следовать всем инструкциям, то вы можете скачать <a href=\"https://gist.github.com/rtivital/229191009ff742df62bd\">стартовый шаблон</a>.<br>","more":"</p>\n<h5 id=\"Идея\"><a href=\"#Идея\" class=\"headerlink\" title=\"Идея\"></a>Идея</h5><p>Библиотека предназначена для валидации данных из одного поля ввода (тега <code>&lt;input&gt;</code> или <code>&lt;textarea&gt;</code>) и предоставляет несколько простых методов проверки данных. Например, можно проверить правильность введённого email адреса или указать максимальное и минимальное количество символов. Сама по себе, библиотека не даёт огромного функционала, но очень проста в расширении, предлагая пользователю самому дописать необходимые ему методы для валидации данных. В комплекте с библиотекой идёт простой строковый шаблонизатор, который поможет выводить понятные сообщения об ошибках.</p>\n<h5 id=\"Параметры\"><a href=\"#Параметры\" class=\"headerlink\" title=\"Параметры\"></a>Параметры</h5><p>Необходимо всегда точно осознавать, что будет делать созданная вами функция-конструктор перед тем, как вы начнёте писать код. Поэтому, для начала, попробуем описать, что будет делать валидатор данных. Мы уже знаем, что нам обязательно нужно передавать DOM элемент (<code>&lt;input&gt;</code> или <code>&lt;textarea&gt;</code>), но помимо этого нам также необходимо узнать правила валидации, шаблоны сообщений об ошибках и <code>callback</code> функции, которые будут срабатывать при успешном или, наоборот, неуспешном завершении валидации. Очевидно, что параметров достаточно много и передавать их в функцию по одному будет крайне неудобно. Как раз для таких целей и существуют объекты. Используя объект, мы можем удобно сгруппировать все передаваемые в функцию данные. Таким образом, все параметры, которые нужно предоставить функции-конструктору: DOM элемент и объект настроек.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> email = <span class=\"built_in\">document</span>.getElementbyId(<span class=\"string\">'email'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> emailValidation = <span class=\"keyword\">new</span> Validator(email, &#123; <span class=\"comment\">/* объект настроек */</span> &#125;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Объект-настроек\"><a href=\"#Объект-настроек\" class=\"headerlink\" title=\"Объект настроек\"></a>Объект настроек</h5><p>Итак, у нас уже есть поле ввода, данные из которого будут проверяться, но этого же недостаточно. По крайней мере, нужно указать правила, в соответствие с которыми будет проводиться валидация. Для этого создадим свойство <code>rules</code> в объекте настроек, которое будет содержать все правила:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> settings = &#123;</span><br><span class=\"line\">  rules: &#123;</span><br><span class=\"line\">    min: <span class=\"number\">8</span>,</span><br><span class=\"line\">    max: <span class=\"number\">50</span>,</span><br><span class=\"line\">    match: <span class=\"string\">'email'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Данная конфигурация скажет функции-конструктору, что поле ввода должно содержать валидный адрес электронной почты, длина которого не меньше 8 и не больше 50 символов.</p>\n<p>К каждому правилу должно прилагаться сообщение об ошибке, которое будет использовано, когда валидация данных будет провалена. Поэтому создадим ещё одно свойство объекта <code>settings</code>, которое будет содержать все сообщения об ошибках.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> settings = &#123;</span><br><span class=\"line\">  rules: &#123; <span class=\"comment\">/* ... */</span> &#125;,</span><br><span class=\"line\">  messages: &#123;</span><br><span class=\"line\">    min: <span class=\"string\">'Поле должно содержать больше 8 символов'</span>,</span><br><span class=\"line\">    max: <span class=\"string\">'Поле не должно содержать больше 50 символов'</span>,</span><br><span class=\"line\">    match: <span class=\"string\">'Поле должно содержать валидный адрес электронной почты'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Теперь остался последний, но самый важный шаг для завершения конфигурации — <code>callback</code> функции. Для наглядности назовём их <code>onError</code> и <code>onSuccess</code>. Данные функции, передаваемые с объектом настроек, будут срабатывать при завершении валидации в зависимости от её результата. Они могут содержать всё что угодно, но пока для простоты будем просто выводить в консоль сообщения.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> settings = &#123;</span><br><span class=\"line\">  rules: &#123; <span class=\"comment\">/* ... */</span> &#125;,</span><br><span class=\"line\">  messages: &#123; <span class=\"comment\">/* ... */</span> &#125;,</span><br><span class=\"line\">  onError: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'Валидация провалена'</span>); &#125;,</span><br><span class=\"line\">  onSuccess: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'Валидация прошла успешно'</span>); &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Итак, основа нашего объекта настроек готова, и мы уже определились со всеми параметрами, передаваемыми в функцию, а, значит, половина работы мы уже сделали.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> settings = &#123;</span><br><span class=\"line\">  rules: &#123;</span><br><span class=\"line\">    min: <span class=\"number\">8</span>,</span><br><span class=\"line\">    max: <span class=\"number\">50</span>,</span><br><span class=\"line\">    match: <span class=\"string\">'email'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  messages: &#123;</span><br><span class=\"line\">    min: <span class=\"string\">'Поле должно содержать больше 8 символов'</span>,</span><br><span class=\"line\">    max: <span class=\"string\">'Поле не должно содержать больше 50 символов'</span>,</span><br><span class=\"line\">    match: <span class=\"string\">'Поле должно содержать валидный адрес электронной почты'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  onError: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'Валидация провалена'</span>); &#125;,</span><br><span class=\"line\">  onSuccess: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'Валидация прошла успешно'</span>); &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> email = <span class=\"built_in\">document</span>.getElementbyId(<span class=\"string\">'email'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> emailValidation = <span class=\"keyword\">new</span> Validator(email, settings);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Паттерн-“Модуль”\"><a href=\"#Паттерн-“Модуль”\" class=\"headerlink\" title=\"Паттерн “Модуль”\"></a>Паттерн “Модуль”</h5><p>При создании библиотеки мы не хотим, чтобы все наши “внутренние” переменные попали в чужие руки (кто знает, что задумали другие разработчики-злодеи). Может возникнуть конфликт имён и любую переменную из нашей библиотеки сможет перезаписать сторонний код. Чтобы этого не произошло, необходимо ограничить доступ. Удобнее всего это сделать с помощью <a href=\"http://forwebdev.ru/javascript/module-pattern/\">паттерна “Модуль”</a>. Всё, что для этого нужно, — обвернуть весь наш код в немедленно вызываемую анонимную функцию и записать результат её выполнения в переменную, которая и будет использоваться другими разработчиками.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Validator = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;)();</span><br></pre></td></tr></table></figure></p>\n<p>Таким образом, мы создали новую область видимости. Всё, что находится внутри неё, не будет доступно для записи и чтения, если мы сами не запишем данные, как свойство объекта <code>window</code>, или не вернём значение — в этом случае то, что возвращает функция будет записано в переменную <code>Validator</code>. Создадим функцию-конструктор и экспортируем её из модуля:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Validator = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  'use strict'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> Validate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element, options</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.element = element;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.options = options;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> Validate;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></p>\n<p>Теперь у нас есть возможность использовать функцию <code>Validate</code> вне модуля, так как она была записана в переменную <code>Validator</code>.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> emailValidation = <span class=\"keyword\">new</span> Validator(<span class=\"string\">'element'</span>, <span class=\"string\">'options'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(emailValidation); <span class=\"comment\">// &#123; element: \"element\", options: \"options\" &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>Как я уже писал выше, мы также можем записать любые данные, как свойство объекта <code>window</code>. При подобной подходе у нас уже не возникает необходимости возвращать что-либо из модуля. Поэтому и результат выполнения записывать в переменную нет необходимости.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  'use strict'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> Validate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element, options</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.element = element;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.options = options;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">window</span>.Validator = Validate;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Запись-свойств\"><a href=\"#Запись-свойств\" class=\"headerlink\" title=\"Запись свойств\"></a>Запись свойств</h5><p>Мы уже приступили к созданию функции-конструктора <code>Validate</code> и записали два свойства: <code>element</code> и <code>options</code>. Этого вполне достаточно, но было бы удобно обращаться к некоторым свойствам напрямую, например, писать каждый раз не <code>this.options.rules</code>, а просто <code>this.rules</code>. Поэтому создадим ещё несколько свойств для удобства:</p>\n<ul>\n<li><code>value</code> для обращения к введенным в поле ввода данным</li>\n<li><code>length</code> — количество символов в полученном <code>value</code></li>\n<li><code>rules</code> — объект, содержащий все правила</li>\n<li>и <code>messages</code> — объект со всеми сообщениями</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Validate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.element = element;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.options = options;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.value = <span class=\"keyword\">this</span>.element.value.trim();</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.length = <span class=\"keyword\">this</span>.value.length;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.rules = <span class=\"keyword\">this</span>.options.rules;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.mesages = <span class=\"keyword\">this</span>.options.messages;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"Методы\"><a href=\"#Методы\" class=\"headerlink\" title=\"Методы\"></a>Методы</h5><p>В начале статьи я писал, что библиотека достаточно минималистична и не располагает огромным количеством методов. Поэтому ограничимся самым минимальным набором:</p>\n<ul>\n<li><code>required</code> — проверка наличия хотя бы одного непробельного символа</li>\n<li><code>min</code> — минимальное количество символов</li>\n<li><code>max</code> — максимальное количество символов</li>\n<li><code>match</code> — проверка соответствия какому-либо паттерну</li>\n</ul>\n<h5 id=\"required\"><a href=\"#required\" class=\"headerlink\" title=\"required\"></a>required</h5><p>Всё, что необходимо сделать в методе — сравнить длину значения <code>this.length</code> с нулём. Таким, образом мы убедимся, что был введён хотя бы один непробельный символ:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Validate.prototype.required = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"min-и-max\"><a href=\"#min-и-max\" class=\"headerlink\" title=\"min и max\"></a>min и max</h5><p>Методы <code>min</code> и <code>max</code> практически повторяют метод <code>required</code>, но также принимают параметр, с которым будут сравнивать длину полученного значения <code>this.length</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Validate.prototype.min = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length &gt;= param;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Validate.prototype.max = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length &lt;= param;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h5><p>Метод <code>match</code> работает с регулярными выражениями. Для простоты создадим объект, который будет содержать все наши регулярные выражения. Положим его в переменную <code>regExps</code> и объявим её вне метода.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> regExps = &#123;</span><br><span class=\"line\">  email: <span class=\"regexp\">/^([\\w-]+(?:\\.[\\w-]+)*)@((?:[\\w-]+\\.)*\\w[\\w-]&#123;0,66&#125;)\\.([a-z]&#123;2,6&#125;(?:\\.[a-z]&#123;2&#125;)?)$/i</span>,</span><br><span class=\"line\">  url: <span class=\"regexp\">/^((https?):\\/\\/(\\w+:&#123;0,1&#125;\\w*@)?(\\S+)|)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&amp;%@!\\-\\/]))?$/</span>,</span><br><span class=\"line\">  numbers: <span class=\"regexp\">/^\\d+(\\.\\d&#123;1,2&#125;)?$/</span>,</span><br><span class=\"line\">  digits: <span class=\"regexp\">/[0-9]*$/</span>,</span><br><span class=\"line\">  letters: <span class=\"regexp\">/[a-z][A-Z]*$/</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Validate.prototype.match = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Теперь мы сможем получить к ним доступ внутри метода <code>match</code>. В будущем нам ещё понадобится этот объект, так что поместить его вне метода <code>match</code> — хорошая идея.<br>Чтобы проверить соответствие значения <code>this.value</code> регулярному выражению нужно воспользоваться методом <code>test</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Validate.prototype.match = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// выбираем регулярное выражение</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> re = regExps[param];</span><br><span class=\"line\">  <span class=\"comment\">// Тестируем</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> re.test(<span class=\"keyword\">this</span>.value);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Кратко</span></span><br><span class=\"line\">Validate.prototype.match = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> regExps[param].test(<span class=\"keyword\">this</span>.value);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Всё-вместе\"><a href=\"#Всё-вместе\" class=\"headerlink\" title=\"Всё вместе\"></a>Всё вместе</h5><p>Итак, мы написали 4 метода для валидации данных:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Validate.prototype.required = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Validate.prototype.min = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length &gt;= param;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Validate.prototype.max = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length &lt;= param;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Validate.prototype.match = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> regExps[param].test(<span class=\"keyword\">this</span>.value);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Для их создания нам каждый раз приходилось обращаться к прототипу функции-конструктора <code>Validate</code>. Запись <code>Validate.prototype</code> достаточно громоздкая. Чтобы каждый раз не использовать её можно создать переменную, которая будет ссылаться на прототип. Так как любой прототип является не более чем простым объектом, мы можем смело задавать подобные переменные:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fn = Validate.prototype;</span><br><span class=\"line\">fn.required = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length &gt; <span class=\"number\">0</span>; &#125;;</span><br><span class=\"line\">fn.min = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length &gt;= param; &#125;;</span><br><span class=\"line\">fn.max = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length &lt;= param; &#125;;</span><br><span class=\"line\">fn.match = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123; <span class=\"keyword\">return</span> regExps[param].test(<span class=\"keyword\">this</span>.value); &#125;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Валидация\"><a href=\"#Валидация\" class=\"headerlink\" title=\"Валидация\"></a>Валидация</h5><p>Сами по себе написанные нами ранее методы бесполезны. Они ничего не умеют, кроме проверки данных. То есть для создания сообщений, группировки этих методов и вызова <code>callback</code> функций они не подходят. Поэтому создадим ещё один метод <code>validate</code>, который будет отвечать за обработку всего выше перечисленного.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn.validate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Первое, что нужно сделать — перезаписать значение для <code>this.value</code> и <code>this.length</code>. При каждом запуске метода <code>validate</code> мы хотим получать новые данные из поля ввода и только потом проверять их.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn.validate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.value = <span class=\"keyword\">this</span>.element.value.trim();</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.length = <span class=\"keyword\">this</span>.value.length;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Теперь у нас есть самые “свежие” данные и мы можем их использовать для проверки соответствия правилам, которые записаны в объекте <code>this.rules</code>. Свойства объекта <code>this.rules</code> соответствуют написанным нами ранее методам. Удобнее всего правила перебрать с помощью цикла <code>for .. in</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Пример объекта правил</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   min: 8,</span></span><br><span class=\"line\"><span class=\"comment\">//   max: 50,</span></span><br><span class=\"line\"><span class=\"comment\">//   match: 'email'</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">fn.validate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.value = <span class=\"keyword\">this</span>.element.value.trim();</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.length = <span class=\"keyword\">this</span>.value.length;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> rule <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.rules) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> param = <span class=\"keyword\">this</span>.rules[rule];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Итак, мы написали цикл, с помощью которого мы переберём все передаваемые в функцию правила. При каждой итерации внутри цикла у нас будет доступ к имени текущего правила, например, <code>min</code>, а также к параметру правила, например <code>8</code> для правила <code>min</code>. Всё, что нам остаётся сделать, — последовательно применить созданные нам ранее методы.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn.validate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> rule <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.rules) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> param = <span class=\"keyword\">this</span>.rules[rule];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"keyword\">this</span>[rule](param);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Переменная <code>result</code> всегда содержит значение типа <code>boolean</code>, с помощью которого мы можем сказать соответствует ли наше <code>this.value</code> требованиям, описанным в правилах. Если мы узнали, что значение не соответствует какому-либо правилу, то мы сразу же прерываем выполнение цикла и вызываем <code>callback</code> функцию <code>onError</code>. Если же значение прошло проверки на все заданные правила, то нужно вызвать функцию <code>onSuccess</code>. Перед циклом объявим переменную <code>isValid</code>, которая будет сигнализировать о состоянии валидации.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn.validate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// Изначально считаем, что все правила пройдены</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> isValid = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> rule <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.rules) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> param = <span class=\"keyword\">this</span>.rules[rule];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"keyword\">this</span>[rule](param);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Если вылидация провалилась, то выставляем значение false</span></span><br><span class=\"line\">      isValid = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"comment\">// Вызываем функцию onError</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.options.onError.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      <span class=\"comment\">// И прерываем выполнение цикла</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// После завершения цикла проверяем isValid</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isValid) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Если всё хорошо, то вызываем функцию onSuccess</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.options.onSuccess.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Пишем-сообщения\"><a href=\"#Пишем-сообщения\" class=\"headerlink\" title=\"Пишем сообщения\"></a>Пишем сообщения</h5><p>Написанный нами метод <code>validate</code> уже сейчас достаточно хорошо. Он умеет проверять соответствие данных всем переданным правилам и вызывать функции в зависимости от результата проверки. Но мы также хотим передавать содержательные сообщения о полученных ошибках. В этом нам поможет простая функция для строковой шаблонизации. Допустим, что на выходе мы хотим получить сообщение, которое будет содержать введённые пользователем данные, а также параметр из наших правил. Чтобы получить подобную конструкцию мы можем составить строку:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> rules = &#123;</span><br><span class=\"line\">  min: <span class=\"number\">8</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> messages = &#123;</span><br><span class=\"line\">  min: <span class=\"string\">'Значение должно быть не менее %rule% символов. Значение \"%data%\" не подходит.'</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>В полученной строке необходимо заменить <code>%rule%</code> на параметр (в данном случае 8), а <code>%data%</code> на значение, полученное от пользователя. Таким образом, со всеми заменами строка будет выглядеть следующим образом: <code>&#39;Значение должно быть не менее 8 символов. Значение &quot;банан&quot; не подходит.&#39;</code></p>\n<p>Реализовать подобную шаблонизацию достаточно просто с помощью метода строк <code>replace</code>. Чтобы не забивать наш метод <code>validate</code> большим количеством кода, создадим для этого отдельную функцию <code>createMessage</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> createMessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str, rule, data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str.replace(<span class=\"string\">'%rule%'</span>, rule).replace(<span class=\"string\">'%data%'</span>, data);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Сразу же опробуем функцию</span></span><br><span class=\"line\">createMessage(<span class=\"string\">'Данные: %data%, Правило: %rule%'</span>,<span class=\"string\">'желтый'</span>, <span class=\"string\">'банан'</span>);</span><br><span class=\"line\"><span class=\"comment\">// Данные: банан, Правило: желтый</span></span><br></pre></td></tr></table></figure></p>\n<p>Функция работает. Но работает только для наших конкретных переменных. Если в будущем мы захотим передавать и другие значения, то у нас ничего не получится. Чтобы это исправить будем передавать в функцию не отдельные параметры, а объект, содержащий все значения, которые нужно заменить.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> createMessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str, settings</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> settings) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(key, settings[key])</span><br><span class=\"line\">    str = str.replace(<span class=\"string\">'%'</span> + key + <span class=\"string\">'%'</span>, settings[key]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Сразу же опробуем функцию</span></span><br><span class=\"line\">createMessage(<span class=\"string\">'Данные: %data%, Правило: %rule%'</span>, &#123;</span><br><span class=\"line\">  data: <span class=\"string\">'Банан'</span>,</span><br><span class=\"line\">  rule: <span class=\"string\">'Жёлтый'</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// Данные: банан, Правило: желтый</span></span><br></pre></td></tr></table></figure></p>\n<p>Теперь функция принимает неограниченное число значений для замены и не зависит от порядка следования этих значений в объекте. Добавим эту функцию в наш модуль и будем использовать в методе <code>validate</code>.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn.validate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// Изначально считаем, что все правила пройдены</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> isValid = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> rule <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.rules) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> param = <span class=\"keyword\">this</span>.rules[rule];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"keyword\">this</span>[rule](param);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">      isValid = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"comment\">// Получаем шаблон сообщения из переданного пользователем объекта messages</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> messageTemplate = <span class=\"keyword\">this</span>.messages[rule];</span><br><span class=\"line\">      <span class=\"comment\">// Создаем сообщение с параметрами data и rule</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.message = createMessage(message, &#123;</span><br><span class=\"line\">        data: <span class=\"keyword\">this</span>.value,</span><br><span class=\"line\">        rule: param</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.options.onError.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isValid) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.options.onSuccess.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Теперь у нас есть сообщение. Но как его можно будет использовать? Как вы, наверное, уже заметили, мы вызываем функции <code>onError</code> и <code>onSuccess</code> с помощью метода <code>call</code>, с помощью которого можно задавать значение <code>this</code> для функций. Другими словами, первый аргумент, передаваемый в метод <code>call</code> будет использован функцией, как <code>this</code>. Таким образом, мы получим возможность использовать все свойства и методы внутри функций.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> onError = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Ошибка: '</span> + <span class=\"keyword\">this</span>.message);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Обращение-к-прототипу\"><a href=\"#Обращение-к-прототипу\" class=\"headerlink\" title=\"Обращение к прототипу\"></a>Обращение к прототипу</h5><p>Чтобы обеспечить удобство создания методов в нашей библиотеке, мы можем экспортировать из нашего модуля не только ссылку на функцию конструктор, но и на её прототип.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Validator = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> Validate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> fn = Validate.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    init: Validate,</span><br><span class=\"line\">    fn: fn</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></p>\n<p>Теперь для создания новой валидации нам придется использовать следующую конструкцию:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> emailValidation = <span class=\"keyword\">new</span> Validator.init(<span class=\"comment\">/* опции */</span>);</span><br></pre></td></tr></table></figure></p>\n<p>Стало немного сложнее, но подобное решение позволяет создавать новые методы для конструктора <code>Validate</code>, обращаясь к его прототипу.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vaidator.fn.password = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.value === <span class=\"string\">'1234qwerty'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> passwordValidation = <span class=\"keyword\">new</span> Validator.init(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'password'</span>), &#123;</span><br><span class=\"line\">  rules: &#123;</span><br><span class=\"line\">    password: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  messages: &#123;</span><br><span class=\"line\">    password: <span class=\"string\">'Пароль %data% неверный'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Код-библиотеки-целиком\"><a href=\"#Код-библиотеки-целиком\" class=\"headerlink\" title=\"Код библиотеки целиком\"></a>Код библиотеки целиком</h5><p>Вы можете посмотреть результат применения библиотеки на <a href=\"http://codepen.io/rtivital/pen/JGwaoV\">codepen</a> или <a href=\"https://gist.github.com/rtivital/d5499b4b6c8377d79dd2/archive/4484ac046d7daba0adb1caa80632bc39f9305689.zip\">скачать работающий пример</a>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Validator = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  'use strict'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> _createMessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">message, settings</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> settings) &#123;</span><br><span class=\"line\">      message = message.replace(<span class=\"string\">'%'</span> + key + <span class=\"string\">'%'</span>, settings[key]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// http://youmightnotneedjquery.com/#deep_extend</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> _extend = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">out</span>) </span>&#123;</span><br><span class=\"line\">    out = out || &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">arguments</span>.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> obj = <span class=\"built_in\">arguments</span>[i];</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!obj)</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> obj[key] === <span class=\"string\">'object'</span>)</span><br><span class=\"line\">            out[key] = _extend(out[key], obj[key]);</span><br><span class=\"line\">          <span class=\"keyword\">else</span></span><br><span class=\"line\">            out[key] = obj[key];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> out;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> regExps = &#123;</span><br><span class=\"line\">    email: <span class=\"regexp\">/^([\\w-]+(?:\\.[\\w-]+)*)@((?:[\\w-]+\\.)*\\w[\\w-]&#123;0,66&#125;)\\.([a-z]&#123;2,6&#125;(?:\\.[a-z]&#123;2&#125;)?)$/i</span>,</span><br><span class=\"line\">    url: <span class=\"regexp\">/^((https?):\\/\\/(\\w+:&#123;0,1&#125;\\w*@)?(\\S+)|)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&amp;%@!\\-\\/]))?$/</span>,</span><br><span class=\"line\">    numbers: <span class=\"regexp\">/^\\d+(\\.\\d&#123;1,2&#125;)?$/</span>,</span><br><span class=\"line\">    digits: <span class=\"regexp\">/[0-9]*$/</span>,</span><br><span class=\"line\">    letters: <span class=\"regexp\">/[a-z][A-Z]*$/</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> messages = &#123;</span><br><span class=\"line\">    required: <span class=\"string\">'This field is required'</span>,</span><br><span class=\"line\">    min: <span class=\"string\">'This field should contain at least %rule% characters'</span>,</span><br><span class=\"line\">    max: <span class=\"string\">'This field should not contain more than %rule% characters'</span>,</span><br><span class=\"line\">    match: <span class=\"string\">'This field shold countain a valid %rule%'</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> Validate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element, options</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> defaults = &#123;</span><br><span class=\"line\">      regExps: regExps,</span><br><span class=\"line\">      messages: messages</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.options = _extend(&#123;&#125;, defaults, options);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.element = element;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.regExps = regExps;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fn = Validate.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">  fn.validate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> isValid = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = <span class=\"keyword\">this</span>.element.value.trim();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.length = <span class=\"keyword\">this</span>.value.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> rule <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.options.rules) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> param = <span class=\"keyword\">this</span>.options.rules[rule];</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>[rule](param)) &#123;</span><br><span class=\"line\">        isValid = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.message = _createMessage(<span class=\"keyword\">this</span>.options.messages[rule], &#123;rule: param, data: <span class=\"keyword\">this</span>.value&#125;);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.options.onError.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isValid) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.options.onSuccess.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  fn.required = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length &gt; <span class=\"number\">0</span>;&#125;;</span><br><span class=\"line\">  fn.min = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length &gt;= param; &#125;;</span><br><span class=\"line\">  fn.max = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.length &lt;= param; &#125;;</span><br><span class=\"line\">  fn.match = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.regExps[param].test(<span class=\"keyword\">this</span>.value); &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    init: Validate,</span><br><span class=\"line\">    fn: fn</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>Заметили, каким хитрым образом мы установили объект настроек <code>this.options</code>? Функция <code>_extend</code> широко используется в подобных ситуациях и позволяет переназначить параметры, заданные по умолчанию с помощью объекта настроек.</p>\n<h5 id=\"Что-дальше\"><a href=\"#Что-дальше\" class=\"headerlink\" title=\"Что дальше?\"></a>Что дальше?</h5><p>Написанное нами решение небезопасно и недружелюбно к пользователю. Всё из-за того, что мы не включили ни одной обработки ошибок. Представьте, что будет, если пользователь попробует передать в функцию-конструктор <code>Validate</code> DOM элемент, у которого не будет свойства <code>value</code>. Или что случится, когда пользователь попробует воспользоваться несуществующим сообщением об ошибке или же регулярным выражением? Попробуйте сами предусмотреть подобные ситуации и улучшить библиотеку. Вы также можете посмотреть мои в <a href=\"https://github.com/rtivital/validate\">этом репозитории</a>.</p>\n<p>Если вы хотите ещё попрактиковаться на данном примере, то попробуйте написать следующие методы:</p>\n<p>Метод <code>contain</code> проверяет нахождение всех переданных подстрок в проверяемых данных:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> emailValidator = <span class=\"keyword\">new</span> Validator.init(email, &#123;</span><br><span class=\"line\">  rules: &#123;</span><br><span class=\"line\">    contain: [<span class=\"string\">'@'</span>, <span class=\"string\">'.com'</span>, <span class=\"string\">'gmail'</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>Метод <code>only</code> проверяет сотоит ли введённое пользователем значение только из указанных символов:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> phoneValidator = <span class=\"keyword\">new</span> Validator.init(phone, &#123;</span><br><span class=\"line\">  rules: &#123;</span><br><span class=\"line\">    only: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">0</span>, <span class=\"string\">'+'</span>, <span class=\"string\">'-'</span>, <span class=\"string\">'('</span>, <span class=\"string\">')'</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>"},{"title":"Объектно-ориентированный JavaScript: примитивы и объекты","author":"rtivital","date":"2016-04-24T00:00:00.000Z","_content":"\nСкорее всего, вы читали или слышали, что всё в JavaScript является объектом. Ещё чаще можно увидеть опровержения этого утверждения. Подобные споры возникают регулярно и обусловлены в большей степени недопониманием концепций JavaScript. И, на самом деле, причина считать примитивы объектами есть — у примитивов можно запрашивать свойства и методы, поведение которых во многом схоже со свойствами и методами объектов.<!--MORE--> Например, строки и массивы содержат одинаковые свойство `length`:\n```javascript\nconst arr = ['this', 'is', 'an', 'array'];\nconst str = 'this is string';\nconsole.log(arr.length); // 4\nconsole.log(str.length); // 14\n```\n\nНа первый взгляд, может показаться, что свойство `length` работает одинаково для строк и массивов. Тем не менее, разница есть. Чтобы понять в чём она заключается достаточно использовать оператор `typeof` для каждого типа данных:\n```javascript\ntypeof str; // \"string\"\ntypeof arr; // \"object\"\n```\n\nИ что? Это не отменяет того, что мы можем использовать полноценные методы и свойства у примитивов. Всё верно. Но следует учитывать то, что происходит \"за сценой\". У каждого примитивного типа данных есть своя функция конструктор, например, для строк — `String`, для чисел — `Number`. Когда вы хотите получить какое-либо свойство или метод для примитивов, вы обращаетесь не к самому примитиву, а к объекту, созданному функцией-конструктором данного примитива. Другими словами, **примитивы не имеют свойств и методов и не являются объектами**. Чтобы разобраться в том, что происходит \"за сценой\", можно инициализировать создание новой строки с помощью функции конструктора `String`:\n```javascript\nconst str = new String('Hello, World!');\ntypeof str; // \"object\"\n```\n\nПодобное обращение к конструктору `String` происходит каждый раз, когда вы запрашиваете у строки свойство или метод. Создаётся новый объект с помощью функции конструктора, выполняется определённое действие (получение свойства или выполнение метода), а затем созданный ранее объект уничтожается, оставляя после себя только результат. Представить для себя подобное выполнение кода можно следующим образом:\n```javascript\n// Получение свойства length строки\nlet length = 'this is string'.length;\n// За сценой\n// После получения значения созданный объект уничтожится\nlet length = (new String('this is string')).length;\n```\n\nПочему важно понимать, что не всё в JavaScript является объектом? Всё просто. Для любого объекта можно задать значение свойства вручную. Например, то же свойство `length` для массивов и строк:\n```javascript\n// Присваивание значение свойтву length у объектов\nconst arr = ['this', 'is', 'an', 'array'];\narr.length = 10;\n\n// Присваивание значение свойтву length у примитивов\nconst str = 'this is string';\nstr.length = 10;\n\narr.length; // 10 (свойство установлено)\nstr.length; // 14 (свойство не установлено)\n```\n\nПочему свойство `length` у строки не изменилось? Когда вы пытаетесь установить свойство у любого примитива, то происходит следующее:\n\n1. Создаётся новый **объект**: `new String('this is string')`\n2. У **нового** объекта устанавливается свойство `length` со значением `10`\n3. Созданный объект уничтожается\n\nВ результате подобной схемы становится очевидно, что данные, находящиеся в исходной переменной не изменяются, а все изменения происходят с новым объектом, который в будущем будет просто уничтожен.\n\nТо же самое произойдёт и в случае, если вы захотите присвоить новое свойство или метод примитиву:\n```javascript\nconst str = 'str';\nstr.newProp = 'my new property';\nstr.newMethod = function() {\n  return 'my new method';\n};\n\nstr.newProp; // undefined\nstr.newMethod(); // Uncaught TypeError: str.newMethod is not a function\n```\n\nСхема работы такая же, как и в прошлом примере:\n\n1. Создаётся новый **объект**: `new String('str')`, которому присваивается свойство `newProp` со значением `'my new property'`\n2. Созданный объект уничтожается\n3. Создаётся **ещё один** новый объект `new String('str')`, которому присваивается метод `newMethod`\n4. Объект уничтожается\n5. Мы пытаемся получить значение несуществующего свойства `newProp`, в результате чего получаем `undefined`\n6. Мы пытаемся выполнить несуществующий метод `newMethod`, что эквивалентно `undefined()`, и получаем ошибку\n\n##### Примитивные данные\n\nВ JavaScript все примитивные данные разделяются на 6 типов:\n\n1. строки: `'str'`, `\"str\"`, ``  `str` ``\n2. числа: `2`, `0`, `100.34`\n3. boolean: `true` и `false`\n4. `undefined`\n5. `null`\n6. символы `Symbol()`\n\nУ строк, чисел и boolean есть функции конструкторы, с помощью, которых можно их инициализировать:\n```javascript\nconst str = new String('str');\nconst num = new Number(20);\nconst bool = new Boolean(true);\n```\n\nНо несмотря на то, что у вас есть возможность создавать примитивы с помощью функций конструкторов, делать это в реальных проетках не надо ни при каких обстоятельствах. **Всегда используйте литералы для создания примитивов** (за исключением символов, так как для них не предусмотрено формы литерала, их нужно создавать при помощи функции `Symbol()`). Почему не стоит создавать примитивы с помощью функций конструкторов? Всё, что вам нужно запомнить — при подобном создании примитива вы не получаете само значение, а только его объект-обвертку. В некоторых ситуациях подобное поведение может быть опасным и привести к проблемам. Например, при создании значения типа `boolean` через конструктор:\n```javascript\nconst val = new Boolean(false);\nif (val) { console.log('Hello, World!'); }\n```\n\nВ результате выполнения данного кода в консоль выведется сообщение. Код внутри конструкции `if` выполняется, так как значение находящееся в переменной `val` является объектом с содержимым `{[[PrimitiveValue]]: false}`, а любой объект, даже пустой, в JavaScript является правдивым значением.\n\nВы можете использовать функции `String`, `Number` и `Boolean` без ключевого слова `new`. При подобном использовании всё, что они будут делать — приводить типы. Несколько примеров:\n```javascript\n// Приведение строки к числу\nlet num = Number('20');\ntypeof num; // \"number\"\n\n// Приведение числа к строке\nlet str = String(20);\ntypeof str; // \"string\"\n\n// Приведение любого значения к типу boolean\nlet bool1 = Boolean('str'); // true\nlet bool2 = Boolean(0); // false\n\ntypeof bool1; // \"boolean\"\ntypeof bool2; // \"boolean\"\n```\n\nИногда подобные решения бывают полезными и позволяют сократить объем необходимого кода, например, если нужно отфильтровать все ложные значения из массива, то можно воспользовать функцией `Boolean`:\n```javascript\nconst falsyArr = ['', 0, null, 10, 'string', undefined, true, {a: 1}, false];\nconst truthyArr = falsyArr.filter(Boolean);\n\n// Аналогично\nconst truthyArr = falsyArr.filter(function (item) {\n  return !!item;\n});\n\n// С использование стрелочных функций из ES6\nconst truthyArr = falsyArr.filter(item => !!item);\n```\n\n##### null является объектом?\nЕсли вы попробуете использовать оператор `typeof` для всех примитивов, то, в целом, вы не обнаружите ничего нового для себя:\n```javascript\ntypeof 'str';     // \"string\"\ntypeof 100;       // \"number\"\ntypeof true;      // \"boolean\"\ntypeof undefined; // \"undefined\"\ntypeof Symbol();  // \"symbol\"\n```\n\nВсё складывается хорошо, до тех пор, пока вы не опробуете данный оператор на `null`\n```javascript\ntypeof null; // \"object\"\n```\n\nЕсли вы подумали, что что-то тут неправильно и нелогично, то вы абсолютно правы. Подобное поведение является не более, чем багом языка. Но за столько лет можно же было бы это исправить? Конечно, можно, но следует понимать, что подобное поведение `typeof null` используется практически в каждом приложении или библиотеке. Таким образом, исправить подобный баг невозможно, так как это сломает весь существующий на данный момент JavaScript код. Ввести подобное нововведение в новый стандарт ECMAScript тоже не получится, так как будет потеряна обратная совместимость.\n\nИтого, `null` не является объектом, несмотря на то, что оператор `typeof` утверждает обратное. Это значит, что в `null` не могут быть записаны никакие свойства или методы, то есть действуют все правила примитивов.\n\n##### Объекты\nВыше были перечислены все типы данных, которые являются притивами. Всё остальное в JavaScript является объектом: массивы, функции, сами объекты. Любому объекту можно присвоить свойства и методы. Например, для любой функции:\n```javascript\nconst log = function(message) { console.log(log.messages); };\nlog.messages = ['first', 'second', 'third'];\nlog(); // [\"first\",\"second\",\"third\"]\n```\n\nВ данном примере к свойству `messages` функции `log` можно обратиться сразу при её инициализации. Разумеется, подобным образом можно записывать и методы:\n```javascript\nconst log = function(message) { console.log(log.transform()); };\nlog.messages = ['first', 'second', 'third'];\nlog.transform = function () {\n  return log.messages.map(function(message) {\n    return message + ' message';\n  });\n};\nlog(); // [\"first message\",\"second message\",\"third message\"]\n```\n\nПодобным образом можно присвоить свойства и методы любому другому объекту. Но всегда стоит понимать, зачем вы это делаете и как это работает. Если раздавать методы и свойства всем видам объектов подряд, то, скорее всего, вы очень быстро заметите странное поведение. Например, если задать свойство `newProp` у массива, то вы обнаружите, что в результате выполнения любого перебирающего метода (например, `forEach`) с именнованным свойством `newProp` не была вызвана `callback` функция, а также оно не влияет на длину самого массива:\n```javascript\nconst arr = [1, 2, 3, 4, 5];\nconsole.log(arr.length); // 5\n\narr.newProp = 'awesome property';\nconsole.log(arr.length); // 5\n\n// свойство newProp не выводится в консоль\narr.forEach(function(num) {\n  console.log(num); // 1 2 3 4 5\n});\n```\n\n##### Итого\nВсе типы данных в JavaScript разделяются на примитивы и объекты. Примитивы не могут иметь собственных свойств и методов, объекты могут. Утверждение, что всё в JavaScript является объектом неверное. Более правильно говорить, что **всё в JavaScript ведёт себя, как объект, но необязательно им является**.\n","source":"_posts/oop-objects-vs-primitives.md","raw":"---\ntitle: \"Объектно-ориентированный JavaScript: примитивы и объекты\"\nauthor: rtivital\ndate: \"2016-04-24\"\ncategories: Статья\ntags: [OOP, JavaScript]\n---\n\nСкорее всего, вы читали или слышали, что всё в JavaScript является объектом. Ещё чаще можно увидеть опровержения этого утверждения. Подобные споры возникают регулярно и обусловлены в большей степени недопониманием концепций JavaScript. И, на самом деле, причина считать примитивы объектами есть — у примитивов можно запрашивать свойства и методы, поведение которых во многом схоже со свойствами и методами объектов.<!--MORE--> Например, строки и массивы содержат одинаковые свойство `length`:\n```javascript\nconst arr = ['this', 'is', 'an', 'array'];\nconst str = 'this is string';\nconsole.log(arr.length); // 4\nconsole.log(str.length); // 14\n```\n\nНа первый взгляд, может показаться, что свойство `length` работает одинаково для строк и массивов. Тем не менее, разница есть. Чтобы понять в чём она заключается достаточно использовать оператор `typeof` для каждого типа данных:\n```javascript\ntypeof str; // \"string\"\ntypeof arr; // \"object\"\n```\n\nИ что? Это не отменяет того, что мы можем использовать полноценные методы и свойства у примитивов. Всё верно. Но следует учитывать то, что происходит \"за сценой\". У каждого примитивного типа данных есть своя функция конструктор, например, для строк — `String`, для чисел — `Number`. Когда вы хотите получить какое-либо свойство или метод для примитивов, вы обращаетесь не к самому примитиву, а к объекту, созданному функцией-конструктором данного примитива. Другими словами, **примитивы не имеют свойств и методов и не являются объектами**. Чтобы разобраться в том, что происходит \"за сценой\", можно инициализировать создание новой строки с помощью функции конструктора `String`:\n```javascript\nconst str = new String('Hello, World!');\ntypeof str; // \"object\"\n```\n\nПодобное обращение к конструктору `String` происходит каждый раз, когда вы запрашиваете у строки свойство или метод. Создаётся новый объект с помощью функции конструктора, выполняется определённое действие (получение свойства или выполнение метода), а затем созданный ранее объект уничтожается, оставляя после себя только результат. Представить для себя подобное выполнение кода можно следующим образом:\n```javascript\n// Получение свойства length строки\nlet length = 'this is string'.length;\n// За сценой\n// После получения значения созданный объект уничтожится\nlet length = (new String('this is string')).length;\n```\n\nПочему важно понимать, что не всё в JavaScript является объектом? Всё просто. Для любого объекта можно задать значение свойства вручную. Например, то же свойство `length` для массивов и строк:\n```javascript\n// Присваивание значение свойтву length у объектов\nconst arr = ['this', 'is', 'an', 'array'];\narr.length = 10;\n\n// Присваивание значение свойтву length у примитивов\nconst str = 'this is string';\nstr.length = 10;\n\narr.length; // 10 (свойство установлено)\nstr.length; // 14 (свойство не установлено)\n```\n\nПочему свойство `length` у строки не изменилось? Когда вы пытаетесь установить свойство у любого примитива, то происходит следующее:\n\n1. Создаётся новый **объект**: `new String('this is string')`\n2. У **нового** объекта устанавливается свойство `length` со значением `10`\n3. Созданный объект уничтожается\n\nВ результате подобной схемы становится очевидно, что данные, находящиеся в исходной переменной не изменяются, а все изменения происходят с новым объектом, который в будущем будет просто уничтожен.\n\nТо же самое произойдёт и в случае, если вы захотите присвоить новое свойство или метод примитиву:\n```javascript\nconst str = 'str';\nstr.newProp = 'my new property';\nstr.newMethod = function() {\n  return 'my new method';\n};\n\nstr.newProp; // undefined\nstr.newMethod(); // Uncaught TypeError: str.newMethod is not a function\n```\n\nСхема работы такая же, как и в прошлом примере:\n\n1. Создаётся новый **объект**: `new String('str')`, которому присваивается свойство `newProp` со значением `'my new property'`\n2. Созданный объект уничтожается\n3. Создаётся **ещё один** новый объект `new String('str')`, которому присваивается метод `newMethod`\n4. Объект уничтожается\n5. Мы пытаемся получить значение несуществующего свойства `newProp`, в результате чего получаем `undefined`\n6. Мы пытаемся выполнить несуществующий метод `newMethod`, что эквивалентно `undefined()`, и получаем ошибку\n\n##### Примитивные данные\n\nВ JavaScript все примитивные данные разделяются на 6 типов:\n\n1. строки: `'str'`, `\"str\"`, ``  `str` ``\n2. числа: `2`, `0`, `100.34`\n3. boolean: `true` и `false`\n4. `undefined`\n5. `null`\n6. символы `Symbol()`\n\nУ строк, чисел и boolean есть функции конструкторы, с помощью, которых можно их инициализировать:\n```javascript\nconst str = new String('str');\nconst num = new Number(20);\nconst bool = new Boolean(true);\n```\n\nНо несмотря на то, что у вас есть возможность создавать примитивы с помощью функций конструкторов, делать это в реальных проетках не надо ни при каких обстоятельствах. **Всегда используйте литералы для создания примитивов** (за исключением символов, так как для них не предусмотрено формы литерала, их нужно создавать при помощи функции `Symbol()`). Почему не стоит создавать примитивы с помощью функций конструкторов? Всё, что вам нужно запомнить — при подобном создании примитива вы не получаете само значение, а только его объект-обвертку. В некоторых ситуациях подобное поведение может быть опасным и привести к проблемам. Например, при создании значения типа `boolean` через конструктор:\n```javascript\nconst val = new Boolean(false);\nif (val) { console.log('Hello, World!'); }\n```\n\nВ результате выполнения данного кода в консоль выведется сообщение. Код внутри конструкции `if` выполняется, так как значение находящееся в переменной `val` является объектом с содержимым `{[[PrimitiveValue]]: false}`, а любой объект, даже пустой, в JavaScript является правдивым значением.\n\nВы можете использовать функции `String`, `Number` и `Boolean` без ключевого слова `new`. При подобном использовании всё, что они будут делать — приводить типы. Несколько примеров:\n```javascript\n// Приведение строки к числу\nlet num = Number('20');\ntypeof num; // \"number\"\n\n// Приведение числа к строке\nlet str = String(20);\ntypeof str; // \"string\"\n\n// Приведение любого значения к типу boolean\nlet bool1 = Boolean('str'); // true\nlet bool2 = Boolean(0); // false\n\ntypeof bool1; // \"boolean\"\ntypeof bool2; // \"boolean\"\n```\n\nИногда подобные решения бывают полезными и позволяют сократить объем необходимого кода, например, если нужно отфильтровать все ложные значения из массива, то можно воспользовать функцией `Boolean`:\n```javascript\nconst falsyArr = ['', 0, null, 10, 'string', undefined, true, {a: 1}, false];\nconst truthyArr = falsyArr.filter(Boolean);\n\n// Аналогично\nconst truthyArr = falsyArr.filter(function (item) {\n  return !!item;\n});\n\n// С использование стрелочных функций из ES6\nconst truthyArr = falsyArr.filter(item => !!item);\n```\n\n##### null является объектом?\nЕсли вы попробуете использовать оператор `typeof` для всех примитивов, то, в целом, вы не обнаружите ничего нового для себя:\n```javascript\ntypeof 'str';     // \"string\"\ntypeof 100;       // \"number\"\ntypeof true;      // \"boolean\"\ntypeof undefined; // \"undefined\"\ntypeof Symbol();  // \"symbol\"\n```\n\nВсё складывается хорошо, до тех пор, пока вы не опробуете данный оператор на `null`\n```javascript\ntypeof null; // \"object\"\n```\n\nЕсли вы подумали, что что-то тут неправильно и нелогично, то вы абсолютно правы. Подобное поведение является не более, чем багом языка. Но за столько лет можно же было бы это исправить? Конечно, можно, но следует понимать, что подобное поведение `typeof null` используется практически в каждом приложении или библиотеке. Таким образом, исправить подобный баг невозможно, так как это сломает весь существующий на данный момент JavaScript код. Ввести подобное нововведение в новый стандарт ECMAScript тоже не получится, так как будет потеряна обратная совместимость.\n\nИтого, `null` не является объектом, несмотря на то, что оператор `typeof` утверждает обратное. Это значит, что в `null` не могут быть записаны никакие свойства или методы, то есть действуют все правила примитивов.\n\n##### Объекты\nВыше были перечислены все типы данных, которые являются притивами. Всё остальное в JavaScript является объектом: массивы, функции, сами объекты. Любому объекту можно присвоить свойства и методы. Например, для любой функции:\n```javascript\nconst log = function(message) { console.log(log.messages); };\nlog.messages = ['first', 'second', 'third'];\nlog(); // [\"first\",\"second\",\"third\"]\n```\n\nВ данном примере к свойству `messages` функции `log` можно обратиться сразу при её инициализации. Разумеется, подобным образом можно записывать и методы:\n```javascript\nconst log = function(message) { console.log(log.transform()); };\nlog.messages = ['first', 'second', 'third'];\nlog.transform = function () {\n  return log.messages.map(function(message) {\n    return message + ' message';\n  });\n};\nlog(); // [\"first message\",\"second message\",\"third message\"]\n```\n\nПодобным образом можно присвоить свойства и методы любому другому объекту. Но всегда стоит понимать, зачем вы это делаете и как это работает. Если раздавать методы и свойства всем видам объектов подряд, то, скорее всего, вы очень быстро заметите странное поведение. Например, если задать свойство `newProp` у массива, то вы обнаружите, что в результате выполнения любого перебирающего метода (например, `forEach`) с именнованным свойством `newProp` не была вызвана `callback` функция, а также оно не влияет на длину самого массива:\n```javascript\nconst arr = [1, 2, 3, 4, 5];\nconsole.log(arr.length); // 5\n\narr.newProp = 'awesome property';\nconsole.log(arr.length); // 5\n\n// свойство newProp не выводится в консоль\narr.forEach(function(num) {\n  console.log(num); // 1 2 3 4 5\n});\n```\n\n##### Итого\nВсе типы данных в JavaScript разделяются на примитивы и объекты. Примитивы не могут иметь собственных свойств и методов, объекты могут. Утверждение, что всё в JavaScript является объектом неверное. Более правильно говорить, что **всё в JavaScript ведёт себя, как объект, но необязательно им является**.\n","slug":"oop-objects-vs-primitives","published":1,"updated":"2016-05-23T13:53:04.533Z","_id":"ciok2o2ay00056gpndbrzo7zy","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Скорее всего, вы читали или слышали, что всё в JavaScript является объектом. Ещё чаще можно увидеть опровержения этого утверждения. Подобные споры возникают регулярно и обусловлены в большей степени недопониманием концепций JavaScript. И, на самом деле, причина считать примитивы объектами есть — у примитивов можно запрашивать свойства и методы, поведение которых во многом схоже со свойствами и методами объектов.<a id=\"more\"></a> Например, строки и массивы содержат одинаковые свойство <code>length</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"string\">'this'</span>, <span class=\"string\">'is'</span>, <span class=\"string\">'an'</span>, <span class=\"string\">'array'</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">'this is string'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.length); <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.length); <span class=\"comment\">// 14</span></span><br></pre></td></tr></table></figure></p>\n<p>На первый взгляд, может показаться, что свойство <code>length</code> работает одинаково для строк и массивов. Тем не менее, разница есть. Чтобы понять в чём она заключается достаточно использовать оператор <code>typeof</code> для каждого типа данных:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> str; <span class=\"comment\">// \"string\"</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> arr; <span class=\"comment\">// \"object\"</span></span><br></pre></td></tr></table></figure></p>\n<p>И что? Это не отменяет того, что мы можем использовать полноценные методы и свойства у примитивов. Всё верно. Но следует учитывать то, что происходит “за сценой”. У каждого примитивного типа данных есть своя функция конструктор, например, для строк — <code>String</code>, для чисел — <code>Number</code>. Когда вы хотите получить какое-либо свойство или метод для примитивов, вы обращаетесь не к самому примитиву, а к объекту, созданному функцией-конструктором данного примитива. Другими словами, <strong>примитивы не имеют свойств и методов и не являются объектами</strong>. Чтобы разобраться в том, что происходит “за сценой”, можно инициализировать создание новой строки с помощью функции конструктора <code>String</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'Hello, World!'</span>);</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> str; <span class=\"comment\">// \"object\"</span></span><br></pre></td></tr></table></figure></p>\n<p>Подобное обращение к конструктору <code>String</code> происходит каждый раз, когда вы запрашиваете у строки свойство или метод. Создаётся новый объект с помощью функции конструктора, выполняется определённое действие (получение свойства или выполнение метода), а затем созданный ранее объект уничтожается, оставляя после себя только результат. Представить для себя подобное выполнение кода можно следующим образом:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Получение свойства length строки</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> length = <span class=\"string\">'this is string'</span>.length;</span><br><span class=\"line\"><span class=\"comment\">// За сценой</span></span><br><span class=\"line\"><span class=\"comment\">// После получения значения созданный объект уничтожится</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> length = (<span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'this is string'</span>)).length;</span><br></pre></td></tr></table></figure></p>\n<p>Почему важно понимать, что не всё в JavaScript является объектом? Всё просто. Для любого объекта можно задать значение свойства вручную. Например, то же свойство <code>length</code> для массивов и строк:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Присваивание значение свойтву length у объектов</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"string\">'this'</span>, <span class=\"string\">'is'</span>, <span class=\"string\">'an'</span>, <span class=\"string\">'array'</span>];</span><br><span class=\"line\">arr.length = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Присваивание значение свойтву length у примитивов</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">'this is string'</span>;</span><br><span class=\"line\">str.length = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">arr.length; <span class=\"comment\">// 10 (свойство установлено)</span></span><br><span class=\"line\">str.length; <span class=\"comment\">// 14 (свойство не установлено)</span></span><br></pre></td></tr></table></figure></p>\n<p>Почему свойство <code>length</code> у строки не изменилось? Когда вы пытаетесь установить свойство у любого примитива, то происходит следующее:</p>\n<ol>\n<li>Создаётся новый <strong>объект</strong>: <code>new String(&#39;this is string&#39;)</code></li>\n<li>У <strong>нового</strong> объекта устанавливается свойство <code>length</code> со значением <code>10</code></li>\n<li>Созданный объект уничтожается</li>\n</ol>\n<p>В результате подобной схемы становится очевидно, что данные, находящиеся в исходной переменной не изменяются, а все изменения происходят с новым объектом, который в будущем будет просто уничтожен.</p>\n<p>То же самое произойдёт и в случае, если вы захотите присвоить новое свойство или метод примитиву:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">'str'</span>;</span><br><span class=\"line\">str.newProp = <span class=\"string\">'my new property'</span>;</span><br><span class=\"line\">str.newMethod = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'my new method'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">str.newProp; <span class=\"comment\">// undefined</span></span><br><span class=\"line\">str.newMethod(); <span class=\"comment\">// Uncaught TypeError: str.newMethod is not a function</span></span><br></pre></td></tr></table></figure></p>\n<p>Схема работы такая же, как и в прошлом примере:</p>\n<ol>\n<li>Создаётся новый <strong>объект</strong>: <code>new String(&#39;str&#39;)</code>, которому присваивается свойство <code>newProp</code> со значением <code>&#39;my new property&#39;</code></li>\n<li>Созданный объект уничтожается</li>\n<li>Создаётся <strong>ещё один</strong> новый объект <code>new String(&#39;str&#39;)</code>, которому присваивается метод <code>newMethod</code></li>\n<li>Объект уничтожается</li>\n<li>Мы пытаемся получить значение несуществующего свойства <code>newProp</code>, в результате чего получаем <code>undefined</code></li>\n<li>Мы пытаемся выполнить несуществующий метод <code>newMethod</code>, что эквивалентно <code>undefined()</code>, и получаем ошибку</li>\n</ol>\n<h5 id=\"Примитивные-данные\"><a href=\"#Примитивные-данные\" class=\"headerlink\" title=\"Примитивные данные\"></a>Примитивные данные</h5><p>В JavaScript все примитивные данные разделяются на 6 типов:</p>\n<ol>\n<li>строки: <code>&#39;str&#39;</code>, <code>&quot;str&quot;</code>, <code>`str` </code></li>\n<li>числа: <code>2</code>, <code>0</code>, <code>100.34</code></li>\n<li>boolean: <code>true</code> и <code>false</code></li>\n<li><code>undefined</code></li>\n<li><code>null</code></li>\n<li>символы <code>Symbol()</code></li>\n</ol>\n<p>У строк, чисел и boolean есть функции конструкторы, с помощью, которых можно их инициализировать:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'str'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> num = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> bool = <span class=\"keyword\">new</span> <span class=\"built_in\">Boolean</span>(<span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure></p>\n<p>Но несмотря на то, что у вас есть возможность создавать примитивы с помощью функций конструкторов, делать это в реальных проетках не надо ни при каких обстоятельствах. <strong>Всегда используйте литералы для создания примитивов</strong> (за исключением символов, так как для них не предусмотрено формы литерала, их нужно создавать при помощи функции <code>Symbol()</code>). Почему не стоит создавать примитивы с помощью функций конструкторов? Всё, что вам нужно запомнить — при подобном создании примитива вы не получаете само значение, а только его объект-обвертку. В некоторых ситуациях подобное поведение может быть опасным и привести к проблемам. Например, при создании значения типа <code>boolean</code> через конструктор:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> val = <span class=\"keyword\">new</span> <span class=\"built_in\">Boolean</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (val) &#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello, World!'</span>); &#125;</span><br></pre></td></tr></table></figure></p>\n<p>В результате выполнения данного кода в консоль выведется сообщение. Код внутри конструкции <code>if</code> выполняется, так как значение находящееся в переменной <code>val</code> является объектом с содержимым <code>{[[PrimitiveValue]]: false}</code>, а любой объект, даже пустой, в JavaScript является правдивым значением.</p>\n<p>Вы можете использовать функции <code>String</code>, <code>Number</code> и <code>Boolean</code> без ключевого слова <code>new</code>. При подобном использовании всё, что они будут делать — приводить типы. Несколько примеров:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Приведение строки к числу</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> num = <span class=\"built_in\">Number</span>(<span class=\"string\">'20'</span>);</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> num; <span class=\"comment\">// \"number\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Приведение числа к строке</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"built_in\">String</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> str; <span class=\"comment\">// \"string\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Приведение любого значения к типу boolean</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> bool1 = <span class=\"built_in\">Boolean</span>(<span class=\"string\">'str'</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> bool2 = <span class=\"built_in\">Boolean</span>(<span class=\"number\">0</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> bool1; <span class=\"comment\">// \"boolean\"</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> bool2; <span class=\"comment\">// \"boolean\"</span></span><br></pre></td></tr></table></figure></p>\n<p>Иногда подобные решения бывают полезными и позволяют сократить объем необходимого кода, например, если нужно отфильтровать все ложные значения из массива, то можно воспользовать функцией <code>Boolean</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> falsyArr = [<span class=\"string\">''</span>, <span class=\"number\">0</span>, <span class=\"literal\">null</span>, <span class=\"number\">10</span>, <span class=\"string\">'string'</span>, <span class=\"literal\">undefined</span>, <span class=\"literal\">true</span>, &#123;a: <span class=\"number\">1</span>&#125;, <span class=\"literal\">false</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> truthyArr = falsyArr.filter(<span class=\"built_in\">Boolean</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Аналогично</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> truthyArr = falsyArr.filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> !!item;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// С использование стрелочных функций из ES6</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> truthyArr = falsyArr.filter(item =&gt; !!item);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"null-является-объектом\"><a href=\"#null-является-объектом\" class=\"headerlink\" title=\"null является объектом?\"></a>null является объектом?</h5><p>Если вы попробуете использовать оператор <code>typeof</code> для всех примитивов, то, в целом, вы не обнаружите ничего нового для себя:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">'str'</span>;     <span class=\"comment\">// \"string\"</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">100</span>;       <span class=\"comment\">// \"number\"</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">true</span>;      <span class=\"comment\">// \"boolean\"</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// \"undefined\"</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">Symbol</span>();  <span class=\"comment\">// \"symbol\"</span></span><br></pre></td></tr></table></figure></p>\n<p>Всё складывается хорошо, до тех пор, пока вы не опробуете данный оператор на <code>null</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span>; <span class=\"comment\">// \"object\"</span></span><br></pre></td></tr></table></figure></p>\n<p>Если вы подумали, что что-то тут неправильно и нелогично, то вы абсолютно правы. Подобное поведение является не более, чем багом языка. Но за столько лет можно же было бы это исправить? Конечно, можно, но следует понимать, что подобное поведение <code>typeof null</code> используется практически в каждом приложении или библиотеке. Таким образом, исправить подобный баг невозможно, так как это сломает весь существующий на данный момент JavaScript код. Ввести подобное нововведение в новый стандарт ECMAScript тоже не получится, так как будет потеряна обратная совместимость.</p>\n<p>Итого, <code>null</code> не является объектом, несмотря на то, что оператор <code>typeof</code> утверждает обратное. Это значит, что в <code>null</code> не могут быть записаны никакие свойства или методы, то есть действуют все правила примитивов.</p>\n<h5 id=\"Объекты\"><a href=\"#Объекты\" class=\"headerlink\" title=\"Объекты\"></a>Объекты</h5><p>Выше были перечислены все типы данных, которые являются притивами. Всё остальное в JavaScript является объектом: массивы, функции, сами объекты. Любому объекту можно присвоить свойства и методы. Например, для любой функции:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> log = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">message</span>) </span>&#123; <span class=\"built_in\">console</span>.log(log.messages); &#125;;</span><br><span class=\"line\">log.messages = [<span class=\"string\">'first'</span>, <span class=\"string\">'second'</span>, <span class=\"string\">'third'</span>];</span><br><span class=\"line\">log(); <span class=\"comment\">// [\"first\",\"second\",\"third\"]</span></span><br></pre></td></tr></table></figure></p>\n<p>В данном примере к свойству <code>messages</code> функции <code>log</code> можно обратиться сразу при её инициализации. Разумеется, подобным образом можно записывать и методы:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> log = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">message</span>) </span>&#123; <span class=\"built_in\">console</span>.log(log.transform()); &#125;;</span><br><span class=\"line\">log.messages = [<span class=\"string\">'first'</span>, <span class=\"string\">'second'</span>, <span class=\"string\">'third'</span>];</span><br><span class=\"line\">log.transform = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> log.messages.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> message + <span class=\"string\">' message'</span>;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">log(); <span class=\"comment\">// [\"first message\",\"second message\",\"third message\"]</span></span><br></pre></td></tr></table></figure></p>\n<p>Подобным образом можно присвоить свойства и методы любому другому объекту. Но всегда стоит понимать, зачем вы это делаете и как это работает. Если раздавать методы и свойства всем видам объектов подряд, то, скорее всего, вы очень быстро заметите странное поведение. Например, если задать свойство <code>newProp</code> у массива, то вы обнаружите, что в результате выполнения любого перебирающего метода (например, <code>forEach</code>) с именнованным свойством <code>newProp</code> не была вызвана <code>callback</code> функция, а также оно не влияет на длину самого массива:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.length); <span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\">arr.newProp = <span class=\"string\">'awesome property'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.length); <span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// свойство newProp не выводится в консоль</span></span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(num); <span class=\"comment\">// 1 2 3 4 5</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Итого\"><a href=\"#Итого\" class=\"headerlink\" title=\"Итого\"></a>Итого</h5><p>Все типы данных в JavaScript разделяются на примитивы и объекты. Примитивы не могут иметь собственных свойств и методов, объекты могут. Утверждение, что всё в JavaScript является объектом неверное. Более правильно говорить, что <strong>всё в JavaScript ведёт себя, как объект, но необязательно им является</strong>.</p>\n","excerpt":"<p>Скорее всего, вы читали или слышали, что всё в JavaScript является объектом. Ещё чаще можно увидеть опровержения этого утверждения. Подобные споры возникают регулярно и обусловлены в большей степени недопониманием концепций JavaScript. И, на самом деле, причина считать примитивы объектами есть — у примитивов можно запрашивать свойства и методы, поведение которых во многом схоже со свойствами и методами объектов.","more":"Например, строки и массивы содержат одинаковые свойство <code>length</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"string\">'this'</span>, <span class=\"string\">'is'</span>, <span class=\"string\">'an'</span>, <span class=\"string\">'array'</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">'this is string'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.length); <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.length); <span class=\"comment\">// 14</span></span><br></pre></td></tr></table></figure></p>\n<p>На первый взгляд, может показаться, что свойство <code>length</code> работает одинаково для строк и массивов. Тем не менее, разница есть. Чтобы понять в чём она заключается достаточно использовать оператор <code>typeof</code> для каждого типа данных:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> str; <span class=\"comment\">// \"string\"</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> arr; <span class=\"comment\">// \"object\"</span></span><br></pre></td></tr></table></figure></p>\n<p>И что? Это не отменяет того, что мы можем использовать полноценные методы и свойства у примитивов. Всё верно. Но следует учитывать то, что происходит “за сценой”. У каждого примитивного типа данных есть своя функция конструктор, например, для строк — <code>String</code>, для чисел — <code>Number</code>. Когда вы хотите получить какое-либо свойство или метод для примитивов, вы обращаетесь не к самому примитиву, а к объекту, созданному функцией-конструктором данного примитива. Другими словами, <strong>примитивы не имеют свойств и методов и не являются объектами</strong>. Чтобы разобраться в том, что происходит “за сценой”, можно инициализировать создание новой строки с помощью функции конструктора <code>String</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'Hello, World!'</span>);</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> str; <span class=\"comment\">// \"object\"</span></span><br></pre></td></tr></table></figure></p>\n<p>Подобное обращение к конструктору <code>String</code> происходит каждый раз, когда вы запрашиваете у строки свойство или метод. Создаётся новый объект с помощью функции конструктора, выполняется определённое действие (получение свойства или выполнение метода), а затем созданный ранее объект уничтожается, оставляя после себя только результат. Представить для себя подобное выполнение кода можно следующим образом:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Получение свойства length строки</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> length = <span class=\"string\">'this is string'</span>.length;</span><br><span class=\"line\"><span class=\"comment\">// За сценой</span></span><br><span class=\"line\"><span class=\"comment\">// После получения значения созданный объект уничтожится</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> length = (<span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'this is string'</span>)).length;</span><br></pre></td></tr></table></figure></p>\n<p>Почему важно понимать, что не всё в JavaScript является объектом? Всё просто. Для любого объекта можно задать значение свойства вручную. Например, то же свойство <code>length</code> для массивов и строк:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Присваивание значение свойтву length у объектов</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"string\">'this'</span>, <span class=\"string\">'is'</span>, <span class=\"string\">'an'</span>, <span class=\"string\">'array'</span>];</span><br><span class=\"line\">arr.length = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Присваивание значение свойтву length у примитивов</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">'this is string'</span>;</span><br><span class=\"line\">str.length = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">arr.length; <span class=\"comment\">// 10 (свойство установлено)</span></span><br><span class=\"line\">str.length; <span class=\"comment\">// 14 (свойство не установлено)</span></span><br></pre></td></tr></table></figure></p>\n<p>Почему свойство <code>length</code> у строки не изменилось? Когда вы пытаетесь установить свойство у любого примитива, то происходит следующее:</p>\n<ol>\n<li>Создаётся новый <strong>объект</strong>: <code>new String(&#39;this is string&#39;)</code></li>\n<li>У <strong>нового</strong> объекта устанавливается свойство <code>length</code> со значением <code>10</code></li>\n<li>Созданный объект уничтожается</li>\n</ol>\n<p>В результате подобной схемы становится очевидно, что данные, находящиеся в исходной переменной не изменяются, а все изменения происходят с новым объектом, который в будущем будет просто уничтожен.</p>\n<p>То же самое произойдёт и в случае, если вы захотите присвоить новое свойство или метод примитиву:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">'str'</span>;</span><br><span class=\"line\">str.newProp = <span class=\"string\">'my new property'</span>;</span><br><span class=\"line\">str.newMethod = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'my new method'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">str.newProp; <span class=\"comment\">// undefined</span></span><br><span class=\"line\">str.newMethod(); <span class=\"comment\">// Uncaught TypeError: str.newMethod is not a function</span></span><br></pre></td></tr></table></figure></p>\n<p>Схема работы такая же, как и в прошлом примере:</p>\n<ol>\n<li>Создаётся новый <strong>объект</strong>: <code>new String(&#39;str&#39;)</code>, которому присваивается свойство <code>newProp</code> со значением <code>&#39;my new property&#39;</code></li>\n<li>Созданный объект уничтожается</li>\n<li>Создаётся <strong>ещё один</strong> новый объект <code>new String(&#39;str&#39;)</code>, которому присваивается метод <code>newMethod</code></li>\n<li>Объект уничтожается</li>\n<li>Мы пытаемся получить значение несуществующего свойства <code>newProp</code>, в результате чего получаем <code>undefined</code></li>\n<li>Мы пытаемся выполнить несуществующий метод <code>newMethod</code>, что эквивалентно <code>undefined()</code>, и получаем ошибку</li>\n</ol>\n<h5 id=\"Примитивные-данные\"><a href=\"#Примитивные-данные\" class=\"headerlink\" title=\"Примитивные данные\"></a>Примитивные данные</h5><p>В JavaScript все примитивные данные разделяются на 6 типов:</p>\n<ol>\n<li>строки: <code>&#39;str&#39;</code>, <code>&quot;str&quot;</code>, <code>`str` </code></li>\n<li>числа: <code>2</code>, <code>0</code>, <code>100.34</code></li>\n<li>boolean: <code>true</code> и <code>false</code></li>\n<li><code>undefined</code></li>\n<li><code>null</code></li>\n<li>символы <code>Symbol()</code></li>\n</ol>\n<p>У строк, чисел и boolean есть функции конструкторы, с помощью, которых можно их инициализировать:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'str'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> num = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> bool = <span class=\"keyword\">new</span> <span class=\"built_in\">Boolean</span>(<span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure></p>\n<p>Но несмотря на то, что у вас есть возможность создавать примитивы с помощью функций конструкторов, делать это в реальных проетках не надо ни при каких обстоятельствах. <strong>Всегда используйте литералы для создания примитивов</strong> (за исключением символов, так как для них не предусмотрено формы литерала, их нужно создавать при помощи функции <code>Symbol()</code>). Почему не стоит создавать примитивы с помощью функций конструкторов? Всё, что вам нужно запомнить — при подобном создании примитива вы не получаете само значение, а только его объект-обвертку. В некоторых ситуациях подобное поведение может быть опасным и привести к проблемам. Например, при создании значения типа <code>boolean</code> через конструктор:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> val = <span class=\"keyword\">new</span> <span class=\"built_in\">Boolean</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (val) &#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello, World!'</span>); &#125;</span><br></pre></td></tr></table></figure></p>\n<p>В результате выполнения данного кода в консоль выведется сообщение. Код внутри конструкции <code>if</code> выполняется, так как значение находящееся в переменной <code>val</code> является объектом с содержимым <code>{[[PrimitiveValue]]: false}</code>, а любой объект, даже пустой, в JavaScript является правдивым значением.</p>\n<p>Вы можете использовать функции <code>String</code>, <code>Number</code> и <code>Boolean</code> без ключевого слова <code>new</code>. При подобном использовании всё, что они будут делать — приводить типы. Несколько примеров:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Приведение строки к числу</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> num = <span class=\"built_in\">Number</span>(<span class=\"string\">'20'</span>);</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> num; <span class=\"comment\">// \"number\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Приведение числа к строке</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"built_in\">String</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> str; <span class=\"comment\">// \"string\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Приведение любого значения к типу boolean</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> bool1 = <span class=\"built_in\">Boolean</span>(<span class=\"string\">'str'</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> bool2 = <span class=\"built_in\">Boolean</span>(<span class=\"number\">0</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> bool1; <span class=\"comment\">// \"boolean\"</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> bool2; <span class=\"comment\">// \"boolean\"</span></span><br></pre></td></tr></table></figure></p>\n<p>Иногда подобные решения бывают полезными и позволяют сократить объем необходимого кода, например, если нужно отфильтровать все ложные значения из массива, то можно воспользовать функцией <code>Boolean</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> falsyArr = [<span class=\"string\">''</span>, <span class=\"number\">0</span>, <span class=\"literal\">null</span>, <span class=\"number\">10</span>, <span class=\"string\">'string'</span>, <span class=\"literal\">undefined</span>, <span class=\"literal\">true</span>, &#123;a: <span class=\"number\">1</span>&#125;, <span class=\"literal\">false</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> truthyArr = falsyArr.filter(<span class=\"built_in\">Boolean</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Аналогично</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> truthyArr = falsyArr.filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> !!item;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// С использование стрелочных функций из ES6</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> truthyArr = falsyArr.filter(item =&gt; !!item);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"null-является-объектом\"><a href=\"#null-является-объектом\" class=\"headerlink\" title=\"null является объектом?\"></a>null является объектом?</h5><p>Если вы попробуете использовать оператор <code>typeof</code> для всех примитивов, то, в целом, вы не обнаружите ничего нового для себя:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">'str'</span>;     <span class=\"comment\">// \"string\"</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">100</span>;       <span class=\"comment\">// \"number\"</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">true</span>;      <span class=\"comment\">// \"boolean\"</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// \"undefined\"</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">Symbol</span>();  <span class=\"comment\">// \"symbol\"</span></span><br></pre></td></tr></table></figure></p>\n<p>Всё складывается хорошо, до тех пор, пока вы не опробуете данный оператор на <code>null</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span>; <span class=\"comment\">// \"object\"</span></span><br></pre></td></tr></table></figure></p>\n<p>Если вы подумали, что что-то тут неправильно и нелогично, то вы абсолютно правы. Подобное поведение является не более, чем багом языка. Но за столько лет можно же было бы это исправить? Конечно, можно, но следует понимать, что подобное поведение <code>typeof null</code> используется практически в каждом приложении или библиотеке. Таким образом, исправить подобный баг невозможно, так как это сломает весь существующий на данный момент JavaScript код. Ввести подобное нововведение в новый стандарт ECMAScript тоже не получится, так как будет потеряна обратная совместимость.</p>\n<p>Итого, <code>null</code> не является объектом, несмотря на то, что оператор <code>typeof</code> утверждает обратное. Это значит, что в <code>null</code> не могут быть записаны никакие свойства или методы, то есть действуют все правила примитивов.</p>\n<h5 id=\"Объекты\"><a href=\"#Объекты\" class=\"headerlink\" title=\"Объекты\"></a>Объекты</h5><p>Выше были перечислены все типы данных, которые являются притивами. Всё остальное в JavaScript является объектом: массивы, функции, сами объекты. Любому объекту можно присвоить свойства и методы. Например, для любой функции:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> log = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">message</span>) </span>&#123; <span class=\"built_in\">console</span>.log(log.messages); &#125;;</span><br><span class=\"line\">log.messages = [<span class=\"string\">'first'</span>, <span class=\"string\">'second'</span>, <span class=\"string\">'third'</span>];</span><br><span class=\"line\">log(); <span class=\"comment\">// [\"first\",\"second\",\"third\"]</span></span><br></pre></td></tr></table></figure></p>\n<p>В данном примере к свойству <code>messages</code> функции <code>log</code> можно обратиться сразу при её инициализации. Разумеется, подобным образом можно записывать и методы:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> log = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">message</span>) </span>&#123; <span class=\"built_in\">console</span>.log(log.transform()); &#125;;</span><br><span class=\"line\">log.messages = [<span class=\"string\">'first'</span>, <span class=\"string\">'second'</span>, <span class=\"string\">'third'</span>];</span><br><span class=\"line\">log.transform = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> log.messages.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> message + <span class=\"string\">' message'</span>;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">log(); <span class=\"comment\">// [\"first message\",\"second message\",\"third message\"]</span></span><br></pre></td></tr></table></figure></p>\n<p>Подобным образом можно присвоить свойства и методы любому другому объекту. Но всегда стоит понимать, зачем вы это делаете и как это работает. Если раздавать методы и свойства всем видам объектов подряд, то, скорее всего, вы очень быстро заметите странное поведение. Например, если задать свойство <code>newProp</code> у массива, то вы обнаружите, что в результате выполнения любого перебирающего метода (например, <code>forEach</code>) с именнованным свойством <code>newProp</code> не была вызвана <code>callback</code> функция, а также оно не влияет на длину самого массива:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.length); <span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\">arr.newProp = <span class=\"string\">'awesome property'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.length); <span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// свойство newProp не выводится в консоль</span></span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(num); <span class=\"comment\">// 1 2 3 4 5</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Итого\"><a href=\"#Итого\" class=\"headerlink\" title=\"Итого\"></a>Итого</h5><p>Все типы данных в JavaScript разделяются на примитивы и объекты. Примитивы не могут иметь собственных свойств и методов, объекты могут. Утверждение, что всё в JavaScript является объектом неверное. Более правильно говорить, что <strong>всё в JavaScript ведёт себя, как объект, но необязательно им является</strong>.</p>"},{"title":"Перебирающие методы массивов изнутри","author":"rtivital","date":"2016-04-25T00:00:00.000Z","_content":"\nМетоды массивов `forEach`, `map`, `filter`, `some`, `every` и `reduce` являются неотъемлимой частью функционального программирования на JavaScript. В этой статье подробно рассмотрим применение каждого из них, а также их реализацию в виде функций.\n<!--MORE-->\n## forEach\nСамый простой способ разобраться, как работают функции высшего порядка, принимающие callback'и, — самостоятельно переписать несколько нативных методов. Начнём с самого простого метода `Array.prototype.forEach`. Метод массивов `forEach` принимает два аргумента: первый (обязательный) — `callback` функция, которая будет выполнена для каждого элемента массива один раз и второй (необязательный) — значение, которое будет использовано в качестве `this` при вызове функции `callback`. Работает это следующим образом:\n```javascript\n['JavaScript', 'is', 'awesome'].forEach(function(item, index, arr) {\n  console.log(item, index, arr);\n});\n// Выведет в консоль\n// JavaScript 0 [\"JavaScript\",\"is\",\"awesome\"]\n// is 1 [\"JavaScript\",\"is\",\"awesome\"]\n// awesome 2 [\"JavaScript\",\"is\",\"awesome\"]\n```\n\nВ `callback` функцию передаётся три аргумента: `item`, соответствующий элементу массива, `index`, равный номеру элемента в массиве, и `arr` — ссылка на массив. Таким образом, справедливо следующее выражение `arr[index] === item`. Аргументам передаваемым в `callback` функцию можно давать разные названия в зависимости от контекста выполнения — выполнение `callback` функции от этого не изменится:\n```javascript\n[1, 2, 3, 4, 5].forEach(function(num, i, nums) {\n  console.log(num * 2); // 2 4 6 8 10\n});\n```\n\nКак я писал выше, помимо `callback` функции метод `forEach` принимает ещё один аргумент — значение, которое будет использовано в качестве `this` при вызове функции `callback`. Зачем это может понадобиться? По умолчанию `this` не определён, то есть равен `undefined`. В некоторых ситуациях, особенно при работе с функциями конструкторами, необходимо задать контекст выполнения `callback` функции:\n```javascript\nvar Person = function(name) {\n  this.name = name;\n};\n\nPerson.prototype.say = function(phrase) {\n  console.log(this.name + ' says ' + phrase);\n}\n\nPerson.prototype.mumble = function(phrases) {\n  phrases.forEach(function(phrase) {\n    this.say(phrase);\n  });\n}\n\nvar johnDoe = new Person('John Doe');\njohnDoe.mumble(['Hello, World!', 'JS is great', 'I\\'m designer and i don\\'t have job']);\n```\n\nПодобный код, на первый взгляд, может оказаться полностью рабочим. Тем не менее, после его выполнения всё, что мы увидим будет ошибка `Cannot read property 'say' of undefined`. Данная ошибка показывает, что при выполнении метода `forEach` на передаваемом в метод `mumble` массиве `phrases` не задаётся контекст испольнения `callback` функции. Проще говоря, `callback` функция пытается выполнить подобный код `undefined[say](words)`. Решается данная проблема элементарно — передётся второй аргумент в метод `forEach`, который и указывает ему, что брать за `this`:\n```javascript\n// ...\nPerson.prototype.mumble = function(arr) {\n  arr.forEach(function(words){\n    this.say(words);\n  }, this);\n}\n\nvar johnDoe = new Person('John Doe');\njohnDoe.mumble(['Hello, World!', 'JS is great', 'I\\'m designer and i don\\'t have job']);\n\n// Выведет в консоль\n// John Doe says Hello, World!\n// John Doe says JS is great\n// John Doe says I'm designer and i don't have job\n```\n\n## forEach своими руками\nТеперь, когда вы знаете, как работает `forEach`, настало время написать функцию, которая делает всё тоже самое. При создании функции `each` будем руководствоваться тремя правилами:\n\n1. Функция принимает три аргумента: массив, по которому будет происходить итерация, `callback` фунцию, которая будет выполнена для каждого элемента массива, и значение, которое будет использовано `callback` функцией в качестве `this`.\n2. `callback` функция, в свою очередь, также работает с тремя аргументами: текущий элемент массива, индекс элемента, ссылка на сам массив.\n3. Функция ничего не возвращает.\n\nСамое очевидное решение: используя цикл `for` перебрать каждый элемент массива и выполнить передаваемую `callback` функцию с каждым. Сделать это очень просто:\n```javascript\nvar each = function(arr, callback, thisArg) {\n  var i, length = arr.length;\n  for (i = 0; i < length; i = i + 1) {\n    callback(arr[i], i, arr);\n  }\n};\n```\n\nФункция `each` будет отлично работать, за исключением того, что не соблюдается часть первого правила — для `callback` функции нельзя задать контекст, то есть нельзя присвоить значение `this`:\n```javascript\neach([1, 2, 3], function(num, i, nums) {\n  console.log('Number: ' + num + ', index: ' + i + ',', nums)\n});\n\n// Выведет в консоль\n// Number: 1, index: 0, [1,2,3]\n// Number: 2, index: 1, [1,2,3]\n// Number: 3, index: 2, [1,2,3]\n```\n\nЧтобы можно было осуществлять передачу ключевого слова `this` в функцию `each` достаточно воспользоваться методом функций `call`, который позволяет вызвать функцию и явно указать, на что будет указывать ключевое слово `this`.\n```javascript\nvar each = function(arr, callback, thisArg) {\n  var i, length = arr.length;\n  for (i = 0; i < length; i = i + 1) {\n    callback.call(thisArg, arr[i], i, arr);\n  }\n};\n```\n\nТеперь функция `each` работает с массивами в точности так, как и метод `forEach`. Чтобы её протестировать, можно запустить её вместе с кодом из предыдущего примера.\n```javascript\nvar Person = function(name) {\n  this.name = name;\n};\n\nPerson.prototype.say = function(phrase) {\n  console.log(this.name + ' says ' + phrase);\n}\n\nPerson.prototype.mumble = function(phrases) {\n  each(phrases, function(phrase) {\n    this.say(phrase);\n  }, this);\n}\n\nvar johnDoe = new Person('John Doe');\njohnDoe.mumble(['Hello, World!', 'JS is great', 'I\\'m designer and i don\\'t have job']);\n\n// Выведет в консоль\n// John Doe says Hello, World!\n// John Doe says JS is great\n// John Doe says I'm designer and i don't have job\n```\n\nНесмотря на кажущуюся одинаковость метода `forEach` и написанной нами выше функции `each`, между ними есть одно очень важное различие: метод `forEach` работает **только с массивами**, в то время как функция `each` может также успешно работать с **любыми коллекциями**.\n\nСкорее всего, вы уже видели ранее подобную конструкцию, которую использую многие JavaScript разработчики для итерации по всем элементам из DOM коллекции:\n```javascript\nvar links = document.links; // коллекция всех ссылок на странице\n[].forEach.call(links, function(link) {\n  // Добавление класса link-active для всех ссылок на странице\n  link.classList.add('link-active');\n});\n```\n\nПодобная конструкция может ввести в замешательство практически любого программиста, который раньше не использовал её сам. Подробное объяснение, как именно она работает можно найти в [этом вопросе](http://stackoverflow.com/questions/16053357/what-does-foreach-call-do-in-javascript) на Stackoverflow. Нужна она лишь для того, чтобы провести итерацию по всем элементам выбранной DOM коллекции и выполнить `callback` функцию для каждого из них. При использовании написанной нами функции `each` надобности в такой хитрой конструкции нет, так как она поддерживает работу не только с массивами, но и с любыми коллекциями, в том числе и коллекциями DOM элементов:\n```javascript\nvar links = document.links; // коллекция всех ссылок на странице\neach(links, function(link) {\n  // Добавление класса link-active для всех ссылок на странице\n  link.classList.add('link-active');\n});\n```\n\nКогда появится широкая поддежка **ES6** метод `forEach` можно будет использовать с DOM коллекциями более простым способом с помощью оператора [Spread](http://jsraccoon.ru/es6-spread-rest/):\n```javascript\n[...links].forEach(function(link) {\n  link.classList.add('link-active');\n});\n```\n\n## map\n\nМетод массивов `map` похож по своей функциональности на `forEach`, но результат выполнения `callback` функции добавляется в новый массив, который возвращается после последней итерации. Другими словами, результатом метода `map` всегда является **новый** массив с результатами выполнения функции `callback` на исходном массиве.\n```javascript\nvar nums = [10, 20, 30, 40];\nvar results = nums.map(function(num, index, arr) {\n  // Возведение числа в степень соответсвующую его индексу в массиве\n  return Math.pow(num, index);\n});\n\n// Исходный массив nums не изменяется\nconsole.log(nums); // [10,20,30,40]\n// результат выполнения map, записанный в переменную\nconsole.log(results); // [1,20,900,64000]\n```\n\nТакже, как и в случае с `forEach` `map` помимо `callback` функции принимает второй параметр, который позволяет задать контекст и явно указать `this`:\n```javascript\nvar Person = function(name) {\n  this.name = name;\n  this.phrases = null;\n};\n\nPerson.prototype.say = function(phrase) {\n  return this.name + ' says ' + phrase;\n}\n\nPerson.prototype.grabPhrases = function(phrases) {\n  this.phrases = phrases.map(function(phrase){\n    // Добавление изменённой строки в новый массив\n    return this.say(phrase);\n  }, this)\n}\n\nvar johnDoe = new Person('John Doe');\njohnDoe.grabPhrases(['Hello, World!', 'JS is great', 'I\\'m designer and i don\\'t have job']);\nconsole.log(johnDoe.phrases);\n// [\"John Doe says Hello, World!\",\"John Doe says JS is great\",\"John Doe says I'm designer and i don't have job\"]\n```\n\nКак вы могли заметить, при использовании `map` и `forEach` всегда использовалась анонимная функция в качестве `callback`. Это совсем не обязательно. Вы можете объвить функцию, которую хотите использовать в качестве `callback` заранее, а затем просто передать её в качестве параметра.\n```javascript\nvar slice = function(str) {\n  // вернуть первые пять символов из строки\n  return str.slice(0, 5);\n};\n\nvar frameworks = ['Knockout', 'Backbone', 'Angular'].map(slice);\n\nconsole.log(frameworks); // [\"Knock\",\"Backb\",\"Angul\"]\n```\n\nВ некоторых ситуациях можно вообще не создавать отдельную функцию и пользоваться нативными методами. Пример выше, в котором каждое число в массиве возводилось в степень, соответствующую своему индексу, можно значительно сократить:\n```javascript\n// Длинный вариант с ненужной анонимной функцией\nvar nums = [10, 20, 30, 40];\nvar results = nums.map(function(num, index, arr) {\n  return Math.pow(num, index);\n});\n\n// Короткий вариант, ничего лишнего\nvar nums = [10, 20, 30, 40];\nvar results = nums.map(Math.pow);\n```\n\nПередвая `callback` функцию подобным образом вы не теряете возможность явно указать `this`. Таким образом, метод `grabPhrases` из функции конструктора `Person` также можно немного сократить:\n```javascript\nPerson.prototype.grabPhrases = function(phrases) {\n  // Ненужная анонимная функция\n  this.phrases = phrases.map(function(phrase) {\n    return this.say(phrase);\n  }, this);\n}\n// Выполнение функции this.say для каждого элемента массива\nPerson.prototype.grabPhrases = function(phrases) {\n  this.phrases = phrases.map(this.say, this)\n}\n```\n\nВ отличие от `forEach` при использовании `map` вам становится доступен chaining. Это значит, что вы можете последовательно применить метод на возвращенный после `map` массив.\n```javascript\n// Получение квадратного корня из чисел с помощью map\n// и вывод результатов в консоль с помощью forEach\n[1, 4, 9, 16].map(Math.sqrt).forEach(function(num) {\n  console.log(num); // 1 2 3 4\n});\n```\n\n## map своими руками\nКак и при создании аналога `forEach` напишем небольшие правила, которыми будем руководствоваться при создании функции `map`:\n\n1. Функция возвращает **новый** массив, оставляя исходный без изменений.\n2. Всё, что возвращает `callback` функция добавляется в новый массив.\n3. Функция принимает три аргумента: массив, по которому будет происходить итерация, `callback` фунцию, которая будет выполнена для каждого элемента массива, и значение, которое будет использовано `callback` функцией в качестве `this`.\n4. `callback` функция, в свою очередь, также работает с тремя аргументами: текущий элемент массива, индекс элемента, ссылка на сам массив.\n\nПравил стало больше, но последними двумя мы уже пользовались при создании функции `each`, а, значит, вы уже знаете, как с ними справиться.\n```javascript\nvar map = function(arr, callback, thisArg) {\n  var i, length = arr.length, results = [];\n  for (i = 0; i < length; i = i + 1) {\n    results.push(callback.call(thisArg, arr[i], i, arr));\n  }\n  return results;\n};\n```\n\nМенять исходный массив нельзя, поэтому нужно создать новый массив в самом начале выполнения функции `map`. Назовём его `results`. В созданный нами массив `results` при кажом выполнении будем добавлять результат выполнения функции `callback` с помощью метода `push`. После завершения последней итерации всё, что остаётся сделать — вернуть массив `results`.\n\nНаписанная нами функция `map` работает точно так же, как и метод массивов `map`, но, как и `each`, может принимать в качестве аргументов любый другие коллекции.\n```javascript\nvar pows = map([10, 20, 30], Math.pow);\nvar frameworks = map(['Knockout', 'Backbone', 'Angular'], function(framework) {\n  return framework.slice(0, 5);\n});\nconsole.log(pows); // [1,20,900]\nconsole.log(frameworks); // [\"Knock\",\"Backb\",\"Angul\"]\n```\n\n**Небольшой совет**: не используйте метод `map` для манипуляций с коллекциями DOM элементов, например, чтобы добавить класс всем элементам коллекции.\n```javascript\n[].map.call(document.links, function(link) {\n  link.classList.add('link');\n});\n```\nДанный код сработает и всем ссылкам будет добавлен класс `link`, но пимимо этого будет создан дополнительный пустой массив, что скажется на производительности при большом объеме итерируемой коллекции. В подобных случаях следует использовать исключительно `forEach`.\n\nТем не менее, `map` отлично подходит для получения данных из DOM коллекций. Например, получение всех `href` атрибутов будет выглядеть следующим образом:\n```javascript\nvar hrefs = [].map.call(document.links, function(link) {\n  return link.href;\n});\n\nconsole.log(hrefs); // [\"http://google.ru\", \"http://jsraccoon.ru\" ...]\n```\n\n## filter\nМетод `filter`, как и следует из названия, служит для фильтрации массива по правилам, заданным в `callback` функции. Так же, как в случае с `map` создаётся **новый** массив, куда добавляются все элементы прошедшие провеку колбэком.\n```javascript\nvar moreThanFive = [1, 20, 4, 2, 5, 3, 24, 6, 45].filter(function(num) {\n  return num > 5;\n});\n\nconsole.log(moreThanFive); // [20,24,6,45]\n```\n\nПри использовании метода `filter` результатом выполнения может быть любое значение, но данные из исходного массива будут добавлены только в том случае, если значение является правдивым. Напомню, что правдивыми значениями являются все, кроме:\n\n1. пустой строки `''`\n2. числа ноль `0`\n3. `false`\n4. `undefined`\n5. `null`\n\nТем не менее, пользоваться подобным способом фильтрации массива не стоит в силу его неочевидности. Поэтому рекомендуется создавать `callback` функцию таким образом, чтобы она всегда возвращала либо `true`, либо `false`.\n\nНемного более сложный пример использования метода `filter`. Допустим, что мы получаем JSON файл с сервера с подобным содержимым:\n```javascript\n[{\"id\":1,\"name\":\"Ernest\",\"email\":\"ebishop0@myspace.com\",\"isCustomer\":false},\n{\"id\":2,\"name\":\"Michael\",\"email\":\"mturner1@multiply.com\",\"isCustomer\":false},\n{\"id\":3,\"name\":\"Mildred\",\"email\":\"mwelch2@google.it\",\"isCustomer\":false},\n{\"id\":4,\"name\":\"Jeremy\",\"email\":\"jwilson3@hostgator.com\",\"isCustomer\":false},\n{\"id\":5,\"name\":\"Judy\",\"email\":\"jellis4@ameblo.jp\",\"isCustomer\":true},\n{\"id\":6,\"name\":\"Judy\",\"email\":\"jrogers5@ow.ly\",\"isCustomer\":false},\n{\"id\":7,\"name\":\"Chris\",\"email\":\"cbennett6@nasa.gov\",\"isCustomer\":false},\n{\"id\":8,\"name\":\"Ruth\",\"email\":\"rmason7@simplemachines.org\",\"isCustomer\":true},\n{\"id\":9,\"name\":\"Justin\",\"email\":\"jmedina8@indiegogo.com\",\"isCustomer\":true},\n{\"id\":10,\"name\":\"Dennis\",\"email\":\"dflores9@g.co\",\"isCustomer\":true}]\n```\n\nПосле получения данных (с помощью AJAX или JSONP, например) мы хотим их отфильтровать, узнав из свойства `isCustomer`, является ли данных человек нашим клиентом или нет. Вот здесь и пригодится метод `filter`:\n```javascript\n// ...\n// Получили данные с сервера и записали их в переменную data\nvar customers = data.filter(function(person) {\n  return person.isCustomer;\n});\n\nconsole.log(customers);\n// [{\"id\":5,\"name\":\"Judy\",\"email\":\"jellis4@ameblo.jp\",\"isCustomer\":true},\n// {\"id\":8,\"name\":\"Ruth\",\"email\":\"rmason7@simplemachines.org\",\"isCustomer\":true},\n// {\"id\":9,\"name\":\"Justin\",\"email\":\"jmedina8@indiegogo.com\",\"isCustomer\":true},\n// {\"id\":10,\"name\":\"Dennis\",\"email\":\"dflores9@g.co\",\"isCustomer\":true}]\n```\n\nИли же можно руководствоваться немного другим, более сложным принципом при выборе цели. Например, мы решили, что если email клиента не начинается с буквы `j`, то он определённо нам не подходит.\n```javascript\n// ...\n// Получили данные с сервера и записали их в переменную data\nvar customers = data.filter(function(person) {\n  return person.email.charAt(0).toLowerCase() === 'j';\n});\nconsole.log(customers);\n// [{\"id\":4,\"name\":\"Jeremy\",\"email\":\"jwilson3@hostgator.com\",\"isCustomer\":false},\n// {\"id\":5,\"name\":\"Judy\",\"email\":\"jellis4@ameblo.jp\",\"isCustomer\":true},\n// {\"id\":6,\"name\":\"Judy\",\"email\":\"jrogers5@ow.ly\",\"isCustomer\":false},\n// {\"id\":9,\"name\":\"Justin\",\"email\":\"jmedina8@indiegogo.com\",\"isCustomer\":true}]\n```\n\n## filter своими руками\nКак и для прошлых функций `map` и `forEach` напишем небольшой свод правил:\n\n1. Функция возвращает **новый** массив, оставляя исходный без изменений.\n2. Данные исходного массива передаются в `callback` функцию. Результат выполнения `callback` функции решает будет ли добавлен данный элемент в новый массив.\n3. Функция принимает три аргумента: массив, по которому будет происходить итерация, `callback` фунцию, которая будет выполнена для каждого элемента массива, и значение, которое будет использовано `callback` функцией в качестве `this`.\n4. `callback` функция, в свою очередь, также работает с тремя аргументами: текущий элемент массива, индекс элемента, ссылка на сам массив.\n\n```javascript\nvar filter = function(arr, callback, thisArg) {\n  var i, length = arr.length, results = [];\n  for (i = 0; i < length; i = i + 1) {\n    if (callback.call(thisArg, arr[i], i, arr)) {\n      results.push(arr[i]);\n    }\n  }\n  return results;\n};\n```\n\nС помощью всё того же метода функций `call` мы вызываем `callback` функцию, но на этот раз всё, что нас будет интересовать — вернула ли функция правдивое значение. Если результат содержит правдивое значение, то данные будут добавлены в массив, если же нет, то просто проигнорированы.\n\nУдостоверимся, что функция `filter` работает, как мы её и задумывали:\n```javascript\nvar strs = ['Hello', ',', 'JavaScript', 'World', '!'];\n\nvar data = filter(strs, function(str) {\n  return str.toLowerCase() !== str;\n});\n\nconsole.log(data); // [\"Hello\",\"JavaScript\",\"World\"]\n```\n\n**Небольшой хак**: чтобы отфильтровать все ложные значения из массива можно воспользоваться конструктором `Boolean`:\n```javascript\nvar data = [32, '', null, 'JavaScript', undefined, 0];\nvar trueData = data.filter(Boolean);\nconsole.log(trueData); // [32,\"JavaScript\"]\n```\n\n## some и every\nМетоды `some` и `every` во многом похожи друг на друга. Оба метода возвращают `true` или `false`. `some` возвращает `true` тогда, когда хотя бы один элемент массива отвечает переданным в `callback` функцию условиям. `every` вернёт `true`, когда все элементы массива отвечают данным условиям. Звучит грозно, но, на самом деле всё очень просто.\n```javascript\nvar fives = [5, 5, 5, 6, 5, 5];\nvar result = fives.every(function(five) {\n  return five === 5;\n});\n\nconsole.log(result); // false — в массиве же есть шестёрка\n\nvar fives = [5, 5, 5, 5, 5, 5];\nvar result = fives.every(function(five) {\n  return five === 5;\n});\n\nconsole.log(result); // true — теперь там только пятёрки, всё хорошо\n\nvar nums = [1, 2, 3, 4, 5];\nvar result = nums.some(function(num) {\n  return num > 3;\n});\n\nconsole.log(result); // true — в массиве есть хотя бы одно значение больше 3\n\nvar nums = [10, 20, 30, 40, 50];\nvar result = nums.some(function(num) {\n  return num < 5;\n});\n\nconsole.log(result); // false — в массиве нет ни одного значения меньше 5\n```\n\nМетоды `some` и `every` очень удобно использовать вместе с методом `filter` для вложенных массивов. Чтобы понять, как это работает, опять представим, что мы получили данные с сервера в виде JSON файла, который содержит массив объектов (наших покупателей). У каждого покупателя есть свойство `purchases`, которое представляет собой список приобретённых покупателем товаров в нашем магазине ранее.\n```javascript\n[{\"name\":\"Wanda\",\"email\":\"wjenkins0@irs.gov\",\"purchases\":['iPhone', 'dishwasher', 'cucumbers']},\n{\"name\":\"Nicholas\",\"email\":\"nkennedy1@ox.ac.uk\",\"purchases\":['tomatoes', 'toster', 'grill']},\n{\"name\":\"Paula\",\"email\":\"pstephens2@boston.com\",\"purchases\":['apples', 'Macbook', 'iPhone']},\n{\"name\":\"Fred\",\"email\":\"fpeterson3@reuters.com\",\"purchases\":['beef', 'pork', 'cheese']},\n{\"name\":\"Andrew\",\"email\":\"awagner4@weebly.com\",\"purchases\":['cottage cheese', 'cream', 'candies']},\n{\"name\":\"Steven\",\"email\":\"sgonzales5@mashable.com\",\"purchases\":['iMac', 'Android phone', 'Windows 10']},\n{\"name\":\"Harry\",\"email\":\"hallen6@nasa.gov\",\"purchases\":['green grape', 'tomatoes', 'potatoes']},\n{\"name\":\"Bonnie\",\"email\":\"breyes7@kickstarter.com\",\"purchases\":['Windows 10', 'dishwasher', 'grill']},\n{\"name\":\"Lisa\",\"email\":\"lgreene8@spotify.com\",\"purchases\":['pork', 'iMac', 'cheese']},\n{\"name\":\"Wayne\",\"email\":\"wramos9@yahoo.com\",\"purchases\":['apples', 'cream', 'candies']}]\n```\n\nЧтобы понять, какие клиенты нам принесли больше всего прибыли, мы хотим их отфильтровать и посмотреть, кто из них покупал у нас технику от Apple (iPhone, Macbook или iMac). Метод `some` поможет сделать это с помощью всего нескольких строк кода.\n```javascript\n// ...\n// Получили данные с сервера и записали их в переменную data\nvar customers = data.filter(function(customer) {\n  return customer.purchases.some(function(purchase) {\n    return purchase === 'iPhone' || purchase === 'Macbook' || purchase === 'iMac';\n  });\n});\n\nconsole.log(customers);\n// [{\"name\":\"Wanda\",\"email\":\"wjenkins0@irs.gov\",\"purchases\":[\"iPhone\",\"dishwasher\",\"cucumbers\"]},\n// {\"name\":\"Paula\",\"email\":\"pstephens2@boston.com\",\"purchases\":[\"apples\",\"Macbook\",\"iPhone\"]},\n// {\"name\":\"Steven\",\"email\":\"sgonzales5@mashable.com\",\"purchases\":[\"iMac\",\"Android phone\",\"Windows 10\"]},\n// {\"name\":\"Lisa\",\"email\":\"lgreene8@spotify.com\",\"purchases\":[\"pork\",\"iMac\",\"cheese\"]}]\n```\n\n## some и every своими руками\nПравила:\n\n1. Функция возвращает только `true` или `false`\n2. Каждое значение передаётся в `callback` функцию и на результате её выполнения для **всех** элементов массива решается, какой будет результат.\n3. Функция принимает три аргумента: массив, по которому будет происходить итерация, `callback` фунцию, которая будет выполнена для каждого элемента массива, и значение, которое будет использовано `callback` функцией в качестве `this`.\n4. `callback` функция, в свою очередь, также работает с тремя аргументами: текущий элемент массива, индекс элемента, ссылка на сам массив.\n\n```javascript\nvar some = function(arr, callback, thisArg) {\n  var i, length = arr.length;\n  for (i = 0; i < length; i = i + 1) {\n    if (callback.call(thisArg, arr[i], i, arr)) {\n      return true;\n    }\n  }\n  return false;\n};\n```\n\nФункция `some` при каждой итерации проверяет, является ли результат выполнения `callback` функции правдивым. Если она находит хотя бы один правдивый результат, то прерывает своё выполнение и сразу возвращает `true`.\n\n```javascript\nvar every = function(arr, callback, thisArg) {\n  var i, length = arr.length;\n  for (i = 0; i < length; i = i + 1) {\n    if (!callback.call(thisArg, arr[i], i, arr)) {\n      return false;\n    }\n  }\n  return true;\n};\n```\n\nФункция `every` построена по противоположному принципу. Если хотя бы одно значение не является верным, то сразу же возвращается `false` без дальнейшего перебирания массива.\n\nФункции `every` и `some` работают идентично соответствующим им методам и будут давать одинаковые резутаты. Тем не менее, написанные нами функции работают лучше нативных методов. Почему? Используя методы массивов `some` и `every` вы подразумеваете, что `callback` функция будет выполнена для всех элементов без исключения. Но, может оказаться так, что первый элемент в массиве уже содержит нужные нам данные и итерация по всем остальным будет абсолютно бесполезной. В написанных нами функциях таких итераций не будет — когда будет найдено искомое значение функция сразу же прекратит своё выполнение. Подобный подход может дать достаточно ощутимый прирост производительности при работе с большими объемами данных, например, с JSON файлами содержащими несколько тысяч объектов.\n\n## reduce\n`callback` функция всех рассмотренных выше методов массивов работает с одинаковым набором данных: значением, индексом и массивом. Метод `reduce` не такой, как все. Принцип его работы немного отличается от всех остальных методов. Начнём сразу с примера:\n```javascript\nvar nums = [10, 20, 30, 40, 50];\nvar sum = nums.reduce(function(result, num) {\n  return result + num;\n}, 0);\n\nconsole.log(sum); // 150 сумма всех элементов массива\n```\n\nМетод `reduce` принимает два аргумента `callback` функцию и начальное значение, которое будет присвоено аргументу `result` в примере выше при первой итерации. `callback` функция принимает целых 4 аргумента: промежуточное значение (аргумент `result` в примере выше), элемент массива, индекс элемента и сам массив. После каждой итерации в промежуточное значение записываются новые данные, которые берутся из результата выполнения функции `callback` при прошлой итерации:\n```javascript\nvar nums = [10, 20, 30, 40, 50];\nvar sum = nums.reduce(function(result, num) {\n  console.log(result);\n  return result + num;\n}, 0);\n\n// Будет выведено в консоль\n// 0 начальное значение\n// 10 начальное значение + первый элемент в массиве = промежуточное значение\n// 30 промежуточное значение + второй элемент в массиве = промежуточное значение\n// 60 и так далее\n// 100\n```\n\nРазумеется, `reduce` может работать с любыми типами данных, не только с числами. Пример со строками (в данном случае в качестве начального значения стоит передавать пустую строку):\n```javascript\nvar strs = ['JavaScript', 'is', 'awesome'];\nvar result = strs.reduce(function(phrase, word, index) {\n  // Перед первым словом не надо ставить пробел\n  return (index === 0) ? phrase + word : phrase + ' ' + word;\n}, '');\n\nconsole.log(result); // JavaScript is awesome\n```\n\nПример с многомерным массивом (начинаем с пустого массива):\n```javascript\nvar arrs = [[1, 2, 3], [4, 5], [6], [7, 8], [9, 10, 11]];\nvar concat = arrs.reduce(function(result, current) {\n  return result.concat(current);\n}, []);\n\nconsole.log(concat); // [1,2,3,4,5,6,7,8,9,10,11]\n```\n\n## reduce своими руками\nВы уже знаете — у нас есть правила:\n\n1. Функция принимает три аргумента: массив, `callback` функцию, начальное значение.\n2. После каждой итерации в промежуточное значение перезаписывается значением, полученным в результате выполнения `callback` функции.\n3.`callback` функция принимает четыре аргумента: промежуточное значение, текущий элемент массива, индекс элемента, ссылка на сам массив.\n4. Явно указать значение `this` нельзя.\n\n```javascript\nvar reduce = function(arr, callback, startValue) {\n  var i, length = arr.length, result = startValue;\n  for (i = 0; i < length; i = i + 1) {\n    result = callback.call(null, result, arr[i], i, arr);\n  }\n  return result;\n};\n```\n\nВ нативном методе указывать значение `this` нельзя, поэтому вместо введения в функцию ещё одного аргумента `thisArg` мы просто передаём `null` в вызов функции.\n\nПротестируем написанную нами функцию `reduce` на предыдущих примерах, чтобы убедиться, что всё работает, как мы и ожидаем.\n```javascript\nvar arrs = [[1, 2, 3], [4, 5], [6], [7, 8], [9, 10, 11]];\nvar strs = ['JavaScript', 'is', 'awesome'];\n\nvar strResults = reduce(strs, function(phrase, word, index) {\n  return (index === 0) ? phrase + word : phrase + ' ' + word;\n}, '');\n\nvar arrResults = reduce(arrs, function(result, current) {\n  return result.concat(current);\n}, []);\n\nconsole.log(strResults); // JavaScript is awesome\nconsole.log(arrResults); // [1,2,3,4,5,6,7,8,9,10,11]\n```\n","source":"_posts/fn-array-methods.md","raw":"---\ntitle: \"Перебирающие методы массивов изнутри\"\nauthor: rtivital\ndate: \"2016-04-25\"\ncategories: Статья\ntags: [FN, JavaScript]\n---\n\nМетоды массивов `forEach`, `map`, `filter`, `some`, `every` и `reduce` являются неотъемлимой частью функционального программирования на JavaScript. В этой статье подробно рассмотрим применение каждого из них, а также их реализацию в виде функций.\n<!--MORE-->\n## forEach\nСамый простой способ разобраться, как работают функции высшего порядка, принимающие callback'и, — самостоятельно переписать несколько нативных методов. Начнём с самого простого метода `Array.prototype.forEach`. Метод массивов `forEach` принимает два аргумента: первый (обязательный) — `callback` функция, которая будет выполнена для каждого элемента массива один раз и второй (необязательный) — значение, которое будет использовано в качестве `this` при вызове функции `callback`. Работает это следующим образом:\n```javascript\n['JavaScript', 'is', 'awesome'].forEach(function(item, index, arr) {\n  console.log(item, index, arr);\n});\n// Выведет в консоль\n// JavaScript 0 [\"JavaScript\",\"is\",\"awesome\"]\n// is 1 [\"JavaScript\",\"is\",\"awesome\"]\n// awesome 2 [\"JavaScript\",\"is\",\"awesome\"]\n```\n\nВ `callback` функцию передаётся три аргумента: `item`, соответствующий элементу массива, `index`, равный номеру элемента в массиве, и `arr` — ссылка на массив. Таким образом, справедливо следующее выражение `arr[index] === item`. Аргументам передаваемым в `callback` функцию можно давать разные названия в зависимости от контекста выполнения — выполнение `callback` функции от этого не изменится:\n```javascript\n[1, 2, 3, 4, 5].forEach(function(num, i, nums) {\n  console.log(num * 2); // 2 4 6 8 10\n});\n```\n\nКак я писал выше, помимо `callback` функции метод `forEach` принимает ещё один аргумент — значение, которое будет использовано в качестве `this` при вызове функции `callback`. Зачем это может понадобиться? По умолчанию `this` не определён, то есть равен `undefined`. В некоторых ситуациях, особенно при работе с функциями конструкторами, необходимо задать контекст выполнения `callback` функции:\n```javascript\nvar Person = function(name) {\n  this.name = name;\n};\n\nPerson.prototype.say = function(phrase) {\n  console.log(this.name + ' says ' + phrase);\n}\n\nPerson.prototype.mumble = function(phrases) {\n  phrases.forEach(function(phrase) {\n    this.say(phrase);\n  });\n}\n\nvar johnDoe = new Person('John Doe');\njohnDoe.mumble(['Hello, World!', 'JS is great', 'I\\'m designer and i don\\'t have job']);\n```\n\nПодобный код, на первый взгляд, может оказаться полностью рабочим. Тем не менее, после его выполнения всё, что мы увидим будет ошибка `Cannot read property 'say' of undefined`. Данная ошибка показывает, что при выполнении метода `forEach` на передаваемом в метод `mumble` массиве `phrases` не задаётся контекст испольнения `callback` функции. Проще говоря, `callback` функция пытается выполнить подобный код `undefined[say](words)`. Решается данная проблема элементарно — передётся второй аргумент в метод `forEach`, который и указывает ему, что брать за `this`:\n```javascript\n// ...\nPerson.prototype.mumble = function(arr) {\n  arr.forEach(function(words){\n    this.say(words);\n  }, this);\n}\n\nvar johnDoe = new Person('John Doe');\njohnDoe.mumble(['Hello, World!', 'JS is great', 'I\\'m designer and i don\\'t have job']);\n\n// Выведет в консоль\n// John Doe says Hello, World!\n// John Doe says JS is great\n// John Doe says I'm designer and i don't have job\n```\n\n## forEach своими руками\nТеперь, когда вы знаете, как работает `forEach`, настало время написать функцию, которая делает всё тоже самое. При создании функции `each` будем руководствоваться тремя правилами:\n\n1. Функция принимает три аргумента: массив, по которому будет происходить итерация, `callback` фунцию, которая будет выполнена для каждого элемента массива, и значение, которое будет использовано `callback` функцией в качестве `this`.\n2. `callback` функция, в свою очередь, также работает с тремя аргументами: текущий элемент массива, индекс элемента, ссылка на сам массив.\n3. Функция ничего не возвращает.\n\nСамое очевидное решение: используя цикл `for` перебрать каждый элемент массива и выполнить передаваемую `callback` функцию с каждым. Сделать это очень просто:\n```javascript\nvar each = function(arr, callback, thisArg) {\n  var i, length = arr.length;\n  for (i = 0; i < length; i = i + 1) {\n    callback(arr[i], i, arr);\n  }\n};\n```\n\nФункция `each` будет отлично работать, за исключением того, что не соблюдается часть первого правила — для `callback` функции нельзя задать контекст, то есть нельзя присвоить значение `this`:\n```javascript\neach([1, 2, 3], function(num, i, nums) {\n  console.log('Number: ' + num + ', index: ' + i + ',', nums)\n});\n\n// Выведет в консоль\n// Number: 1, index: 0, [1,2,3]\n// Number: 2, index: 1, [1,2,3]\n// Number: 3, index: 2, [1,2,3]\n```\n\nЧтобы можно было осуществлять передачу ключевого слова `this` в функцию `each` достаточно воспользоваться методом функций `call`, который позволяет вызвать функцию и явно указать, на что будет указывать ключевое слово `this`.\n```javascript\nvar each = function(arr, callback, thisArg) {\n  var i, length = arr.length;\n  for (i = 0; i < length; i = i + 1) {\n    callback.call(thisArg, arr[i], i, arr);\n  }\n};\n```\n\nТеперь функция `each` работает с массивами в точности так, как и метод `forEach`. Чтобы её протестировать, можно запустить её вместе с кодом из предыдущего примера.\n```javascript\nvar Person = function(name) {\n  this.name = name;\n};\n\nPerson.prototype.say = function(phrase) {\n  console.log(this.name + ' says ' + phrase);\n}\n\nPerson.prototype.mumble = function(phrases) {\n  each(phrases, function(phrase) {\n    this.say(phrase);\n  }, this);\n}\n\nvar johnDoe = new Person('John Doe');\njohnDoe.mumble(['Hello, World!', 'JS is great', 'I\\'m designer and i don\\'t have job']);\n\n// Выведет в консоль\n// John Doe says Hello, World!\n// John Doe says JS is great\n// John Doe says I'm designer and i don't have job\n```\n\nНесмотря на кажущуюся одинаковость метода `forEach` и написанной нами выше функции `each`, между ними есть одно очень важное различие: метод `forEach` работает **только с массивами**, в то время как функция `each` может также успешно работать с **любыми коллекциями**.\n\nСкорее всего, вы уже видели ранее подобную конструкцию, которую использую многие JavaScript разработчики для итерации по всем элементам из DOM коллекции:\n```javascript\nvar links = document.links; // коллекция всех ссылок на странице\n[].forEach.call(links, function(link) {\n  // Добавление класса link-active для всех ссылок на странице\n  link.classList.add('link-active');\n});\n```\n\nПодобная конструкция может ввести в замешательство практически любого программиста, который раньше не использовал её сам. Подробное объяснение, как именно она работает можно найти в [этом вопросе](http://stackoverflow.com/questions/16053357/what-does-foreach-call-do-in-javascript) на Stackoverflow. Нужна она лишь для того, чтобы провести итерацию по всем элементам выбранной DOM коллекции и выполнить `callback` функцию для каждого из них. При использовании написанной нами функции `each` надобности в такой хитрой конструкции нет, так как она поддерживает работу не только с массивами, но и с любыми коллекциями, в том числе и коллекциями DOM элементов:\n```javascript\nvar links = document.links; // коллекция всех ссылок на странице\neach(links, function(link) {\n  // Добавление класса link-active для всех ссылок на странице\n  link.classList.add('link-active');\n});\n```\n\nКогда появится широкая поддежка **ES6** метод `forEach` можно будет использовать с DOM коллекциями более простым способом с помощью оператора [Spread](http://jsraccoon.ru/es6-spread-rest/):\n```javascript\n[...links].forEach(function(link) {\n  link.classList.add('link-active');\n});\n```\n\n## map\n\nМетод массивов `map` похож по своей функциональности на `forEach`, но результат выполнения `callback` функции добавляется в новый массив, который возвращается после последней итерации. Другими словами, результатом метода `map` всегда является **новый** массив с результатами выполнения функции `callback` на исходном массиве.\n```javascript\nvar nums = [10, 20, 30, 40];\nvar results = nums.map(function(num, index, arr) {\n  // Возведение числа в степень соответсвующую его индексу в массиве\n  return Math.pow(num, index);\n});\n\n// Исходный массив nums не изменяется\nconsole.log(nums); // [10,20,30,40]\n// результат выполнения map, записанный в переменную\nconsole.log(results); // [1,20,900,64000]\n```\n\nТакже, как и в случае с `forEach` `map` помимо `callback` функции принимает второй параметр, который позволяет задать контекст и явно указать `this`:\n```javascript\nvar Person = function(name) {\n  this.name = name;\n  this.phrases = null;\n};\n\nPerson.prototype.say = function(phrase) {\n  return this.name + ' says ' + phrase;\n}\n\nPerson.prototype.grabPhrases = function(phrases) {\n  this.phrases = phrases.map(function(phrase){\n    // Добавление изменённой строки в новый массив\n    return this.say(phrase);\n  }, this)\n}\n\nvar johnDoe = new Person('John Doe');\njohnDoe.grabPhrases(['Hello, World!', 'JS is great', 'I\\'m designer and i don\\'t have job']);\nconsole.log(johnDoe.phrases);\n// [\"John Doe says Hello, World!\",\"John Doe says JS is great\",\"John Doe says I'm designer and i don't have job\"]\n```\n\nКак вы могли заметить, при использовании `map` и `forEach` всегда использовалась анонимная функция в качестве `callback`. Это совсем не обязательно. Вы можете объвить функцию, которую хотите использовать в качестве `callback` заранее, а затем просто передать её в качестве параметра.\n```javascript\nvar slice = function(str) {\n  // вернуть первые пять символов из строки\n  return str.slice(0, 5);\n};\n\nvar frameworks = ['Knockout', 'Backbone', 'Angular'].map(slice);\n\nconsole.log(frameworks); // [\"Knock\",\"Backb\",\"Angul\"]\n```\n\nВ некоторых ситуациях можно вообще не создавать отдельную функцию и пользоваться нативными методами. Пример выше, в котором каждое число в массиве возводилось в степень, соответствующую своему индексу, можно значительно сократить:\n```javascript\n// Длинный вариант с ненужной анонимной функцией\nvar nums = [10, 20, 30, 40];\nvar results = nums.map(function(num, index, arr) {\n  return Math.pow(num, index);\n});\n\n// Короткий вариант, ничего лишнего\nvar nums = [10, 20, 30, 40];\nvar results = nums.map(Math.pow);\n```\n\nПередвая `callback` функцию подобным образом вы не теряете возможность явно указать `this`. Таким образом, метод `grabPhrases` из функции конструктора `Person` также можно немного сократить:\n```javascript\nPerson.prototype.grabPhrases = function(phrases) {\n  // Ненужная анонимная функция\n  this.phrases = phrases.map(function(phrase) {\n    return this.say(phrase);\n  }, this);\n}\n// Выполнение функции this.say для каждого элемента массива\nPerson.prototype.grabPhrases = function(phrases) {\n  this.phrases = phrases.map(this.say, this)\n}\n```\n\nВ отличие от `forEach` при использовании `map` вам становится доступен chaining. Это значит, что вы можете последовательно применить метод на возвращенный после `map` массив.\n```javascript\n// Получение квадратного корня из чисел с помощью map\n// и вывод результатов в консоль с помощью forEach\n[1, 4, 9, 16].map(Math.sqrt).forEach(function(num) {\n  console.log(num); // 1 2 3 4\n});\n```\n\n## map своими руками\nКак и при создании аналога `forEach` напишем небольшие правила, которыми будем руководствоваться при создании функции `map`:\n\n1. Функция возвращает **новый** массив, оставляя исходный без изменений.\n2. Всё, что возвращает `callback` функция добавляется в новый массив.\n3. Функция принимает три аргумента: массив, по которому будет происходить итерация, `callback` фунцию, которая будет выполнена для каждого элемента массива, и значение, которое будет использовано `callback` функцией в качестве `this`.\n4. `callback` функция, в свою очередь, также работает с тремя аргументами: текущий элемент массива, индекс элемента, ссылка на сам массив.\n\nПравил стало больше, но последними двумя мы уже пользовались при создании функции `each`, а, значит, вы уже знаете, как с ними справиться.\n```javascript\nvar map = function(arr, callback, thisArg) {\n  var i, length = arr.length, results = [];\n  for (i = 0; i < length; i = i + 1) {\n    results.push(callback.call(thisArg, arr[i], i, arr));\n  }\n  return results;\n};\n```\n\nМенять исходный массив нельзя, поэтому нужно создать новый массив в самом начале выполнения функции `map`. Назовём его `results`. В созданный нами массив `results` при кажом выполнении будем добавлять результат выполнения функции `callback` с помощью метода `push`. После завершения последней итерации всё, что остаётся сделать — вернуть массив `results`.\n\nНаписанная нами функция `map` работает точно так же, как и метод массивов `map`, но, как и `each`, может принимать в качестве аргументов любый другие коллекции.\n```javascript\nvar pows = map([10, 20, 30], Math.pow);\nvar frameworks = map(['Knockout', 'Backbone', 'Angular'], function(framework) {\n  return framework.slice(0, 5);\n});\nconsole.log(pows); // [1,20,900]\nconsole.log(frameworks); // [\"Knock\",\"Backb\",\"Angul\"]\n```\n\n**Небольшой совет**: не используйте метод `map` для манипуляций с коллекциями DOM элементов, например, чтобы добавить класс всем элементам коллекции.\n```javascript\n[].map.call(document.links, function(link) {\n  link.classList.add('link');\n});\n```\nДанный код сработает и всем ссылкам будет добавлен класс `link`, но пимимо этого будет создан дополнительный пустой массив, что скажется на производительности при большом объеме итерируемой коллекции. В подобных случаях следует использовать исключительно `forEach`.\n\nТем не менее, `map` отлично подходит для получения данных из DOM коллекций. Например, получение всех `href` атрибутов будет выглядеть следующим образом:\n```javascript\nvar hrefs = [].map.call(document.links, function(link) {\n  return link.href;\n});\n\nconsole.log(hrefs); // [\"http://google.ru\", \"http://jsraccoon.ru\" ...]\n```\n\n## filter\nМетод `filter`, как и следует из названия, служит для фильтрации массива по правилам, заданным в `callback` функции. Так же, как в случае с `map` создаётся **новый** массив, куда добавляются все элементы прошедшие провеку колбэком.\n```javascript\nvar moreThanFive = [1, 20, 4, 2, 5, 3, 24, 6, 45].filter(function(num) {\n  return num > 5;\n});\n\nconsole.log(moreThanFive); // [20,24,6,45]\n```\n\nПри использовании метода `filter` результатом выполнения может быть любое значение, но данные из исходного массива будут добавлены только в том случае, если значение является правдивым. Напомню, что правдивыми значениями являются все, кроме:\n\n1. пустой строки `''`\n2. числа ноль `0`\n3. `false`\n4. `undefined`\n5. `null`\n\nТем не менее, пользоваться подобным способом фильтрации массива не стоит в силу его неочевидности. Поэтому рекомендуется создавать `callback` функцию таким образом, чтобы она всегда возвращала либо `true`, либо `false`.\n\nНемного более сложный пример использования метода `filter`. Допустим, что мы получаем JSON файл с сервера с подобным содержимым:\n```javascript\n[{\"id\":1,\"name\":\"Ernest\",\"email\":\"ebishop0@myspace.com\",\"isCustomer\":false},\n{\"id\":2,\"name\":\"Michael\",\"email\":\"mturner1@multiply.com\",\"isCustomer\":false},\n{\"id\":3,\"name\":\"Mildred\",\"email\":\"mwelch2@google.it\",\"isCustomer\":false},\n{\"id\":4,\"name\":\"Jeremy\",\"email\":\"jwilson3@hostgator.com\",\"isCustomer\":false},\n{\"id\":5,\"name\":\"Judy\",\"email\":\"jellis4@ameblo.jp\",\"isCustomer\":true},\n{\"id\":6,\"name\":\"Judy\",\"email\":\"jrogers5@ow.ly\",\"isCustomer\":false},\n{\"id\":7,\"name\":\"Chris\",\"email\":\"cbennett6@nasa.gov\",\"isCustomer\":false},\n{\"id\":8,\"name\":\"Ruth\",\"email\":\"rmason7@simplemachines.org\",\"isCustomer\":true},\n{\"id\":9,\"name\":\"Justin\",\"email\":\"jmedina8@indiegogo.com\",\"isCustomer\":true},\n{\"id\":10,\"name\":\"Dennis\",\"email\":\"dflores9@g.co\",\"isCustomer\":true}]\n```\n\nПосле получения данных (с помощью AJAX или JSONP, например) мы хотим их отфильтровать, узнав из свойства `isCustomer`, является ли данных человек нашим клиентом или нет. Вот здесь и пригодится метод `filter`:\n```javascript\n// ...\n// Получили данные с сервера и записали их в переменную data\nvar customers = data.filter(function(person) {\n  return person.isCustomer;\n});\n\nconsole.log(customers);\n// [{\"id\":5,\"name\":\"Judy\",\"email\":\"jellis4@ameblo.jp\",\"isCustomer\":true},\n// {\"id\":8,\"name\":\"Ruth\",\"email\":\"rmason7@simplemachines.org\",\"isCustomer\":true},\n// {\"id\":9,\"name\":\"Justin\",\"email\":\"jmedina8@indiegogo.com\",\"isCustomer\":true},\n// {\"id\":10,\"name\":\"Dennis\",\"email\":\"dflores9@g.co\",\"isCustomer\":true}]\n```\n\nИли же можно руководствоваться немного другим, более сложным принципом при выборе цели. Например, мы решили, что если email клиента не начинается с буквы `j`, то он определённо нам не подходит.\n```javascript\n// ...\n// Получили данные с сервера и записали их в переменную data\nvar customers = data.filter(function(person) {\n  return person.email.charAt(0).toLowerCase() === 'j';\n});\nconsole.log(customers);\n// [{\"id\":4,\"name\":\"Jeremy\",\"email\":\"jwilson3@hostgator.com\",\"isCustomer\":false},\n// {\"id\":5,\"name\":\"Judy\",\"email\":\"jellis4@ameblo.jp\",\"isCustomer\":true},\n// {\"id\":6,\"name\":\"Judy\",\"email\":\"jrogers5@ow.ly\",\"isCustomer\":false},\n// {\"id\":9,\"name\":\"Justin\",\"email\":\"jmedina8@indiegogo.com\",\"isCustomer\":true}]\n```\n\n## filter своими руками\nКак и для прошлых функций `map` и `forEach` напишем небольшой свод правил:\n\n1. Функция возвращает **новый** массив, оставляя исходный без изменений.\n2. Данные исходного массива передаются в `callback` функцию. Результат выполнения `callback` функции решает будет ли добавлен данный элемент в новый массив.\n3. Функция принимает три аргумента: массив, по которому будет происходить итерация, `callback` фунцию, которая будет выполнена для каждого элемента массива, и значение, которое будет использовано `callback` функцией в качестве `this`.\n4. `callback` функция, в свою очередь, также работает с тремя аргументами: текущий элемент массива, индекс элемента, ссылка на сам массив.\n\n```javascript\nvar filter = function(arr, callback, thisArg) {\n  var i, length = arr.length, results = [];\n  for (i = 0; i < length; i = i + 1) {\n    if (callback.call(thisArg, arr[i], i, arr)) {\n      results.push(arr[i]);\n    }\n  }\n  return results;\n};\n```\n\nС помощью всё того же метода функций `call` мы вызываем `callback` функцию, но на этот раз всё, что нас будет интересовать — вернула ли функция правдивое значение. Если результат содержит правдивое значение, то данные будут добавлены в массив, если же нет, то просто проигнорированы.\n\nУдостоверимся, что функция `filter` работает, как мы её и задумывали:\n```javascript\nvar strs = ['Hello', ',', 'JavaScript', 'World', '!'];\n\nvar data = filter(strs, function(str) {\n  return str.toLowerCase() !== str;\n});\n\nconsole.log(data); // [\"Hello\",\"JavaScript\",\"World\"]\n```\n\n**Небольшой хак**: чтобы отфильтровать все ложные значения из массива можно воспользоваться конструктором `Boolean`:\n```javascript\nvar data = [32, '', null, 'JavaScript', undefined, 0];\nvar trueData = data.filter(Boolean);\nconsole.log(trueData); // [32,\"JavaScript\"]\n```\n\n## some и every\nМетоды `some` и `every` во многом похожи друг на друга. Оба метода возвращают `true` или `false`. `some` возвращает `true` тогда, когда хотя бы один элемент массива отвечает переданным в `callback` функцию условиям. `every` вернёт `true`, когда все элементы массива отвечают данным условиям. Звучит грозно, но, на самом деле всё очень просто.\n```javascript\nvar fives = [5, 5, 5, 6, 5, 5];\nvar result = fives.every(function(five) {\n  return five === 5;\n});\n\nconsole.log(result); // false — в массиве же есть шестёрка\n\nvar fives = [5, 5, 5, 5, 5, 5];\nvar result = fives.every(function(five) {\n  return five === 5;\n});\n\nconsole.log(result); // true — теперь там только пятёрки, всё хорошо\n\nvar nums = [1, 2, 3, 4, 5];\nvar result = nums.some(function(num) {\n  return num > 3;\n});\n\nconsole.log(result); // true — в массиве есть хотя бы одно значение больше 3\n\nvar nums = [10, 20, 30, 40, 50];\nvar result = nums.some(function(num) {\n  return num < 5;\n});\n\nconsole.log(result); // false — в массиве нет ни одного значения меньше 5\n```\n\nМетоды `some` и `every` очень удобно использовать вместе с методом `filter` для вложенных массивов. Чтобы понять, как это работает, опять представим, что мы получили данные с сервера в виде JSON файла, который содержит массив объектов (наших покупателей). У каждого покупателя есть свойство `purchases`, которое представляет собой список приобретённых покупателем товаров в нашем магазине ранее.\n```javascript\n[{\"name\":\"Wanda\",\"email\":\"wjenkins0@irs.gov\",\"purchases\":['iPhone', 'dishwasher', 'cucumbers']},\n{\"name\":\"Nicholas\",\"email\":\"nkennedy1@ox.ac.uk\",\"purchases\":['tomatoes', 'toster', 'grill']},\n{\"name\":\"Paula\",\"email\":\"pstephens2@boston.com\",\"purchases\":['apples', 'Macbook', 'iPhone']},\n{\"name\":\"Fred\",\"email\":\"fpeterson3@reuters.com\",\"purchases\":['beef', 'pork', 'cheese']},\n{\"name\":\"Andrew\",\"email\":\"awagner4@weebly.com\",\"purchases\":['cottage cheese', 'cream', 'candies']},\n{\"name\":\"Steven\",\"email\":\"sgonzales5@mashable.com\",\"purchases\":['iMac', 'Android phone', 'Windows 10']},\n{\"name\":\"Harry\",\"email\":\"hallen6@nasa.gov\",\"purchases\":['green grape', 'tomatoes', 'potatoes']},\n{\"name\":\"Bonnie\",\"email\":\"breyes7@kickstarter.com\",\"purchases\":['Windows 10', 'dishwasher', 'grill']},\n{\"name\":\"Lisa\",\"email\":\"lgreene8@spotify.com\",\"purchases\":['pork', 'iMac', 'cheese']},\n{\"name\":\"Wayne\",\"email\":\"wramos9@yahoo.com\",\"purchases\":['apples', 'cream', 'candies']}]\n```\n\nЧтобы понять, какие клиенты нам принесли больше всего прибыли, мы хотим их отфильтровать и посмотреть, кто из них покупал у нас технику от Apple (iPhone, Macbook или iMac). Метод `some` поможет сделать это с помощью всего нескольких строк кода.\n```javascript\n// ...\n// Получили данные с сервера и записали их в переменную data\nvar customers = data.filter(function(customer) {\n  return customer.purchases.some(function(purchase) {\n    return purchase === 'iPhone' || purchase === 'Macbook' || purchase === 'iMac';\n  });\n});\n\nconsole.log(customers);\n// [{\"name\":\"Wanda\",\"email\":\"wjenkins0@irs.gov\",\"purchases\":[\"iPhone\",\"dishwasher\",\"cucumbers\"]},\n// {\"name\":\"Paula\",\"email\":\"pstephens2@boston.com\",\"purchases\":[\"apples\",\"Macbook\",\"iPhone\"]},\n// {\"name\":\"Steven\",\"email\":\"sgonzales5@mashable.com\",\"purchases\":[\"iMac\",\"Android phone\",\"Windows 10\"]},\n// {\"name\":\"Lisa\",\"email\":\"lgreene8@spotify.com\",\"purchases\":[\"pork\",\"iMac\",\"cheese\"]}]\n```\n\n## some и every своими руками\nПравила:\n\n1. Функция возвращает только `true` или `false`\n2. Каждое значение передаётся в `callback` функцию и на результате её выполнения для **всех** элементов массива решается, какой будет результат.\n3. Функция принимает три аргумента: массив, по которому будет происходить итерация, `callback` фунцию, которая будет выполнена для каждого элемента массива, и значение, которое будет использовано `callback` функцией в качестве `this`.\n4. `callback` функция, в свою очередь, также работает с тремя аргументами: текущий элемент массива, индекс элемента, ссылка на сам массив.\n\n```javascript\nvar some = function(arr, callback, thisArg) {\n  var i, length = arr.length;\n  for (i = 0; i < length; i = i + 1) {\n    if (callback.call(thisArg, arr[i], i, arr)) {\n      return true;\n    }\n  }\n  return false;\n};\n```\n\nФункция `some` при каждой итерации проверяет, является ли результат выполнения `callback` функции правдивым. Если она находит хотя бы один правдивый результат, то прерывает своё выполнение и сразу возвращает `true`.\n\n```javascript\nvar every = function(arr, callback, thisArg) {\n  var i, length = arr.length;\n  for (i = 0; i < length; i = i + 1) {\n    if (!callback.call(thisArg, arr[i], i, arr)) {\n      return false;\n    }\n  }\n  return true;\n};\n```\n\nФункция `every` построена по противоположному принципу. Если хотя бы одно значение не является верным, то сразу же возвращается `false` без дальнейшего перебирания массива.\n\nФункции `every` и `some` работают идентично соответствующим им методам и будут давать одинаковые резутаты. Тем не менее, написанные нами функции работают лучше нативных методов. Почему? Используя методы массивов `some` и `every` вы подразумеваете, что `callback` функция будет выполнена для всех элементов без исключения. Но, может оказаться так, что первый элемент в массиве уже содержит нужные нам данные и итерация по всем остальным будет абсолютно бесполезной. В написанных нами функциях таких итераций не будет — когда будет найдено искомое значение функция сразу же прекратит своё выполнение. Подобный подход может дать достаточно ощутимый прирост производительности при работе с большими объемами данных, например, с JSON файлами содержащими несколько тысяч объектов.\n\n## reduce\n`callback` функция всех рассмотренных выше методов массивов работает с одинаковым набором данных: значением, индексом и массивом. Метод `reduce` не такой, как все. Принцип его работы немного отличается от всех остальных методов. Начнём сразу с примера:\n```javascript\nvar nums = [10, 20, 30, 40, 50];\nvar sum = nums.reduce(function(result, num) {\n  return result + num;\n}, 0);\n\nconsole.log(sum); // 150 сумма всех элементов массива\n```\n\nМетод `reduce` принимает два аргумента `callback` функцию и начальное значение, которое будет присвоено аргументу `result` в примере выше при первой итерации. `callback` функция принимает целых 4 аргумента: промежуточное значение (аргумент `result` в примере выше), элемент массива, индекс элемента и сам массив. После каждой итерации в промежуточное значение записываются новые данные, которые берутся из результата выполнения функции `callback` при прошлой итерации:\n```javascript\nvar nums = [10, 20, 30, 40, 50];\nvar sum = nums.reduce(function(result, num) {\n  console.log(result);\n  return result + num;\n}, 0);\n\n// Будет выведено в консоль\n// 0 начальное значение\n// 10 начальное значение + первый элемент в массиве = промежуточное значение\n// 30 промежуточное значение + второй элемент в массиве = промежуточное значение\n// 60 и так далее\n// 100\n```\n\nРазумеется, `reduce` может работать с любыми типами данных, не только с числами. Пример со строками (в данном случае в качестве начального значения стоит передавать пустую строку):\n```javascript\nvar strs = ['JavaScript', 'is', 'awesome'];\nvar result = strs.reduce(function(phrase, word, index) {\n  // Перед первым словом не надо ставить пробел\n  return (index === 0) ? phrase + word : phrase + ' ' + word;\n}, '');\n\nconsole.log(result); // JavaScript is awesome\n```\n\nПример с многомерным массивом (начинаем с пустого массива):\n```javascript\nvar arrs = [[1, 2, 3], [4, 5], [6], [7, 8], [9, 10, 11]];\nvar concat = arrs.reduce(function(result, current) {\n  return result.concat(current);\n}, []);\n\nconsole.log(concat); // [1,2,3,4,5,6,7,8,9,10,11]\n```\n\n## reduce своими руками\nВы уже знаете — у нас есть правила:\n\n1. Функция принимает три аргумента: массив, `callback` функцию, начальное значение.\n2. После каждой итерации в промежуточное значение перезаписывается значением, полученным в результате выполнения `callback` функции.\n3.`callback` функция принимает четыре аргумента: промежуточное значение, текущий элемент массива, индекс элемента, ссылка на сам массив.\n4. Явно указать значение `this` нельзя.\n\n```javascript\nvar reduce = function(arr, callback, startValue) {\n  var i, length = arr.length, result = startValue;\n  for (i = 0; i < length; i = i + 1) {\n    result = callback.call(null, result, arr[i], i, arr);\n  }\n  return result;\n};\n```\n\nВ нативном методе указывать значение `this` нельзя, поэтому вместо введения в функцию ещё одного аргумента `thisArg` мы просто передаём `null` в вызов функции.\n\nПротестируем написанную нами функцию `reduce` на предыдущих примерах, чтобы убедиться, что всё работает, как мы и ожидаем.\n```javascript\nvar arrs = [[1, 2, 3], [4, 5], [6], [7, 8], [9, 10, 11]];\nvar strs = ['JavaScript', 'is', 'awesome'];\n\nvar strResults = reduce(strs, function(phrase, word, index) {\n  return (index === 0) ? phrase + word : phrase + ' ' + word;\n}, '');\n\nvar arrResults = reduce(arrs, function(result, current) {\n  return result.concat(current);\n}, []);\n\nconsole.log(strResults); // JavaScript is awesome\nconsole.log(arrResults); // [1,2,3,4,5,6,7,8,9,10,11]\n```\n","slug":"fn-array-methods","published":1,"updated":"2016-05-23T14:14:11.767Z","_id":"ciok3emeg00096gpnjk7o0esb","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Методы массивов <code>forEach</code>, <code>map</code>, <code>filter</code>, <code>some</code>, <code>every</code> и <code>reduce</code> являются неотъемлимой частью функционального программирования на JavaScript. В этой статье подробно рассмотрим применение каждого из них, а также их реализацию в виде функций.<br><a id=\"more\"></a></p>\n<h2 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h2><p>Самый простой способ разобраться, как работают функции высшего порядка, принимающие callback’и, — самостоятельно переписать несколько нативных методов. Начнём с самого простого метода <code>Array.prototype.forEach</code>. Метод массивов <code>forEach</code> принимает два аргумента: первый (обязательный) — <code>callback</code> функция, которая будет выполнена для каждого элемента массива один раз и второй (необязательный) — значение, которое будет использовано в качестве <code>this</code> при вызове функции <code>callback</code>. Работает это следующим образом:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">'JavaScript'</span>, <span class=\"string\">'is'</span>, <span class=\"string\">'awesome'</span>].forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item, index, arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item, index, arr);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// Выведет в консоль</span></span><br><span class=\"line\"><span class=\"comment\">// JavaScript 0 [\"JavaScript\",\"is\",\"awesome\"]</span></span><br><span class=\"line\"><span class=\"comment\">// is 1 [\"JavaScript\",\"is\",\"awesome\"]</span></span><br><span class=\"line\"><span class=\"comment\">// awesome 2 [\"JavaScript\",\"is\",\"awesome\"]</span></span><br></pre></td></tr></table></figure></p>\n<p>В <code>callback</code> функцию передаётся три аргумента: <code>item</code>, соответствующий элементу массива, <code>index</code>, равный номеру элемента в массиве, и <code>arr</code> — ссылка на массив. Таким образом, справедливо следующее выражение <code>arr[index] === item</code>. Аргументам передаваемым в <code>callback</code> функцию можно давать разные названия в зависимости от контекста выполнения — выполнение <code>callback</code> функции от этого не изменится:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num, i, nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(num * <span class=\"number\">2</span>); <span class=\"comment\">// 2 4 6 8 10</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>Как я писал выше, помимо <code>callback</code> функции метод <code>forEach</code> принимает ещё один аргумент — значение, которое будет использовано в качестве <code>this</code> при вызове функции <code>callback</code>. Зачем это может понадобиться? По умолчанию <code>this</code> не определён, то есть равен <code>undefined</code>. В некоторых ситуациях, особенно при работе с функциями конструкторами, необходимо задать контекст выполнения <code>callback</code> функции:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Person = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrase</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' says '</span> + phrase);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.mumble = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrases</span>) </span>&#123;</span><br><span class=\"line\">  phrases.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrase</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.say(phrase);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> johnDoe = <span class=\"keyword\">new</span> Person(<span class=\"string\">'John Doe'</span>);</span><br><span class=\"line\">johnDoe.mumble([<span class=\"string\">'Hello, World!'</span>, <span class=\"string\">'JS is great'</span>, <span class=\"string\">'I\\'m designer and i don\\'t have job'</span>]);</span><br></pre></td></tr></table></figure></p>\n<p>Подобный код, на первый взгляд, может оказаться полностью рабочим. Тем не менее, после его выполнения всё, что мы увидим будет ошибка <code>Cannot read property &#39;say&#39; of undefined</code>. Данная ошибка показывает, что при выполнении метода <code>forEach</code> на передаваемом в метод <code>mumble</code> массиве <code>phrases</code> не задаётся контекст испольнения <code>callback</code> функции. Проще говоря, <code>callback</code> функция пытается выполнить подобный код <code>undefined[say](words)</code>. Решается данная проблема элементарно — передётся второй аргумент в метод <code>forEach</code>, который и указывает ему, что брать за <code>this</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">Person.prototype.mumble = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">words</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.say(words);</span><br><span class=\"line\">  &#125;, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> johnDoe = <span class=\"keyword\">new</span> Person(<span class=\"string\">'John Doe'</span>);</span><br><span class=\"line\">johnDoe.mumble([<span class=\"string\">'Hello, World!'</span>, <span class=\"string\">'JS is great'</span>, <span class=\"string\">'I\\'m designer and i don\\'t have job'</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Выведет в консоль</span></span><br><span class=\"line\"><span class=\"comment\">// John Doe says Hello, World!</span></span><br><span class=\"line\"><span class=\"comment\">// John Doe says JS is great</span></span><br><span class=\"line\"><span class=\"comment\">// John Doe says I'm designer and i don't have job</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"forEach-своими-руками\"><a href=\"#forEach-своими-руками\" class=\"headerlink\" title=\"forEach своими руками\"></a>forEach своими руками</h2><p>Теперь, когда вы знаете, как работает <code>forEach</code>, настало время написать функцию, которая делает всё тоже самое. При создании функции <code>each</code> будем руководствоваться тремя правилами:</p>\n<ol>\n<li>Функция принимает три аргумента: массив, по которому будет происходить итерация, <code>callback</code> фунцию, которая будет выполнена для каждого элемента массива, и значение, которое будет использовано <code>callback</code> функцией в качестве <code>this</code>.</li>\n<li><code>callback</code> функция, в свою очередь, также работает с тремя аргументами: текущий элемент массива, индекс элемента, ссылка на сам массив.</li>\n<li>Функция ничего не возвращает.</li>\n</ol>\n<p>Самое очевидное решение: используя цикл <code>for</code> перебрать каждый элемент массива и выполнить передаваемую <code>callback</code> функцию с каждым. Сделать это очень просто:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> each = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr, callback, thisArg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i, length = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; length; i = i + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    callback(arr[i], i, arr);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Функция <code>each</code> будет отлично работать, за исключением того, что не соблюдается часть первого правила — для <code>callback</code> функции нельзя задать контекст, то есть нельзя присвоить значение <code>this</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">each([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num, i, nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Number: '</span> + num + <span class=\"string\">', index: '</span> + i + <span class=\"string\">','</span>, nums)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Выведет в консоль</span></span><br><span class=\"line\"><span class=\"comment\">// Number: 1, index: 0, [1,2,3]</span></span><br><span class=\"line\"><span class=\"comment\">// Number: 2, index: 1, [1,2,3]</span></span><br><span class=\"line\"><span class=\"comment\">// Number: 3, index: 2, [1,2,3]</span></span><br></pre></td></tr></table></figure></p>\n<p>Чтобы можно было осуществлять передачу ключевого слова <code>this</code> в функцию <code>each</code> достаточно воспользоваться методом функций <code>call</code>, который позволяет вызвать функцию и явно указать, на что будет указывать ключевое слово <code>this</code>.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> each = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr, callback, thisArg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i, length = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; length; i = i + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    callback.call(thisArg, arr[i], i, arr);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Теперь функция <code>each</code> работает с массивами в точности так, как и метод <code>forEach</code>. Чтобы её протестировать, можно запустить её вместе с кодом из предыдущего примера.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Person = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrase</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' says '</span> + phrase);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.mumble = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrases</span>) </span>&#123;</span><br><span class=\"line\">  each(phrases, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrase</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.say(phrase);</span><br><span class=\"line\">  &#125;, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> johnDoe = <span class=\"keyword\">new</span> Person(<span class=\"string\">'John Doe'</span>);</span><br><span class=\"line\">johnDoe.mumble([<span class=\"string\">'Hello, World!'</span>, <span class=\"string\">'JS is great'</span>, <span class=\"string\">'I\\'m designer and i don\\'t have job'</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Выведет в консоль</span></span><br><span class=\"line\"><span class=\"comment\">// John Doe says Hello, World!</span></span><br><span class=\"line\"><span class=\"comment\">// John Doe says JS is great</span></span><br><span class=\"line\"><span class=\"comment\">// John Doe says I'm designer and i don't have job</span></span><br></pre></td></tr></table></figure></p>\n<p>Несмотря на кажущуюся одинаковость метода <code>forEach</code> и написанной нами выше функции <code>each</code>, между ними есть одно очень важное различие: метод <code>forEach</code> работает <strong>только с массивами</strong>, в то время как функция <code>each</code> может также успешно работать с <strong>любыми коллекциями</strong>.</p>\n<p>Скорее всего, вы уже видели ранее подобную конструкцию, которую использую многие JavaScript разработчики для итерации по всем элементам из DOM коллекции:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> links = <span class=\"built_in\">document</span>.links; <span class=\"comment\">// коллекция всех ссылок на странице</span></span><br><span class=\"line\">[].forEach.call(links, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">link</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Добавление класса link-active для всех ссылок на странице</span></span><br><span class=\"line\">  link.classList.add(<span class=\"string\">'link-active'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>Подобная конструкция может ввести в замешательство практически любого программиста, который раньше не использовал её сам. Подробное объяснение, как именно она работает можно найти в <a href=\"http://stackoverflow.com/questions/16053357/what-does-foreach-call-do-in-javascript\" target=\"_blank\" rel=\"external\">этом вопросе</a> на Stackoverflow. Нужна она лишь для того, чтобы провести итерацию по всем элементам выбранной DOM коллекции и выполнить <code>callback</code> функцию для каждого из них. При использовании написанной нами функции <code>each</code> надобности в такой хитрой конструкции нет, так как она поддерживает работу не только с массивами, но и с любыми коллекциями, в том числе и коллекциями DOM элементов:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> links = <span class=\"built_in\">document</span>.links; <span class=\"comment\">// коллекция всех ссылок на странице</span></span><br><span class=\"line\">each(links, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">link</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Добавление класса link-active для всех ссылок на странице</span></span><br><span class=\"line\">  link.classList.add(<span class=\"string\">'link-active'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>Когда появится широкая поддежка <strong>ES6</strong> метод <code>forEach</code> можно будет использовать с DOM коллекциями более простым способом с помощью оператора <a href=\"http://jsraccoon.ru/es6-spread-rest/\" target=\"_blank\" rel=\"external\">Spread</a>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...links].forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">link</span>) </span>&#123;</span><br><span class=\"line\">  link.classList.add(<span class=\"string\">'link-active'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h2><p>Метод массивов <code>map</code> похож по своей функциональности на <code>forEach</code>, но результат выполнения <code>callback</code> функции добавляется в новый массив, который возвращается после последней итерации. Другими словами, результатом метода <code>map</code> всегда является <strong>новый</strong> массив с результатами выполнения функции <code>callback</code> на исходном массиве.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nums = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> results = nums.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num, index, arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Возведение числа в степень соответсвующую его индексу в массиве</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.pow(num, index);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Исходный массив nums не изменяется</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(nums); <span class=\"comment\">// [10,20,30,40]</span></span><br><span class=\"line\"><span class=\"comment\">// результат выполнения map, записанный в переменную</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(results); <span class=\"comment\">// [1,20,900,64000]</span></span><br></pre></td></tr></table></figure></p>\n<p>Также, как и в случае с <code>forEach</code> <code>map</code> помимо <code>callback</code> функции принимает второй параметр, который позволяет задать контекст и явно указать <code>this</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Person = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.phrases = <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrase</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">' says '</span> + phrase;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.grabPhrases = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrases</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.phrases = phrases.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrase</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Добавление изменённой строки в новый массив</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.say(phrase);</span><br><span class=\"line\">  &#125;, <span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> johnDoe = <span class=\"keyword\">new</span> Person(<span class=\"string\">'John Doe'</span>);</span><br><span class=\"line\">johnDoe.grabPhrases([<span class=\"string\">'Hello, World!'</span>, <span class=\"string\">'JS is great'</span>, <span class=\"string\">'I\\'m designer and i don\\'t have job'</span>]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(johnDoe.phrases);</span><br><span class=\"line\"><span class=\"comment\">// [\"John Doe says Hello, World!\",\"John Doe says JS is great\",\"John Doe says I'm designer and i don't have job\"]</span></span><br></pre></td></tr></table></figure></p>\n<p>Как вы могли заметить, при использовании <code>map</code> и <code>forEach</code> всегда использовалась анонимная функция в качестве <code>callback</code>. Это совсем не обязательно. Вы можете объвить функцию, которую хотите использовать в качестве <code>callback</code> заранее, а затем просто передать её в качестве параметра.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> slice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// вернуть первые пять символов из строки</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> str.slice(<span class=\"number\">0</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> frameworks = [<span class=\"string\">'Knockout'</span>, <span class=\"string\">'Backbone'</span>, <span class=\"string\">'Angular'</span>].map(slice);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(frameworks); <span class=\"comment\">// [\"Knock\",\"Backb\",\"Angul\"]</span></span><br></pre></td></tr></table></figure></p>\n<p>В некоторых ситуациях можно вообще не создавать отдельную функцию и пользоваться нативными методами. Пример выше, в котором каждое число в массиве возводилось в степень, соответствующую своему индексу, можно значительно сократить:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Длинный вариант с ненужной анонимной функцией</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nums = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> results = nums.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num, index, arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.pow(num, index);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Короткий вариант, ничего лишнего</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nums = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> results = nums.map(<span class=\"built_in\">Math</span>.pow);</span><br></pre></td></tr></table></figure></p>\n<p>Передвая <code>callback</code> функцию подобным образом вы не теряете возможность явно указать <code>this</code>. Таким образом, метод <code>grabPhrases</code> из функции конструктора <code>Person</code> также можно немного сократить:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person.prototype.grabPhrases = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrases</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Ненужная анонимная функция</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.phrases = phrases.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrase</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.say(phrase);</span><br><span class=\"line\">  &#125;, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Выполнение функции this.say для каждого элемента массива</span></span><br><span class=\"line\">Person.prototype.grabPhrases = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrases</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.phrases = phrases.map(<span class=\"keyword\">this</span>.say, <span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>В отличие от <code>forEach</code> при использовании <code>map</code> вам становится доступен chaining. Это значит, что вы можете последовательно применить метод на возвращенный после <code>map</code> массив.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Получение квадратного корня из чисел с помощью map</span></span><br><span class=\"line\"><span class=\"comment\">// и вывод результатов в консоль с помощью forEach</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>].map(<span class=\"built_in\">Math</span>.sqrt).forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(num); <span class=\"comment\">// 1 2 3 4</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"map-своими-руками\"><a href=\"#map-своими-руками\" class=\"headerlink\" title=\"map своими руками\"></a>map своими руками</h2><p>Как и при создании аналога <code>forEach</code> напишем небольшие правила, которыми будем руководствоваться при создании функции <code>map</code>:</p>\n<ol>\n<li>Функция возвращает <strong>новый</strong> массив, оставляя исходный без изменений.</li>\n<li>Всё, что возвращает <code>callback</code> функция добавляется в новый массив.</li>\n<li>Функция принимает три аргумента: массив, по которому будет происходить итерация, <code>callback</code> фунцию, которая будет выполнена для каждого элемента массива, и значение, которое будет использовано <code>callback</code> функцией в качестве <code>this</code>.</li>\n<li><code>callback</code> функция, в свою очередь, также работает с тремя аргументами: текущий элемент массива, индекс элемента, ссылка на сам массив.</li>\n</ol>\n<p>Правил стало больше, но последними двумя мы уже пользовались при создании функции <code>each</code>, а, значит, вы уже знаете, как с ними справиться.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr, callback, thisArg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i, length = arr.length, results = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; length; i = i + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    results.push(callback.call(thisArg, arr[i], i, arr));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> results;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Менять исходный массив нельзя, поэтому нужно создать новый массив в самом начале выполнения функции <code>map</code>. Назовём его <code>results</code>. В созданный нами массив <code>results</code> при кажом выполнении будем добавлять результат выполнения функции <code>callback</code> с помощью метода <code>push</code>. После завершения последней итерации всё, что остаётся сделать — вернуть массив <code>results</code>.</p>\n<p>Написанная нами функция <code>map</code> работает точно так же, как и метод массивов <code>map</code>, но, как и <code>each</code>, может принимать в качестве аргументов любый другие коллекции.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pows = map([<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>], <span class=\"built_in\">Math</span>.pow);</span><br><span class=\"line\"><span class=\"keyword\">var</span> frameworks = map([<span class=\"string\">'Knockout'</span>, <span class=\"string\">'Backbone'</span>, <span class=\"string\">'Angular'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">framework</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> framework.slice(<span class=\"number\">0</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(pows); <span class=\"comment\">// [1,20,900]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(frameworks); <span class=\"comment\">// [\"Knock\",\"Backb\",\"Angul\"]</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>Небольшой совет</strong>: не используйте метод <code>map</code> для манипуляций с коллекциями DOM элементов, например, чтобы добавить класс всем элементам коллекции.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[].map.call(<span class=\"built_in\">document</span>.links, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">link</span>) </span>&#123;</span><br><span class=\"line\">  link.classList.add(<span class=\"string\">'link'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>Данный код сработает и всем ссылкам будет добавлен класс <code>link</code>, но пимимо этого будет создан дополнительный пустой массив, что скажется на производительности при большом объеме итерируемой коллекции. В подобных случаях следует использовать исключительно <code>forEach</code>.</p>\n<p>Тем не менее, <code>map</code> отлично подходит для получения данных из DOM коллекций. Например, получение всех <code>href</code> атрибутов будет выглядеть следующим образом:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> hrefs = [].map.call(<span class=\"built_in\">document</span>.links, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">link</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> link.href;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hrefs); <span class=\"comment\">// [\"http://google.ru\", \"http://jsraccoon.ru\" ...]</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h2><p>Метод <code>filter</code>, как и следует из названия, служит для фильтрации массива по правилам, заданным в <code>callback</code> функции. Так же, как в случае с <code>map</code> создаётся <strong>новый</strong> массив, куда добавляются все элементы прошедшие провеку колбэком.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> moreThanFive = [<span class=\"number\">1</span>, <span class=\"number\">20</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">24</span>, <span class=\"number\">6</span>, <span class=\"number\">45</span>].filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num &gt; <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(moreThanFive); <span class=\"comment\">// [20,24,6,45]</span></span><br></pre></td></tr></table></figure></p>\n<p>При использовании метода <code>filter</code> результатом выполнения может быть любое значение, но данные из исходного массива будут добавлены только в том случае, если значение является правдивым. Напомню, что правдивыми значениями являются все, кроме:</p>\n<ol>\n<li>пустой строки <code>&#39;&#39;</code></li>\n<li>числа ноль <code>0</code></li>\n<li><code>false</code></li>\n<li><code>undefined</code></li>\n<li><code>null</code></li>\n</ol>\n<p>Тем не менее, пользоваться подобным способом фильтрации массива не стоит в силу его неочевидности. Поэтому рекомендуется создавать <code>callback</code> функцию таким образом, чтобы она всегда возвращала либо <code>true</code>, либо <code>false</code>.</p>\n<p>Немного более сложный пример использования метода <code>filter</code>. Допустим, что мы получаем JSON файл с сервера с подобным содержимым:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&#123;<span class=\"string\">\"id\"</span>:<span class=\"number\">1</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Ernest\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"ebishop0@myspace.com\"</span>,<span class=\"string\">\"isCustomer\"</span>:<span class=\"literal\">false</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"id\"</span>:<span class=\"number\">2</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Michael\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"mturner1@multiply.com\"</span>,<span class=\"string\">\"isCustomer\"</span>:<span class=\"literal\">false</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"id\"</span>:<span class=\"number\">3</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Mildred\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"mwelch2@google.it\"</span>,<span class=\"string\">\"isCustomer\"</span>:<span class=\"literal\">false</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"id\"</span>:<span class=\"number\">4</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Jeremy\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"jwilson3@hostgator.com\"</span>,<span class=\"string\">\"isCustomer\"</span>:<span class=\"literal\">false</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"id\"</span>:<span class=\"number\">5</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Judy\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"jellis4@ameblo.jp\"</span>,<span class=\"string\">\"isCustomer\"</span>:<span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"id\"</span>:<span class=\"number\">6</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Judy\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"jrogers5@ow.ly\"</span>,<span class=\"string\">\"isCustomer\"</span>:<span class=\"literal\">false</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"id\"</span>:<span class=\"number\">7</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Chris\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"cbennett6@nasa.gov\"</span>,<span class=\"string\">\"isCustomer\"</span>:<span class=\"literal\">false</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"id\"</span>:<span class=\"number\">8</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Ruth\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"rmason7@simplemachines.org\"</span>,<span class=\"string\">\"isCustomer\"</span>:<span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"id\"</span>:<span class=\"number\">9</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Justin\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"jmedina8@indiegogo.com\"</span>,<span class=\"string\">\"isCustomer\"</span>:<span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"id\"</span>:<span class=\"number\">10</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Dennis\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"dflores9@g.co\"</span>,<span class=\"string\">\"isCustomer\"</span>:<span class=\"literal\">true</span>&#125;]</span><br></pre></td></tr></table></figure></p>\n<p>После получения данных (с помощью AJAX или JSONP, например) мы хотим их отфильтровать, узнав из свойства <code>isCustomer</code>, является ли данных человек нашим клиентом или нет. Вот здесь и пригодится метод <code>filter</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"comment\">// Получили данные с сервера и записали их в переменную data</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> customers = data.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> person.isCustomer;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(customers);</span><br><span class=\"line\"><span class=\"comment\">// [&#123;\"id\":5,\"name\":\"Judy\",\"email\":\"jellis4@ameblo.jp\",\"isCustomer\":true&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;\"id\":8,\"name\":\"Ruth\",\"email\":\"rmason7@simplemachines.org\",\"isCustomer\":true&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;\"id\":9,\"name\":\"Justin\",\"email\":\"jmedina8@indiegogo.com\",\"isCustomer\":true&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;\"id\":10,\"name\":\"Dennis\",\"email\":\"dflores9@g.co\",\"isCustomer\":true&#125;]</span></span><br></pre></td></tr></table></figure></p>\n<p>Или же можно руководствоваться немного другим, более сложным принципом при выборе цели. Например, мы решили, что если email клиента не начинается с буквы <code>j</code>, то он определённо нам не подходит.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"comment\">// Получили данные с сервера и записали их в переменную data</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> customers = data.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> person.email.charAt(<span class=\"number\">0</span>).toLowerCase() === <span class=\"string\">'j'</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(customers);</span><br><span class=\"line\"><span class=\"comment\">// [&#123;\"id\":4,\"name\":\"Jeremy\",\"email\":\"jwilson3@hostgator.com\",\"isCustomer\":false&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;\"id\":5,\"name\":\"Judy\",\"email\":\"jellis4@ameblo.jp\",\"isCustomer\":true&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;\"id\":6,\"name\":\"Judy\",\"email\":\"jrogers5@ow.ly\",\"isCustomer\":false&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;\"id\":9,\"name\":\"Justin\",\"email\":\"jmedina8@indiegogo.com\",\"isCustomer\":true&#125;]</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"filter-своими-руками\"><a href=\"#filter-своими-руками\" class=\"headerlink\" title=\"filter своими руками\"></a>filter своими руками</h2><p>Как и для прошлых функций <code>map</code> и <code>forEach</code> напишем небольшой свод правил:</p>\n<ol>\n<li>Функция возвращает <strong>новый</strong> массив, оставляя исходный без изменений.</li>\n<li>Данные исходного массива передаются в <code>callback</code> функцию. Результат выполнения <code>callback</code> функции решает будет ли добавлен данный элемент в новый массив.</li>\n<li>Функция принимает три аргумента: массив, по которому будет происходить итерация, <code>callback</code> фунцию, которая будет выполнена для каждого элемента массива, и значение, которое будет использовано <code>callback</code> функцией в качестве <code>this</code>.</li>\n<li><code>callback</code> функция, в свою очередь, также работает с тремя аргументами: текущий элемент массива, индекс элемента, ссылка на сам массив.</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> filter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr, callback, thisArg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i, length = arr.length, results = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; length; i = i + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (callback.call(thisArg, arr[i], i, arr)) &#123;</span><br><span class=\"line\">      results.push(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> results;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>С помощью всё того же метода функций <code>call</code> мы вызываем <code>callback</code> функцию, но на этот раз всё, что нас будет интересовать — вернула ли функция правдивое значение. Если результат содержит правдивое значение, то данные будут добавлены в массив, если же нет, то просто проигнорированы.</p>\n<p>Удостоверимся, что функция <code>filter</code> работает, как мы её и задумывали:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> strs = [<span class=\"string\">'Hello'</span>, <span class=\"string\">','</span>, <span class=\"string\">'JavaScript'</span>, <span class=\"string\">'World'</span>, <span class=\"string\">'!'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = filter(strs, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str.toLowerCase() !== str;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(data); <span class=\"comment\">// [\"Hello\",\"JavaScript\",\"World\"]</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>Небольшой хак</strong>: чтобы отфильтровать все ложные значения из массива можно воспользоваться конструктором <code>Boolean</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = [<span class=\"number\">32</span>, <span class=\"string\">''</span>, <span class=\"literal\">null</span>, <span class=\"string\">'JavaScript'</span>, <span class=\"literal\">undefined</span>, <span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> trueData = data.filter(<span class=\"built_in\">Boolean</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(trueData); <span class=\"comment\">// [32,\"JavaScript\"]</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"some-и-every\"><a href=\"#some-и-every\" class=\"headerlink\" title=\"some и every\"></a>some и every</h2><p>Методы <code>some</code> и <code>every</code> во многом похожи друг на друга. Оба метода возвращают <code>true</code> или <code>false</code>. <code>some</code> возвращает <code>true</code> тогда, когда хотя бы один элемент массива отвечает переданным в <code>callback</code> функцию условиям. <code>every</code> вернёт <code>true</code>, когда все элементы массива отвечают данным условиям. Звучит грозно, но, на самом деле всё очень просто.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fives = [<span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = fives.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">five</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> five === <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// false — в массиве же есть шестёрка</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fives = [<span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = fives.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">five</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> five === <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// true — теперь там только пятёрки, всё хорошо</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> nums = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = nums.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num &gt; <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// true — в массиве есть хотя бы одно значение больше 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> nums = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = nums.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num &lt; <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// false — в массиве нет ни одного значения меньше 5</span></span><br></pre></td></tr></table></figure></p>\n<p>Методы <code>some</code> и <code>every</code> очень удобно использовать вместе с методом <code>filter</code> для вложенных массивов. Чтобы понять, как это работает, опять представим, что мы получили данные с сервера в виде JSON файла, который содержит массив объектов (наших покупателей). У каждого покупателя есть свойство <code>purchases</code>, которое представляет собой список приобретённых покупателем товаров в нашем магазине ранее.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Wanda\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"wjenkins0@irs.gov\"</span>,<span class=\"string\">\"purchases\"</span>:[<span class=\"string\">'iPhone'</span>, <span class=\"string\">'dishwasher'</span>, <span class=\"string\">'cucumbers'</span>]&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Nicholas\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"nkennedy1@ox.ac.uk\"</span>,<span class=\"string\">\"purchases\"</span>:[<span class=\"string\">'tomatoes'</span>, <span class=\"string\">'toster'</span>, <span class=\"string\">'grill'</span>]&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Paula\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"pstephens2@boston.com\"</span>,<span class=\"string\">\"purchases\"</span>:[<span class=\"string\">'apples'</span>, <span class=\"string\">'Macbook'</span>, <span class=\"string\">'iPhone'</span>]&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Fred\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"fpeterson3@reuters.com\"</span>,<span class=\"string\">\"purchases\"</span>:[<span class=\"string\">'beef'</span>, <span class=\"string\">'pork'</span>, <span class=\"string\">'cheese'</span>]&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Andrew\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"awagner4@weebly.com\"</span>,<span class=\"string\">\"purchases\"</span>:[<span class=\"string\">'cottage cheese'</span>, <span class=\"string\">'cream'</span>, <span class=\"string\">'candies'</span>]&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Steven\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"sgonzales5@mashable.com\"</span>,<span class=\"string\">\"purchases\"</span>:[<span class=\"string\">'iMac'</span>, <span class=\"string\">'Android phone'</span>, <span class=\"string\">'Windows 10'</span>]&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Harry\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"hallen6@nasa.gov\"</span>,<span class=\"string\">\"purchases\"</span>:[<span class=\"string\">'green grape'</span>, <span class=\"string\">'tomatoes'</span>, <span class=\"string\">'potatoes'</span>]&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Bonnie\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"breyes7@kickstarter.com\"</span>,<span class=\"string\">\"purchases\"</span>:[<span class=\"string\">'Windows 10'</span>, <span class=\"string\">'dishwasher'</span>, <span class=\"string\">'grill'</span>]&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Lisa\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"lgreene8@spotify.com\"</span>,<span class=\"string\">\"purchases\"</span>:[<span class=\"string\">'pork'</span>, <span class=\"string\">'iMac'</span>, <span class=\"string\">'cheese'</span>]&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Wayne\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"wramos9@yahoo.com\"</span>,<span class=\"string\">\"purchases\"</span>:[<span class=\"string\">'apples'</span>, <span class=\"string\">'cream'</span>, <span class=\"string\">'candies'</span>]&#125;]</span><br></pre></td></tr></table></figure></p>\n<p>Чтобы понять, какие клиенты нам принесли больше всего прибыли, мы хотим их отфильтровать и посмотреть, кто из них покупал у нас технику от Apple (iPhone, Macbook или iMac). Метод <code>some</code> поможет сделать это с помощью всего нескольких строк кода.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"comment\">// Получили данные с сервера и записали их в переменную data</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> customers = data.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">customer</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> customer.purchases.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">purchase</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> purchase === <span class=\"string\">'iPhone'</span> || purchase === <span class=\"string\">'Macbook'</span> || purchase === <span class=\"string\">'iMac'</span>;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(customers);</span><br><span class=\"line\"><span class=\"comment\">// [&#123;\"name\":\"Wanda\",\"email\":\"wjenkins0@irs.gov\",\"purchases\":[\"iPhone\",\"dishwasher\",\"cucumbers\"]&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;\"name\":\"Paula\",\"email\":\"pstephens2@boston.com\",\"purchases\":[\"apples\",\"Macbook\",\"iPhone\"]&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;\"name\":\"Steven\",\"email\":\"sgonzales5@mashable.com\",\"purchases\":[\"iMac\",\"Android phone\",\"Windows 10\"]&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;\"name\":\"Lisa\",\"email\":\"lgreene8@spotify.com\",\"purchases\":[\"pork\",\"iMac\",\"cheese\"]&#125;]</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"some-и-every-своими-руками\"><a href=\"#some-и-every-своими-руками\" class=\"headerlink\" title=\"some и every своими руками\"></a>some и every своими руками</h2><p>Правила:</p>\n<ol>\n<li>Функция возвращает только <code>true</code> или <code>false</code></li>\n<li>Каждое значение передаётся в <code>callback</code> функцию и на результате её выполнения для <strong>всех</strong> элементов массива решается, какой будет результат.</li>\n<li>Функция принимает три аргумента: массив, по которому будет происходить итерация, <code>callback</code> фунцию, которая будет выполнена для каждого элемента массива, и значение, которое будет использовано <code>callback</code> функцией в качестве <code>this</code>.</li>\n<li><code>callback</code> функция, в свою очередь, также работает с тремя аргументами: текущий элемент массива, индекс элемента, ссылка на сам массив.</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> some = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr, callback, thisArg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i, length = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; length; i = i + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (callback.call(thisArg, arr[i], i, arr)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Функция <code>some</code> при каждой итерации проверяет, является ли результат выполнения <code>callback</code> функции правдивым. Если она находит хотя бы один правдивый результат, то прерывает своё выполнение и сразу возвращает <code>true</code>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> every = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr, callback, thisArg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i, length = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; length; i = i + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!callback.call(thisArg, arr[i], i, arr)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Функция <code>every</code> построена по противоположному принципу. Если хотя бы одно значение не является верным, то сразу же возвращается <code>false</code> без дальнейшего перебирания массива.</p>\n<p>Функции <code>every</code> и <code>some</code> работают идентично соответствующим им методам и будут давать одинаковые резутаты. Тем не менее, написанные нами функции работают лучше нативных методов. Почему? Используя методы массивов <code>some</code> и <code>every</code> вы подразумеваете, что <code>callback</code> функция будет выполнена для всех элементов без исключения. Но, может оказаться так, что первый элемент в массиве уже содержит нужные нам данные и итерация по всем остальным будет абсолютно бесполезной. В написанных нами функциях таких итераций не будет — когда будет найдено искомое значение функция сразу же прекратит своё выполнение. Подобный подход может дать достаточно ощутимый прирост производительности при работе с большими объемами данных, например, с JSON файлами содержащими несколько тысяч объектов.</p>\n<h2 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h2><p><code>callback</code> функция всех рассмотренных выше методов массивов работает с одинаковым набором данных: значением, индексом и массивом. Метод <code>reduce</code> не такой, как все. Принцип его работы немного отличается от всех остальных методов. Начнём сразу с примера:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nums = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = nums.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result, num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result + num;</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum); <span class=\"comment\">// 150 сумма всех элементов массива</span></span><br></pre></td></tr></table></figure></p>\n<p>Метод <code>reduce</code> принимает два аргумента <code>callback</code> функцию и начальное значение, которое будет присвоено аргументу <code>result</code> в примере выше при первой итерации. <code>callback</code> функция принимает целых 4 аргумента: промежуточное значение (аргумент <code>result</code> в примере выше), элемент массива, индекс элемента и сам массив. После каждой итерации в промежуточное значение записываются новые данные, которые берутся из результата выполнения функции <code>callback</code> при прошлой итерации:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nums = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = nums.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result, num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result + num;</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Будет выведено в консоль</span></span><br><span class=\"line\"><span class=\"comment\">// 0 начальное значение</span></span><br><span class=\"line\"><span class=\"comment\">// 10 начальное значение + первый элемент в массиве = промежуточное значение</span></span><br><span class=\"line\"><span class=\"comment\">// 30 промежуточное значение + второй элемент в массиве = промежуточное значение</span></span><br><span class=\"line\"><span class=\"comment\">// 60 и так далее</span></span><br><span class=\"line\"><span class=\"comment\">// 100</span></span><br></pre></td></tr></table></figure></p>\n<p>Разумеется, <code>reduce</code> может работать с любыми типами данных, не только с числами. Пример со строками (в данном случае в качестве начального значения стоит передавать пустую строку):<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> strs = [<span class=\"string\">'JavaScript'</span>, <span class=\"string\">'is'</span>, <span class=\"string\">'awesome'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = strs.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrase, word, index</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Перед первым словом не надо ставить пробел</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (index === <span class=\"number\">0</span>) ? phrase + word : phrase + <span class=\"string\">' '</span> + word;</span><br><span class=\"line\">&#125;, <span class=\"string\">''</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// JavaScript is awesome</span></span><br></pre></td></tr></table></figure></p>\n<p>Пример с многомерным массивом (начинаем с пустого массива):<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arrs = [[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"number\">4</span>, <span class=\"number\">5</span>], [<span class=\"number\">6</span>], [<span class=\"number\">7</span>, <span class=\"number\">8</span>], [<span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>]];</span><br><span class=\"line\"><span class=\"keyword\">var</span> concat = arrs.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result, current</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result.concat(current);</span><br><span class=\"line\">&#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(concat); <span class=\"comment\">// [1,2,3,4,5,6,7,8,9,10,11]</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"reduce-своими-руками\"><a href=\"#reduce-своими-руками\" class=\"headerlink\" title=\"reduce своими руками\"></a>reduce своими руками</h2><p>Вы уже знаете — у нас есть правила:</p>\n<ol>\n<li>Функция принимает три аргумента: массив, <code>callback</code> функцию, начальное значение.</li>\n<li>После каждой итерации в промежуточное значение перезаписывается значением, полученным в результате выполнения <code>callback</code> функции.<br>3.<code>callback</code> функция принимает четыре аргумента: промежуточное значение, текущий элемент массива, индекс элемента, ссылка на сам массив.</li>\n<li>Явно указать значение <code>this</code> нельзя.</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reduce = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr, callback, startValue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i, length = arr.length, result = startValue;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; length; i = i + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    result = callback.call(<span class=\"literal\">null</span>, result, arr[i], i, arr);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>В нативном методе указывать значение <code>this</code> нельзя, поэтому вместо введения в функцию ещё одного аргумента <code>thisArg</code> мы просто передаём <code>null</code> в вызов функции.</p>\n<p>Протестируем написанную нами функцию <code>reduce</code> на предыдущих примерах, чтобы убедиться, что всё работает, как мы и ожидаем.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arrs = [[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"number\">4</span>, <span class=\"number\">5</span>], [<span class=\"number\">6</span>], [<span class=\"number\">7</span>, <span class=\"number\">8</span>], [<span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>]];</span><br><span class=\"line\"><span class=\"keyword\">var</span> strs = [<span class=\"string\">'JavaScript'</span>, <span class=\"string\">'is'</span>, <span class=\"string\">'awesome'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> strResults = reduce(strs, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrase, word, index</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (index === <span class=\"number\">0</span>) ? phrase + word : phrase + <span class=\"string\">' '</span> + word;</span><br><span class=\"line\">&#125;, <span class=\"string\">''</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrResults = reduce(arrs, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result, current</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result.concat(current);</span><br><span class=\"line\">&#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(strResults); <span class=\"comment\">// JavaScript is awesome</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrResults); <span class=\"comment\">// [1,2,3,4,5,6,7,8,9,10,11]</span></span><br></pre></td></tr></table></figure></p>\n","excerpt":"<p>Методы массивов <code>forEach</code>, <code>map</code>, <code>filter</code>, <code>some</code>, <code>every</code> и <code>reduce</code> являются неотъемлимой частью функционального программирования на JavaScript. В этой статье подробно рассмотрим применение каждого из них, а также их реализацию в виде функций.<br>","more":"</p>\n<h2 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h2><p>Самый простой способ разобраться, как работают функции высшего порядка, принимающие callback’и, — самостоятельно переписать несколько нативных методов. Начнём с самого простого метода <code>Array.prototype.forEach</code>. Метод массивов <code>forEach</code> принимает два аргумента: первый (обязательный) — <code>callback</code> функция, которая будет выполнена для каждого элемента массива один раз и второй (необязательный) — значение, которое будет использовано в качестве <code>this</code> при вызове функции <code>callback</code>. Работает это следующим образом:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">'JavaScript'</span>, <span class=\"string\">'is'</span>, <span class=\"string\">'awesome'</span>].forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item, index, arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item, index, arr);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// Выведет в консоль</span></span><br><span class=\"line\"><span class=\"comment\">// JavaScript 0 [\"JavaScript\",\"is\",\"awesome\"]</span></span><br><span class=\"line\"><span class=\"comment\">// is 1 [\"JavaScript\",\"is\",\"awesome\"]</span></span><br><span class=\"line\"><span class=\"comment\">// awesome 2 [\"JavaScript\",\"is\",\"awesome\"]</span></span><br></pre></td></tr></table></figure></p>\n<p>В <code>callback</code> функцию передаётся три аргумента: <code>item</code>, соответствующий элементу массива, <code>index</code>, равный номеру элемента в массиве, и <code>arr</code> — ссылка на массив. Таким образом, справедливо следующее выражение <code>arr[index] === item</code>. Аргументам передаваемым в <code>callback</code> функцию можно давать разные названия в зависимости от контекста выполнения — выполнение <code>callback</code> функции от этого не изменится:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num, i, nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(num * <span class=\"number\">2</span>); <span class=\"comment\">// 2 4 6 8 10</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>Как я писал выше, помимо <code>callback</code> функции метод <code>forEach</code> принимает ещё один аргумент — значение, которое будет использовано в качестве <code>this</code> при вызове функции <code>callback</code>. Зачем это может понадобиться? По умолчанию <code>this</code> не определён, то есть равен <code>undefined</code>. В некоторых ситуациях, особенно при работе с функциями конструкторами, необходимо задать контекст выполнения <code>callback</code> функции:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Person = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrase</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' says '</span> + phrase);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.mumble = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrases</span>) </span>&#123;</span><br><span class=\"line\">  phrases.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrase</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.say(phrase);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> johnDoe = <span class=\"keyword\">new</span> Person(<span class=\"string\">'John Doe'</span>);</span><br><span class=\"line\">johnDoe.mumble([<span class=\"string\">'Hello, World!'</span>, <span class=\"string\">'JS is great'</span>, <span class=\"string\">'I\\'m designer and i don\\'t have job'</span>]);</span><br></pre></td></tr></table></figure></p>\n<p>Подобный код, на первый взгляд, может оказаться полностью рабочим. Тем не менее, после его выполнения всё, что мы увидим будет ошибка <code>Cannot read property &#39;say&#39; of undefined</code>. Данная ошибка показывает, что при выполнении метода <code>forEach</code> на передаваемом в метод <code>mumble</code> массиве <code>phrases</code> не задаётся контекст испольнения <code>callback</code> функции. Проще говоря, <code>callback</code> функция пытается выполнить подобный код <code>undefined[say](words)</code>. Решается данная проблема элементарно — передётся второй аргумент в метод <code>forEach</code>, который и указывает ему, что брать за <code>this</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">Person.prototype.mumble = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">words</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.say(words);</span><br><span class=\"line\">  &#125;, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> johnDoe = <span class=\"keyword\">new</span> Person(<span class=\"string\">'John Doe'</span>);</span><br><span class=\"line\">johnDoe.mumble([<span class=\"string\">'Hello, World!'</span>, <span class=\"string\">'JS is great'</span>, <span class=\"string\">'I\\'m designer and i don\\'t have job'</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Выведет в консоль</span></span><br><span class=\"line\"><span class=\"comment\">// John Doe says Hello, World!</span></span><br><span class=\"line\"><span class=\"comment\">// John Doe says JS is great</span></span><br><span class=\"line\"><span class=\"comment\">// John Doe says I'm designer and i don't have job</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"forEach-своими-руками\"><a href=\"#forEach-своими-руками\" class=\"headerlink\" title=\"forEach своими руками\"></a>forEach своими руками</h2><p>Теперь, когда вы знаете, как работает <code>forEach</code>, настало время написать функцию, которая делает всё тоже самое. При создании функции <code>each</code> будем руководствоваться тремя правилами:</p>\n<ol>\n<li>Функция принимает три аргумента: массив, по которому будет происходить итерация, <code>callback</code> фунцию, которая будет выполнена для каждого элемента массива, и значение, которое будет использовано <code>callback</code> функцией в качестве <code>this</code>.</li>\n<li><code>callback</code> функция, в свою очередь, также работает с тремя аргументами: текущий элемент массива, индекс элемента, ссылка на сам массив.</li>\n<li>Функция ничего не возвращает.</li>\n</ol>\n<p>Самое очевидное решение: используя цикл <code>for</code> перебрать каждый элемент массива и выполнить передаваемую <code>callback</code> функцию с каждым. Сделать это очень просто:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> each = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr, callback, thisArg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i, length = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; length; i = i + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    callback(arr[i], i, arr);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Функция <code>each</code> будет отлично работать, за исключением того, что не соблюдается часть первого правила — для <code>callback</code> функции нельзя задать контекст, то есть нельзя присвоить значение <code>this</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">each([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num, i, nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Number: '</span> + num + <span class=\"string\">', index: '</span> + i + <span class=\"string\">','</span>, nums)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Выведет в консоль</span></span><br><span class=\"line\"><span class=\"comment\">// Number: 1, index: 0, [1,2,3]</span></span><br><span class=\"line\"><span class=\"comment\">// Number: 2, index: 1, [1,2,3]</span></span><br><span class=\"line\"><span class=\"comment\">// Number: 3, index: 2, [1,2,3]</span></span><br></pre></td></tr></table></figure></p>\n<p>Чтобы можно было осуществлять передачу ключевого слова <code>this</code> в функцию <code>each</code> достаточно воспользоваться методом функций <code>call</code>, который позволяет вызвать функцию и явно указать, на что будет указывать ключевое слово <code>this</code>.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> each = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr, callback, thisArg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i, length = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; length; i = i + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    callback.call(thisArg, arr[i], i, arr);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Теперь функция <code>each</code> работает с массивами в точности так, как и метод <code>forEach</code>. Чтобы её протестировать, можно запустить её вместе с кодом из предыдущего примера.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Person = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrase</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' says '</span> + phrase);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.mumble = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrases</span>) </span>&#123;</span><br><span class=\"line\">  each(phrases, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrase</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.say(phrase);</span><br><span class=\"line\">  &#125;, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> johnDoe = <span class=\"keyword\">new</span> Person(<span class=\"string\">'John Doe'</span>);</span><br><span class=\"line\">johnDoe.mumble([<span class=\"string\">'Hello, World!'</span>, <span class=\"string\">'JS is great'</span>, <span class=\"string\">'I\\'m designer and i don\\'t have job'</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Выведет в консоль</span></span><br><span class=\"line\"><span class=\"comment\">// John Doe says Hello, World!</span></span><br><span class=\"line\"><span class=\"comment\">// John Doe says JS is great</span></span><br><span class=\"line\"><span class=\"comment\">// John Doe says I'm designer and i don't have job</span></span><br></pre></td></tr></table></figure></p>\n<p>Несмотря на кажущуюся одинаковость метода <code>forEach</code> и написанной нами выше функции <code>each</code>, между ними есть одно очень важное различие: метод <code>forEach</code> работает <strong>только с массивами</strong>, в то время как функция <code>each</code> может также успешно работать с <strong>любыми коллекциями</strong>.</p>\n<p>Скорее всего, вы уже видели ранее подобную конструкцию, которую использую многие JavaScript разработчики для итерации по всем элементам из DOM коллекции:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> links = <span class=\"built_in\">document</span>.links; <span class=\"comment\">// коллекция всех ссылок на странице</span></span><br><span class=\"line\">[].forEach.call(links, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">link</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Добавление класса link-active для всех ссылок на странице</span></span><br><span class=\"line\">  link.classList.add(<span class=\"string\">'link-active'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>Подобная конструкция может ввести в замешательство практически любого программиста, который раньше не использовал её сам. Подробное объяснение, как именно она работает можно найти в <a href=\"http://stackoverflow.com/questions/16053357/what-does-foreach-call-do-in-javascript\">этом вопросе</a> на Stackoverflow. Нужна она лишь для того, чтобы провести итерацию по всем элементам выбранной DOM коллекции и выполнить <code>callback</code> функцию для каждого из них. При использовании написанной нами функции <code>each</code> надобности в такой хитрой конструкции нет, так как она поддерживает работу не только с массивами, но и с любыми коллекциями, в том числе и коллекциями DOM элементов:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> links = <span class=\"built_in\">document</span>.links; <span class=\"comment\">// коллекция всех ссылок на странице</span></span><br><span class=\"line\">each(links, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">link</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Добавление класса link-active для всех ссылок на странице</span></span><br><span class=\"line\">  link.classList.add(<span class=\"string\">'link-active'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>Когда появится широкая поддежка <strong>ES6</strong> метод <code>forEach</code> можно будет использовать с DOM коллекциями более простым способом с помощью оператора <a href=\"http://jsraccoon.ru/es6-spread-rest/\">Spread</a>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...links].forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">link</span>) </span>&#123;</span><br><span class=\"line\">  link.classList.add(<span class=\"string\">'link-active'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h2><p>Метод массивов <code>map</code> похож по своей функциональности на <code>forEach</code>, но результат выполнения <code>callback</code> функции добавляется в новый массив, который возвращается после последней итерации. Другими словами, результатом метода <code>map</code> всегда является <strong>новый</strong> массив с результатами выполнения функции <code>callback</code> на исходном массиве.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nums = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> results = nums.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num, index, arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Возведение числа в степень соответсвующую его индексу в массиве</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.pow(num, index);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Исходный массив nums не изменяется</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(nums); <span class=\"comment\">// [10,20,30,40]</span></span><br><span class=\"line\"><span class=\"comment\">// результат выполнения map, записанный в переменную</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(results); <span class=\"comment\">// [1,20,900,64000]</span></span><br></pre></td></tr></table></figure></p>\n<p>Также, как и в случае с <code>forEach</code> <code>map</code> помимо <code>callback</code> функции принимает второй параметр, который позволяет задать контекст и явно указать <code>this</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Person = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.phrases = <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrase</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">' says '</span> + phrase;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.grabPhrases = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrases</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.phrases = phrases.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrase</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Добавление изменённой строки в новый массив</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.say(phrase);</span><br><span class=\"line\">  &#125;, <span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> johnDoe = <span class=\"keyword\">new</span> Person(<span class=\"string\">'John Doe'</span>);</span><br><span class=\"line\">johnDoe.grabPhrases([<span class=\"string\">'Hello, World!'</span>, <span class=\"string\">'JS is great'</span>, <span class=\"string\">'I\\'m designer and i don\\'t have job'</span>]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(johnDoe.phrases);</span><br><span class=\"line\"><span class=\"comment\">// [\"John Doe says Hello, World!\",\"John Doe says JS is great\",\"John Doe says I'm designer and i don't have job\"]</span></span><br></pre></td></tr></table></figure></p>\n<p>Как вы могли заметить, при использовании <code>map</code> и <code>forEach</code> всегда использовалась анонимная функция в качестве <code>callback</code>. Это совсем не обязательно. Вы можете объвить функцию, которую хотите использовать в качестве <code>callback</code> заранее, а затем просто передать её в качестве параметра.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> slice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// вернуть первые пять символов из строки</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> str.slice(<span class=\"number\">0</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> frameworks = [<span class=\"string\">'Knockout'</span>, <span class=\"string\">'Backbone'</span>, <span class=\"string\">'Angular'</span>].map(slice);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(frameworks); <span class=\"comment\">// [\"Knock\",\"Backb\",\"Angul\"]</span></span><br></pre></td></tr></table></figure></p>\n<p>В некоторых ситуациях можно вообще не создавать отдельную функцию и пользоваться нативными методами. Пример выше, в котором каждое число в массиве возводилось в степень, соответствующую своему индексу, можно значительно сократить:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Длинный вариант с ненужной анонимной функцией</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nums = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> results = nums.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num, index, arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.pow(num, index);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Короткий вариант, ничего лишнего</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nums = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> results = nums.map(<span class=\"built_in\">Math</span>.pow);</span><br></pre></td></tr></table></figure></p>\n<p>Передвая <code>callback</code> функцию подобным образом вы не теряете возможность явно указать <code>this</code>. Таким образом, метод <code>grabPhrases</code> из функции конструктора <code>Person</code> также можно немного сократить:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person.prototype.grabPhrases = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrases</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Ненужная анонимная функция</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.phrases = phrases.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrase</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.say(phrase);</span><br><span class=\"line\">  &#125;, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Выполнение функции this.say для каждого элемента массива</span></span><br><span class=\"line\">Person.prototype.grabPhrases = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrases</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.phrases = phrases.map(<span class=\"keyword\">this</span>.say, <span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>В отличие от <code>forEach</code> при использовании <code>map</code> вам становится доступен chaining. Это значит, что вы можете последовательно применить метод на возвращенный после <code>map</code> массив.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Получение квадратного корня из чисел с помощью map</span></span><br><span class=\"line\"><span class=\"comment\">// и вывод результатов в консоль с помощью forEach</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>].map(<span class=\"built_in\">Math</span>.sqrt).forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(num); <span class=\"comment\">// 1 2 3 4</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"map-своими-руками\"><a href=\"#map-своими-руками\" class=\"headerlink\" title=\"map своими руками\"></a>map своими руками</h2><p>Как и при создании аналога <code>forEach</code> напишем небольшие правила, которыми будем руководствоваться при создании функции <code>map</code>:</p>\n<ol>\n<li>Функция возвращает <strong>новый</strong> массив, оставляя исходный без изменений.</li>\n<li>Всё, что возвращает <code>callback</code> функция добавляется в новый массив.</li>\n<li>Функция принимает три аргумента: массив, по которому будет происходить итерация, <code>callback</code> фунцию, которая будет выполнена для каждого элемента массива, и значение, которое будет использовано <code>callback</code> функцией в качестве <code>this</code>.</li>\n<li><code>callback</code> функция, в свою очередь, также работает с тремя аргументами: текущий элемент массива, индекс элемента, ссылка на сам массив.</li>\n</ol>\n<p>Правил стало больше, но последними двумя мы уже пользовались при создании функции <code>each</code>, а, значит, вы уже знаете, как с ними справиться.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr, callback, thisArg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i, length = arr.length, results = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; length; i = i + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    results.push(callback.call(thisArg, arr[i], i, arr));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> results;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Менять исходный массив нельзя, поэтому нужно создать новый массив в самом начале выполнения функции <code>map</code>. Назовём его <code>results</code>. В созданный нами массив <code>results</code> при кажом выполнении будем добавлять результат выполнения функции <code>callback</code> с помощью метода <code>push</code>. После завершения последней итерации всё, что остаётся сделать — вернуть массив <code>results</code>.</p>\n<p>Написанная нами функция <code>map</code> работает точно так же, как и метод массивов <code>map</code>, но, как и <code>each</code>, может принимать в качестве аргументов любый другие коллекции.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pows = map([<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>], <span class=\"built_in\">Math</span>.pow);</span><br><span class=\"line\"><span class=\"keyword\">var</span> frameworks = map([<span class=\"string\">'Knockout'</span>, <span class=\"string\">'Backbone'</span>, <span class=\"string\">'Angular'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">framework</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> framework.slice(<span class=\"number\">0</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(pows); <span class=\"comment\">// [1,20,900]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(frameworks); <span class=\"comment\">// [\"Knock\",\"Backb\",\"Angul\"]</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>Небольшой совет</strong>: не используйте метод <code>map</code> для манипуляций с коллекциями DOM элементов, например, чтобы добавить класс всем элементам коллекции.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[].map.call(<span class=\"built_in\">document</span>.links, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">link</span>) </span>&#123;</span><br><span class=\"line\">  link.classList.add(<span class=\"string\">'link'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>Данный код сработает и всем ссылкам будет добавлен класс <code>link</code>, но пимимо этого будет создан дополнительный пустой массив, что скажется на производительности при большом объеме итерируемой коллекции. В подобных случаях следует использовать исключительно <code>forEach</code>.</p>\n<p>Тем не менее, <code>map</code> отлично подходит для получения данных из DOM коллекций. Например, получение всех <code>href</code> атрибутов будет выглядеть следующим образом:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> hrefs = [].map.call(<span class=\"built_in\">document</span>.links, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">link</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> link.href;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hrefs); <span class=\"comment\">// [\"http://google.ru\", \"http://jsraccoon.ru\" ...]</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h2><p>Метод <code>filter</code>, как и следует из названия, служит для фильтрации массива по правилам, заданным в <code>callback</code> функции. Так же, как в случае с <code>map</code> создаётся <strong>новый</strong> массив, куда добавляются все элементы прошедшие провеку колбэком.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> moreThanFive = [<span class=\"number\">1</span>, <span class=\"number\">20</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">24</span>, <span class=\"number\">6</span>, <span class=\"number\">45</span>].filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num &gt; <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(moreThanFive); <span class=\"comment\">// [20,24,6,45]</span></span><br></pre></td></tr></table></figure></p>\n<p>При использовании метода <code>filter</code> результатом выполнения может быть любое значение, но данные из исходного массива будут добавлены только в том случае, если значение является правдивым. Напомню, что правдивыми значениями являются все, кроме:</p>\n<ol>\n<li>пустой строки <code>&#39;&#39;</code></li>\n<li>числа ноль <code>0</code></li>\n<li><code>false</code></li>\n<li><code>undefined</code></li>\n<li><code>null</code></li>\n</ol>\n<p>Тем не менее, пользоваться подобным способом фильтрации массива не стоит в силу его неочевидности. Поэтому рекомендуется создавать <code>callback</code> функцию таким образом, чтобы она всегда возвращала либо <code>true</code>, либо <code>false</code>.</p>\n<p>Немного более сложный пример использования метода <code>filter</code>. Допустим, что мы получаем JSON файл с сервера с подобным содержимым:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&#123;<span class=\"string\">\"id\"</span>:<span class=\"number\">1</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Ernest\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"ebishop0@myspace.com\"</span>,<span class=\"string\">\"isCustomer\"</span>:<span class=\"literal\">false</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"id\"</span>:<span class=\"number\">2</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Michael\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"mturner1@multiply.com\"</span>,<span class=\"string\">\"isCustomer\"</span>:<span class=\"literal\">false</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"id\"</span>:<span class=\"number\">3</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Mildred\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"mwelch2@google.it\"</span>,<span class=\"string\">\"isCustomer\"</span>:<span class=\"literal\">false</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"id\"</span>:<span class=\"number\">4</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Jeremy\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"jwilson3@hostgator.com\"</span>,<span class=\"string\">\"isCustomer\"</span>:<span class=\"literal\">false</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"id\"</span>:<span class=\"number\">5</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Judy\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"jellis4@ameblo.jp\"</span>,<span class=\"string\">\"isCustomer\"</span>:<span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"id\"</span>:<span class=\"number\">6</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Judy\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"jrogers5@ow.ly\"</span>,<span class=\"string\">\"isCustomer\"</span>:<span class=\"literal\">false</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"id\"</span>:<span class=\"number\">7</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Chris\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"cbennett6@nasa.gov\"</span>,<span class=\"string\">\"isCustomer\"</span>:<span class=\"literal\">false</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"id\"</span>:<span class=\"number\">8</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Ruth\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"rmason7@simplemachines.org\"</span>,<span class=\"string\">\"isCustomer\"</span>:<span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"id\"</span>:<span class=\"number\">9</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Justin\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"jmedina8@indiegogo.com\"</span>,<span class=\"string\">\"isCustomer\"</span>:<span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"id\"</span>:<span class=\"number\">10</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Dennis\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"dflores9@g.co\"</span>,<span class=\"string\">\"isCustomer\"</span>:<span class=\"literal\">true</span>&#125;]</span><br></pre></td></tr></table></figure></p>\n<p>После получения данных (с помощью AJAX или JSONP, например) мы хотим их отфильтровать, узнав из свойства <code>isCustomer</code>, является ли данных человек нашим клиентом или нет. Вот здесь и пригодится метод <code>filter</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"comment\">// Получили данные с сервера и записали их в переменную data</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> customers = data.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> person.isCustomer;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(customers);</span><br><span class=\"line\"><span class=\"comment\">// [&#123;\"id\":5,\"name\":\"Judy\",\"email\":\"jellis4@ameblo.jp\",\"isCustomer\":true&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;\"id\":8,\"name\":\"Ruth\",\"email\":\"rmason7@simplemachines.org\",\"isCustomer\":true&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;\"id\":9,\"name\":\"Justin\",\"email\":\"jmedina8@indiegogo.com\",\"isCustomer\":true&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;\"id\":10,\"name\":\"Dennis\",\"email\":\"dflores9@g.co\",\"isCustomer\":true&#125;]</span></span><br></pre></td></tr></table></figure></p>\n<p>Или же можно руководствоваться немного другим, более сложным принципом при выборе цели. Например, мы решили, что если email клиента не начинается с буквы <code>j</code>, то он определённо нам не подходит.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"comment\">// Получили данные с сервера и записали их в переменную data</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> customers = data.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> person.email.charAt(<span class=\"number\">0</span>).toLowerCase() === <span class=\"string\">'j'</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(customers);</span><br><span class=\"line\"><span class=\"comment\">// [&#123;\"id\":4,\"name\":\"Jeremy\",\"email\":\"jwilson3@hostgator.com\",\"isCustomer\":false&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;\"id\":5,\"name\":\"Judy\",\"email\":\"jellis4@ameblo.jp\",\"isCustomer\":true&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;\"id\":6,\"name\":\"Judy\",\"email\":\"jrogers5@ow.ly\",\"isCustomer\":false&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;\"id\":9,\"name\":\"Justin\",\"email\":\"jmedina8@indiegogo.com\",\"isCustomer\":true&#125;]</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"filter-своими-руками\"><a href=\"#filter-своими-руками\" class=\"headerlink\" title=\"filter своими руками\"></a>filter своими руками</h2><p>Как и для прошлых функций <code>map</code> и <code>forEach</code> напишем небольшой свод правил:</p>\n<ol>\n<li>Функция возвращает <strong>новый</strong> массив, оставляя исходный без изменений.</li>\n<li>Данные исходного массива передаются в <code>callback</code> функцию. Результат выполнения <code>callback</code> функции решает будет ли добавлен данный элемент в новый массив.</li>\n<li>Функция принимает три аргумента: массив, по которому будет происходить итерация, <code>callback</code> фунцию, которая будет выполнена для каждого элемента массива, и значение, которое будет использовано <code>callback</code> функцией в качестве <code>this</code>.</li>\n<li><code>callback</code> функция, в свою очередь, также работает с тремя аргументами: текущий элемент массива, индекс элемента, ссылка на сам массив.</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> filter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr, callback, thisArg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i, length = arr.length, results = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; length; i = i + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (callback.call(thisArg, arr[i], i, arr)) &#123;</span><br><span class=\"line\">      results.push(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> results;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>С помощью всё того же метода функций <code>call</code> мы вызываем <code>callback</code> функцию, но на этот раз всё, что нас будет интересовать — вернула ли функция правдивое значение. Если результат содержит правдивое значение, то данные будут добавлены в массив, если же нет, то просто проигнорированы.</p>\n<p>Удостоверимся, что функция <code>filter</code> работает, как мы её и задумывали:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> strs = [<span class=\"string\">'Hello'</span>, <span class=\"string\">','</span>, <span class=\"string\">'JavaScript'</span>, <span class=\"string\">'World'</span>, <span class=\"string\">'!'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = filter(strs, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str.toLowerCase() !== str;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(data); <span class=\"comment\">// [\"Hello\",\"JavaScript\",\"World\"]</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>Небольшой хак</strong>: чтобы отфильтровать все ложные значения из массива можно воспользоваться конструктором <code>Boolean</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = [<span class=\"number\">32</span>, <span class=\"string\">''</span>, <span class=\"literal\">null</span>, <span class=\"string\">'JavaScript'</span>, <span class=\"literal\">undefined</span>, <span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> trueData = data.filter(<span class=\"built_in\">Boolean</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(trueData); <span class=\"comment\">// [32,\"JavaScript\"]</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"some-и-every\"><a href=\"#some-и-every\" class=\"headerlink\" title=\"some и every\"></a>some и every</h2><p>Методы <code>some</code> и <code>every</code> во многом похожи друг на друга. Оба метода возвращают <code>true</code> или <code>false</code>. <code>some</code> возвращает <code>true</code> тогда, когда хотя бы один элемент массива отвечает переданным в <code>callback</code> функцию условиям. <code>every</code> вернёт <code>true</code>, когда все элементы массива отвечают данным условиям. Звучит грозно, но, на самом деле всё очень просто.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fives = [<span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = fives.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">five</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> five === <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// false — в массиве же есть шестёрка</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fives = [<span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = fives.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">five</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> five === <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// true — теперь там только пятёрки, всё хорошо</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> nums = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = nums.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num &gt; <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// true — в массиве есть хотя бы одно значение больше 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> nums = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = nums.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num &lt; <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// false — в массиве нет ни одного значения меньше 5</span></span><br></pre></td></tr></table></figure></p>\n<p>Методы <code>some</code> и <code>every</code> очень удобно использовать вместе с методом <code>filter</code> для вложенных массивов. Чтобы понять, как это работает, опять представим, что мы получили данные с сервера в виде JSON файла, который содержит массив объектов (наших покупателей). У каждого покупателя есть свойство <code>purchases</code>, которое представляет собой список приобретённых покупателем товаров в нашем магазине ранее.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Wanda\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"wjenkins0@irs.gov\"</span>,<span class=\"string\">\"purchases\"</span>:[<span class=\"string\">'iPhone'</span>, <span class=\"string\">'dishwasher'</span>, <span class=\"string\">'cucumbers'</span>]&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Nicholas\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"nkennedy1@ox.ac.uk\"</span>,<span class=\"string\">\"purchases\"</span>:[<span class=\"string\">'tomatoes'</span>, <span class=\"string\">'toster'</span>, <span class=\"string\">'grill'</span>]&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Paula\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"pstephens2@boston.com\"</span>,<span class=\"string\">\"purchases\"</span>:[<span class=\"string\">'apples'</span>, <span class=\"string\">'Macbook'</span>, <span class=\"string\">'iPhone'</span>]&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Fred\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"fpeterson3@reuters.com\"</span>,<span class=\"string\">\"purchases\"</span>:[<span class=\"string\">'beef'</span>, <span class=\"string\">'pork'</span>, <span class=\"string\">'cheese'</span>]&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Andrew\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"awagner4@weebly.com\"</span>,<span class=\"string\">\"purchases\"</span>:[<span class=\"string\">'cottage cheese'</span>, <span class=\"string\">'cream'</span>, <span class=\"string\">'candies'</span>]&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Steven\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"sgonzales5@mashable.com\"</span>,<span class=\"string\">\"purchases\"</span>:[<span class=\"string\">'iMac'</span>, <span class=\"string\">'Android phone'</span>, <span class=\"string\">'Windows 10'</span>]&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Harry\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"hallen6@nasa.gov\"</span>,<span class=\"string\">\"purchases\"</span>:[<span class=\"string\">'green grape'</span>, <span class=\"string\">'tomatoes'</span>, <span class=\"string\">'potatoes'</span>]&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Bonnie\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"breyes7@kickstarter.com\"</span>,<span class=\"string\">\"purchases\"</span>:[<span class=\"string\">'Windows 10'</span>, <span class=\"string\">'dishwasher'</span>, <span class=\"string\">'grill'</span>]&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Lisa\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"lgreene8@spotify.com\"</span>,<span class=\"string\">\"purchases\"</span>:[<span class=\"string\">'pork'</span>, <span class=\"string\">'iMac'</span>, <span class=\"string\">'cheese'</span>]&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Wayne\"</span>,<span class=\"string\">\"email\"</span>:<span class=\"string\">\"wramos9@yahoo.com\"</span>,<span class=\"string\">\"purchases\"</span>:[<span class=\"string\">'apples'</span>, <span class=\"string\">'cream'</span>, <span class=\"string\">'candies'</span>]&#125;]</span><br></pre></td></tr></table></figure></p>\n<p>Чтобы понять, какие клиенты нам принесли больше всего прибыли, мы хотим их отфильтровать и посмотреть, кто из них покупал у нас технику от Apple (iPhone, Macbook или iMac). Метод <code>some</code> поможет сделать это с помощью всего нескольких строк кода.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"comment\">// Получили данные с сервера и записали их в переменную data</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> customers = data.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">customer</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> customer.purchases.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">purchase</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> purchase === <span class=\"string\">'iPhone'</span> || purchase === <span class=\"string\">'Macbook'</span> || purchase === <span class=\"string\">'iMac'</span>;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(customers);</span><br><span class=\"line\"><span class=\"comment\">// [&#123;\"name\":\"Wanda\",\"email\":\"wjenkins0@irs.gov\",\"purchases\":[\"iPhone\",\"dishwasher\",\"cucumbers\"]&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;\"name\":\"Paula\",\"email\":\"pstephens2@boston.com\",\"purchases\":[\"apples\",\"Macbook\",\"iPhone\"]&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;\"name\":\"Steven\",\"email\":\"sgonzales5@mashable.com\",\"purchases\":[\"iMac\",\"Android phone\",\"Windows 10\"]&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;\"name\":\"Lisa\",\"email\":\"lgreene8@spotify.com\",\"purchases\":[\"pork\",\"iMac\",\"cheese\"]&#125;]</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"some-и-every-своими-руками\"><a href=\"#some-и-every-своими-руками\" class=\"headerlink\" title=\"some и every своими руками\"></a>some и every своими руками</h2><p>Правила:</p>\n<ol>\n<li>Функция возвращает только <code>true</code> или <code>false</code></li>\n<li>Каждое значение передаётся в <code>callback</code> функцию и на результате её выполнения для <strong>всех</strong> элементов массива решается, какой будет результат.</li>\n<li>Функция принимает три аргумента: массив, по которому будет происходить итерация, <code>callback</code> фунцию, которая будет выполнена для каждого элемента массива, и значение, которое будет использовано <code>callback</code> функцией в качестве <code>this</code>.</li>\n<li><code>callback</code> функция, в свою очередь, также работает с тремя аргументами: текущий элемент массива, индекс элемента, ссылка на сам массив.</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> some = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr, callback, thisArg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i, length = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; length; i = i + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (callback.call(thisArg, arr[i], i, arr)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Функция <code>some</code> при каждой итерации проверяет, является ли результат выполнения <code>callback</code> функции правдивым. Если она находит хотя бы один правдивый результат, то прерывает своё выполнение и сразу возвращает <code>true</code>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> every = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr, callback, thisArg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i, length = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; length; i = i + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!callback.call(thisArg, arr[i], i, arr)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Функция <code>every</code> построена по противоположному принципу. Если хотя бы одно значение не является верным, то сразу же возвращается <code>false</code> без дальнейшего перебирания массива.</p>\n<p>Функции <code>every</code> и <code>some</code> работают идентично соответствующим им методам и будут давать одинаковые резутаты. Тем не менее, написанные нами функции работают лучше нативных методов. Почему? Используя методы массивов <code>some</code> и <code>every</code> вы подразумеваете, что <code>callback</code> функция будет выполнена для всех элементов без исключения. Но, может оказаться так, что первый элемент в массиве уже содержит нужные нам данные и итерация по всем остальным будет абсолютно бесполезной. В написанных нами функциях таких итераций не будет — когда будет найдено искомое значение функция сразу же прекратит своё выполнение. Подобный подход может дать достаточно ощутимый прирост производительности при работе с большими объемами данных, например, с JSON файлами содержащими несколько тысяч объектов.</p>\n<h2 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h2><p><code>callback</code> функция всех рассмотренных выше методов массивов работает с одинаковым набором данных: значением, индексом и массивом. Метод <code>reduce</code> не такой, как все. Принцип его работы немного отличается от всех остальных методов. Начнём сразу с примера:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nums = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = nums.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result, num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result + num;</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum); <span class=\"comment\">// 150 сумма всех элементов массива</span></span><br></pre></td></tr></table></figure></p>\n<p>Метод <code>reduce</code> принимает два аргумента <code>callback</code> функцию и начальное значение, которое будет присвоено аргументу <code>result</code> в примере выше при первой итерации. <code>callback</code> функция принимает целых 4 аргумента: промежуточное значение (аргумент <code>result</code> в примере выше), элемент массива, индекс элемента и сам массив. После каждой итерации в промежуточное значение записываются новые данные, которые берутся из результата выполнения функции <code>callback</code> при прошлой итерации:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nums = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = nums.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result, num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result + num;</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Будет выведено в консоль</span></span><br><span class=\"line\"><span class=\"comment\">// 0 начальное значение</span></span><br><span class=\"line\"><span class=\"comment\">// 10 начальное значение + первый элемент в массиве = промежуточное значение</span></span><br><span class=\"line\"><span class=\"comment\">// 30 промежуточное значение + второй элемент в массиве = промежуточное значение</span></span><br><span class=\"line\"><span class=\"comment\">// 60 и так далее</span></span><br><span class=\"line\"><span class=\"comment\">// 100</span></span><br></pre></td></tr></table></figure></p>\n<p>Разумеется, <code>reduce</code> может работать с любыми типами данных, не только с числами. Пример со строками (в данном случае в качестве начального значения стоит передавать пустую строку):<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> strs = [<span class=\"string\">'JavaScript'</span>, <span class=\"string\">'is'</span>, <span class=\"string\">'awesome'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = strs.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrase, word, index</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Перед первым словом не надо ставить пробел</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (index === <span class=\"number\">0</span>) ? phrase + word : phrase + <span class=\"string\">' '</span> + word;</span><br><span class=\"line\">&#125;, <span class=\"string\">''</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// JavaScript is awesome</span></span><br></pre></td></tr></table></figure></p>\n<p>Пример с многомерным массивом (начинаем с пустого массива):<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arrs = [[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"number\">4</span>, <span class=\"number\">5</span>], [<span class=\"number\">6</span>], [<span class=\"number\">7</span>, <span class=\"number\">8</span>], [<span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>]];</span><br><span class=\"line\"><span class=\"keyword\">var</span> concat = arrs.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result, current</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result.concat(current);</span><br><span class=\"line\">&#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(concat); <span class=\"comment\">// [1,2,3,4,5,6,7,8,9,10,11]</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"reduce-своими-руками\"><a href=\"#reduce-своими-руками\" class=\"headerlink\" title=\"reduce своими руками\"></a>reduce своими руками</h2><p>Вы уже знаете — у нас есть правила:</p>\n<ol>\n<li>Функция принимает три аргумента: массив, <code>callback</code> функцию, начальное значение.</li>\n<li>После каждой итерации в промежуточное значение перезаписывается значением, полученным в результате выполнения <code>callback</code> функции.<br>3.<code>callback</code> функция принимает четыре аргумента: промежуточное значение, текущий элемент массива, индекс элемента, ссылка на сам массив.</li>\n<li>Явно указать значение <code>this</code> нельзя.</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reduce = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr, callback, startValue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i, length = arr.length, result = startValue;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; length; i = i + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    result = callback.call(<span class=\"literal\">null</span>, result, arr[i], i, arr);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>В нативном методе указывать значение <code>this</code> нельзя, поэтому вместо введения в функцию ещё одного аргумента <code>thisArg</code> мы просто передаём <code>null</code> в вызов функции.</p>\n<p>Протестируем написанную нами функцию <code>reduce</code> на предыдущих примерах, чтобы убедиться, что всё работает, как мы и ожидаем.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arrs = [[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"number\">4</span>, <span class=\"number\">5</span>], [<span class=\"number\">6</span>], [<span class=\"number\">7</span>, <span class=\"number\">8</span>], [<span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>]];</span><br><span class=\"line\"><span class=\"keyword\">var</span> strs = [<span class=\"string\">'JavaScript'</span>, <span class=\"string\">'is'</span>, <span class=\"string\">'awesome'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> strResults = reduce(strs, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">phrase, word, index</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (index === <span class=\"number\">0</span>) ? phrase + word : phrase + <span class=\"string\">' '</span> + word;</span><br><span class=\"line\">&#125;, <span class=\"string\">''</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrResults = reduce(arrs, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result, current</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result.concat(current);</span><br><span class=\"line\">&#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(strResults); <span class=\"comment\">// JavaScript is awesome</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrResults); <span class=\"comment\">// [1,2,3,4,5,6,7,8,9,10,11]</span></span><br></pre></td></tr></table></figure></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ciohe4moc0000sspn0pjc7rwg","category_id":"cioii992q00026kpnkdrladun","_id":"cioii992s00036kpny4mahffv"},{"post_id":"ciok26pl900006gpnpwu7la6x","category_id":"cioii992q00026kpnkdrladun","_id":"ciok28tmq00026gpnz8lexnd4"},{"post_id":"ciok2o2ay00056gpndbrzo7zy","category_id":"cioii992q00026kpnkdrladun","_id":"ciok2osrl00086gpnira4lwe3"},{"post_id":"ciok3emeg00096gpnjk7o0esb","category_id":"cioii992q00026kpnkdrladun","_id":"ciok3ftmw000c6gpnddh6hs9q"}],"PostTag":[{"post_id":"ciohe4moc0000sspn0pjc7rwg","tag_id":"ciohe4mog0001sspnzvvrk5zq","_id":"cioin5jwx00086kpn45fz7ady"},{"post_id":"ciohe4moc0000sspn0pjc7rwg","tag_id":"ciohe4moj0002sspn217rmsxn","_id":"cioin5jwz00096kpn9qf2u2u0"},{"post_id":"ciok26pl900006gpnpwu7la6x","tag_id":"ciok28tmo00016gpn6dmtw46w","_id":"ciok28tmr00036gpnrtr3j4wh"},{"post_id":"ciok26pl900006gpnpwu7la6x","tag_id":"ciohe4moj0002sspn217rmsxn","_id":"ciok28tmr00046gpn5hll3s27"},{"post_id":"ciok2o2ay00056gpndbrzo7zy","tag_id":"ciok28tmo00016gpn6dmtw46w","_id":"ciok2osrl00066gpnpx00q6vu"},{"post_id":"ciok2o2ay00056gpndbrzo7zy","tag_id":"ciohe4moj0002sspn217rmsxn","_id":"ciok2osrl00076gpnga35t8fl"},{"post_id":"ciok3emeg00096gpnjk7o0esb","tag_id":"ciohe4moj0002sspn217rmsxn","_id":"ciok3ftmv000b6gpnyaqnw4xs"},{"post_id":"ciok3emeg00096gpnjk7o0esb","tag_id":"ciok3ga4h000d6gpnor0jurv0","_id":"ciok3ga4i000e6gpnqhmt5hk5"}],"Tag":[{"name":"ES6","_id":"ciohe4mog0001sspnzvvrk5zq"},{"name":"JavaScript","_id":"ciohe4moj0002sspn217rmsxn"},{"name":"hello","_id":"cioin5btn00046kpn8ctlw1y0"},{"name":"world","_id":"cioin5btp00056kpnmpg3fsdc"},{"name":"OOP","_id":"ciok28tmo00016gpn6dmtw46w"},{"name":"FN","_id":"ciok3ga4h000d6gpnor0jurv0"}]}}